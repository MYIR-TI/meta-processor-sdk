From 08830f046fc0db27869d9c8d2e48494bf2e4d2ba Mon Sep 17 00:00:00 2001
From: Pooja Prajod <a0132412@ti.com>
Date: Tue, 28 Apr 2015 20:15:52 +0530
Subject: [PATCH] gst-waylandsink: Cleanup buffer in NULL state

When the pipeline goes to NULL state from playing state,
the last buffer is not cleaned up and stays on surface.
This patch calls a display destrot function which cleans up the surface.

Signed-off-by: Pooja Prajod <a0132412@ti.com>
---
 ext/wayland/gstwaylandsink.c | 22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index dc83de7..93a6bda 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -97,6 +97,7 @@ static gboolean
 gst_wayland_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query);
 static gboolean gst_wayland_sink_render (GstBaseSink * bsink,
     GstBuffer * buffer);
+static gboolean gst_wayland_sink_stop (GstBaseSink * bsink);
 
 static struct display *create_display (void);
 static void registry_handle_global (void *data, struct wl_registry *registry,
@@ -184,6 +185,7 @@ gst_wayland_sink_class_init (GstWaylandSinkClass * klass)
   gstbasesink_class->propose_allocation =
       GST_DEBUG_FUNCPTR (gst_wayland_sink_propose_allocation);
   gstbasesink_class->render = GST_DEBUG_FUNCPTR (gst_wayland_sink_render);
+  gstbasesink_class->stop = GST_DEBUG_FUNCPTR (gst_wayland_sink_stop);
 
   g_object_class_install_property (gobject_class, PROP_WAYLAND_DISPLAY,
       g_param_spec_pointer ("wayland-display", "Wayland Display",
@@ -348,6 +350,9 @@ gst_wayland_sink_finalize (GObject * object)
 
   GST_DEBUG_OBJECT (sink, "Finalizing the sink..");
 
+  gst_buffer_replace (&sink->last_buf, NULL);
+  gst_buffer_replace (&sink->display_buf, NULL);
+
   if (sink->window)
     destroy_window (sink->window);
   if (sink->display)
@@ -358,14 +363,12 @@ gst_wayland_sink_finalize (GObject * object)
     gst_drm_buffer_pool_destroy (sink->drm_pool);
     sink->drm_pool = NULL;
   }
+
   if (sink->wlbufferpriv) {
     g_hash_table_destroy (sink->wlbufferpriv);
     sink->wlbufferpriv = NULL;
   }
 
-  gst_buffer_replace (&sink->last_buf, NULL);
-  gst_buffer_replace (&sink->display_buf, NULL);
-
   g_mutex_clear (&sink->wayland_lock);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
@@ -430,6 +433,7 @@ drm_handle_format (void *data, struct wl_drm *drm, uint32_t format)
   if (d->drm_format_count < 50) {
     d->drm_formats[d->drm_format_count++] = format;
   } else {
+    d->drm_formats[d->drm_format_count++] = format;
     GST_WARNING ("drm_handle_formats (no room for more formats): %"
         GST_FOURCC_FORMAT, GST_FOURCC_ARGS (format));
   }
@@ -962,6 +966,18 @@ gst_wayland_sink_start (GstBaseSink * bsink)
 }
 
 static gboolean
+gst_wayland_sink_stop (GstBaseSink * bsink)
+{
+  GstWaylandSink *sink = (GstWaylandSink *) bsink;
+  GST_DEBUG_OBJECT (sink, "stop");
+  gst_buffer_replace (&sink->last_buf, NULL);
+  gst_buffer_replace (&sink->display_buf, NULL);
+  if (sink->display)
+    destroy_display (sink->display);
+  return TRUE;
+}
+
+static gboolean
 gst_wayland_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
 {
   GstWaylandSink *sink = GST_WAYLAND_SINK (bsink);
-- 
1.7.12.4

