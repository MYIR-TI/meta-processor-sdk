diff --git a/gstwaylandsink.c b/gstwaylandsink.c
index 0ef1ef8..dc83de7 100644
--- a/gstwaylandsink.c
+++ b/gstwaylandsink.c
@@ -107,6 +107,9 @@ static void create_window (GstWaylandSink * sink, struct display *display,
     int width, int height);
 static void shm_pool_destroy (struct shm_pool *pool);
 
+static void input_grab (struct input *input, struct window *window);
+static void input_ungrab (struct input *input);
+
 typedef struct
 {
   uint32_t wl_format;
@@ -188,13 +191,13 @@ gst_wayland_sink_class_init (GstWaylandSinkClass * klass)
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
-/* Free function for key destruction for the hashtable we are using*/ 
+/* Free function for key destruction for the hashtable we are using*/
 static void
-wlbufferpriv_free_func (GstWLBufferPriv *priv)
+wlbufferpriv_free_func (GstWLBufferPriv * priv)
 {
   wl_buffer_destroy (priv->buffer);
   omap_bo_del (priv->bo);
-  g_free(priv);
+  g_free (priv);
 }
 
 static void
@@ -244,6 +247,54 @@ gst_wayland_sink_set_property (GObject * object,
 }
 
 static void
+input_grab (struct input *input, struct window *window)
+{
+  input->grab = window;
+}
+
+static void
+input_ungrab (struct input *input)
+{
+  input->grab = NULL;
+}
+
+static void
+input_remove_pointer_focus (struct input *input)
+{
+  struct window *window = input->pointer_focus;
+
+  if (!window)
+    return;
+
+  input->pointer_focus = NULL;
+}
+
+static void
+input_destroy (struct input *input)
+{
+  input_remove_pointer_focus (input);
+
+  if (input->display->seat_version >= 3) {
+    if (input->pointer)
+      wl_pointer_release (input->pointer);
+  }
+
+  wl_list_remove (&input->link);
+  wl_seat_destroy (input->seat);
+  free (input);
+}
+
+static void
+display_destroy_inputs (struct display *display)
+{
+  struct input *tmp;
+  struct input *input;
+
+  wl_list_for_each_safe (input, tmp, &display->input_list, link)
+      input_destroy (input);
+}
+
+static void
 destroy_display (struct display *display)
 {
   if (display->shm)
@@ -258,6 +309,7 @@ destroy_display (struct display *display)
   if (display->compositor)
     wl_compositor_destroy (display->compositor);
 
+  display_destroy_inputs (display);
   wl_display_flush (display->display);
   wl_display_disconnect (display->display);
   free (display);
@@ -306,7 +358,7 @@ gst_wayland_sink_finalize (GObject * object)
     gst_drm_buffer_pool_destroy (sink->drm_pool);
     sink->drm_pool = NULL;
   }
-  if (sink->wlbufferpriv){
+  if (sink->wlbufferpriv) {
     g_hash_table_destroy (sink->wlbufferpriv);
     sink->wlbufferpriv = NULL;
   }
@@ -378,8 +430,8 @@ drm_handle_format (void *data, struct wl_drm *drm, uint32_t format)
   if (d->drm_format_count < 50) {
     d->drm_formats[d->drm_format_count++] = format;
   } else {
-    GST_WARNING ("drm_handle_formats (no room for more formats): %" 
-                GST_FOURCC_FORMAT, GST_FOURCC_ARGS (format));
+    GST_WARNING ("drm_handle_formats (no room for more formats): %"
+        GST_FOURCC_FORMAT, GST_FOURCC_ARGS (format));
   }
 }
 
@@ -390,7 +442,8 @@ drm_handle_authenticated (void *data, struct wl_drm *drm)
   GST_DEBUG ("authenticated");
   d->dev = omap_device_new (d->fd);
   d->authenticated = 1;
-  GST_DEBUG("drm_handle_authenticated: dev: %p, d->authenticated: %d\n", d->dev, d->authenticated);
+  GST_DEBUG ("drm_handle_authenticated: dev: %p, d->authenticated: %d\n",
+      d->dev, d->authenticated);
 }
 
 static const struct wl_drm_listener drm_listener = {
@@ -399,7 +452,227 @@ static const struct wl_drm_listener drm_listener = {
   drm_handle_authenticated
 };
 
+static void
+pointer_handle_enter (void *data, struct wl_pointer *pointer,
+    uint32_t serial, struct wl_surface *surface,
+    wl_fixed_t sx_w, wl_fixed_t sy_w)
+{
+  struct input *input = data;
+
+  if (!surface) {
+    /* enter event for a window we've just destroyed */
+    return;
+  }
+
+  input->display->serial = serial;
+  input->pointer_focus = wl_surface_get_user_data (surface);
+}
+
+static void
+pointer_handle_leave (void *data, struct wl_pointer *pointer,
+    uint32_t serial, struct wl_surface *surface)
+{
+  struct input *input = data;
+
+  input_remove_pointer_focus (input);
+}
+
+static void
+pointer_handle_motion (void *data, struct wl_pointer *pointer,
+    uint32_t time, wl_fixed_t sx_w, wl_fixed_t sy_w)
+{
+  struct input *input = data;
+  struct window *window = input->pointer_focus;
+
+  if (!window)
+    return;
+
+  if (input->grab)
+    wl_shell_surface_move (input->grab->shell_surface, input->seat,
+        input->display->serial);
+
+}
+
+static void
+pointer_handle_button (void *data, struct wl_pointer *pointer, uint32_t serial,
+    uint32_t time, uint32_t button, uint32_t state_w)
+{
+  struct input *input = data;
+  enum wl_pointer_button_state state = state_w;
+  input->display->serial = serial;
+
+  if (button == BTN_LEFT) {
+    if (state == WL_POINTER_BUTTON_STATE_PRESSED)
+      input_grab (input, input->pointer_focus);
+
+    if (input->grab && state == WL_POINTER_BUTTON_STATE_RELEASED)
+      input_ungrab (input);
+  }
+
+  if (input->grab)
+    wl_shell_surface_move (input->grab->shell_surface, input->seat,
+        input->display->serial);
+}
+
+static void
+pointer_handle_axis (void *data, struct wl_pointer *pointer,
+    uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+  pointer_handle_enter,
+  pointer_handle_leave,
+  pointer_handle_motion,
+  pointer_handle_button,
+  pointer_handle_axis,
+};
+
+static void
+touch_handle_down (void *data, struct wl_touch *wl_touch,
+    uint32_t serial, uint32_t time, struct wl_surface *surface,
+    int32_t id, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+  struct input *input = data;
+  struct touch_point *tp;
+
+  input->display->serial = serial;
+  input->touch_focus = wl_surface_get_user_data (surface);
+  if (!input->touch_focus) {
+    return;
+  }
+
+  tp = malloc (sizeof *tp);
+  if (tp) {
+    tp->id = id;
+    wl_list_insert (&input->touch_point_list, &tp->link);
+    wl_shell_surface_move (input->touch_focus->shell_surface, input->seat,
+        serial);
+  }
+}
+
+static void
+touch_handle_motion (void *data, struct wl_touch *wl_touch,
+    uint32_t time, int32_t id, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+  struct input *input = data;
+  struct touch_point *tp;
+
+
+  if (!input->touch_focus) {
+    return;
+  }
+  wl_list_for_each (tp, &input->touch_point_list, link) {
+    if (tp->id != id)
+      continue;
+
+    wl_shell_surface_move (input->touch_focus->shell_surface, input->seat,
+        input->display->serial);
+
+    return;
+  }
+}
+
+static void
+touch_handle_frame (void *data, struct wl_touch *wl_touch)
+{
+}
+
+static void
+touch_handle_cancel (void *data, struct wl_touch *wl_touch)
+{
+}
+
+static void
+touch_handle_up (void *data, struct wl_touch *wl_touch,
+    uint32_t serial, uint32_t time, int32_t id)
+{
+  struct input *input = data;
+  struct touch_point *tp, *tmp;
+
+  if (!input->touch_focus) {
+    return;
+  }
+
+  wl_list_for_each_safe (tp, tmp, &input->touch_point_list, link) {
+    if (tp->id != id)
+      continue;
+
+    wl_list_remove (&tp->link);
+    free (tp);
+
+    return;
+  }
+}
+
+static const struct wl_touch_listener touch_listener = {
+  touch_handle_down,
+  touch_handle_up,
+  touch_handle_motion,
+  touch_handle_frame,
+  touch_handle_cancel,
+};
+
+
+
+static void
+seat_handle_capabilities (void *data, struct wl_seat *seat,
+    enum wl_seat_capability caps)
+{
+  struct input *input = data;
+
+  if ((caps & WL_SEAT_CAPABILITY_POINTER) && !input->pointer) {
+    input->pointer = wl_seat_get_pointer (seat);
+    wl_pointer_set_user_data (input->pointer, input);
+    wl_pointer_add_listener (input->pointer, &pointer_listener, input);
+  } else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && input->pointer) {
+    wl_pointer_destroy (input->pointer);
+    input->pointer = NULL;
+  }
+
+  if ((caps & WL_SEAT_CAPABILITY_TOUCH) && !input->touch) {
+    input->touch = wl_seat_get_touch (seat);
+    wl_touch_set_user_data (input->touch, input);
+    wl_touch_add_listener (input->touch, &touch_listener, input);
+  } else if (!(caps & WL_SEAT_CAPABILITY_TOUCH) && input->touch) {
+    wl_touch_destroy (input->touch);
+    input->touch = NULL;
+  }
+}
+
+static void
+seat_handle_name (void *data, struct wl_seat *seat, const char *name)
+{
 
+}
+
+static const struct wl_seat_listener seat_listener = {
+  seat_handle_capabilities,
+  seat_handle_name
+};
+
+static void
+display_add_input (struct display *d, uint32_t id)
+{
+  struct input *input;
+
+  input = calloc (1, sizeof (*input));
+  if (input == NULL) {
+    fprintf (stderr, "%s: out of memory\n", "gst-wayland-sink");
+    exit (EXIT_FAILURE);
+  }
+  input->display = d;
+  input->seat = wl_registry_bind (d->registry, id, &wl_seat_interface,
+      MAX (d->seat_version, 3));
+  input->touch_focus = NULL;
+  input->pointer_focus = NULL;
+  wl_list_init (&input->touch_point_list);
+  wl_list_insert (d->input_list.prev, &input->link);
+
+  wl_seat_add_listener (input->seat, &seat_listener, input);
+  wl_seat_set_user_data (input->seat, input);
+
+}
 
 static void
 registry_handle_global (void *data, struct wl_registry *registry,
@@ -418,6 +691,9 @@ registry_handle_global (void *data, struct wl_registry *registry,
   } else if (strcmp (interface, "wl_drm") == 0) {
     d->drm = wl_registry_bind (registry, id, &wl_drm_interface, 1);
     wl_drm_add_listener (d->drm, &drm_listener, d);
+  } else if (strcmp (interface, "wl_seat") == 0) {
+    d->seat_version = version;
+    display_add_input (d, id);
   }
 }
 
@@ -439,6 +715,8 @@ create_display (void)
   }
   display->authenticated = 0;
 
+  wl_list_init (&display->input_list);
+
   display->registry = wl_display_get_registry (display->display);
   wl_registry_add_listener (display->registry, &registry_listener, display);
 
@@ -474,12 +752,14 @@ gst_wayland_sink_format_from_caps (uint32_t * wl_format, GstCaps * caps)
 static void
 wait_authentication (GstWaylandSink * sink)
 {
-  GST_DEBUG_OBJECT (sink, "Before wait aunthenticated value is %d : \n", sink->display->authenticated );
+  GST_DEBUG_OBJECT (sink, "Before wait aunthenticated value is %d : \n",
+      sink->display->authenticated);
   while (!sink->display->authenticated) {
     GST_DEBUG_OBJECT (sink, "waiting for authentication");
     wl_display_roundtrip (sink->display->display);
   }
-  GST_DEBUG_OBJECT (sink, "After wait aunthenticated value is %d : \n", sink->display->authenticated );
+  GST_DEBUG_OBJECT (sink, "After wait aunthenticated value is %d : \n",
+      sink->display->authenticated);
 }
 
 /* create a drm buffer pool if the video format is NV12 */
@@ -498,7 +778,7 @@ create_pool (GstWaylandSink * sink, GstCaps * caps)
   if (!gst_video_info_from_caps (&info, caps))
     goto invalid_format;
 
-  
+
 
   if (sink->drm_pool) {
     GST_INFO_OBJECT (sink, "recreating pool");
@@ -511,12 +791,11 @@ create_pool (GstWaylandSink * sink, GstCaps * caps)
 
   sink->drm_pool = gst_drm_buffer_pool_new (GST_ELEMENT (sink),
       sink->display->fd, caps, info.size);
-  if(sink->drm_pool){
+  if (sink->drm_pool) {
     return TRUE;
-   }
-  else {
+  } else {
     return FALSE;
-   }
+  }
 
 invalid_format:
   {
@@ -535,7 +814,7 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
   GstStructure *structure;
   static GstAllocationParams params = { 0, 0, 0, 15, };
   guint size;
- GstVideoFormat fmt;
+  GstVideoFormat fmt;
 
   sink = GST_WAYLAND_SINK (bsink);
 
@@ -544,11 +823,12 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
   if (!gst_video_info_from_caps (&info, caps))
     goto invalid_format;
 
-  fmt = GST_VIDEO_INFO_FORMAT(&info);
-  if (fmt == GST_VIDEO_FORMAT_NV12 ||  fmt == GST_VIDEO_FORMAT_I420 || fmt == GST_VIDEO_FORMAT_YUY2 || fmt == GST_VIDEO_FORMAT_UYVY){
-    create_pool(sink, caps);
+  fmt = GST_VIDEO_INFO_FORMAT (&info);
+  if (fmt == GST_VIDEO_FORMAT_NV12 || fmt == GST_VIDEO_FORMAT_I420
+      || fmt == GST_VIDEO_FORMAT_YUY2 || fmt == GST_VIDEO_FORMAT_UYVY) {
+    create_pool (sink, caps);
     return TRUE;
-  } 
+  }
 
   if (!gst_wayland_sink_format_from_caps (&sink->format, caps))
     goto invalid_format;
@@ -643,6 +923,8 @@ create_window (GstWaylandSink * sink, struct display *display, int width,
 
   window->surface = wl_compositor_create_surface (display->compositor);
 
+  wl_surface_set_user_data (window->surface, window);
+
   window->shell_surface = wl_shell_get_shell_surface (display->shell,
       window->surface);
 
@@ -790,22 +1072,22 @@ gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
   struct display *display;
   GstWLBufferPriv *priv;
   GstMapInfo mapsrc;
-  
+
   GST_LOG_OBJECT (sink, "render buffer %p", buffer);
-  if (!sink->window){
+  if (!sink->window) {
     gint video_width = sink->video_width;
     gint video_height = sink->video_height;
-    GstVideoCropMeta* crop = gst_buffer_get_video_crop_meta (buffer);
-    if(crop){
-       if (crop->width) {
-         video_width = crop->width;
-       } 
-      if (crop->height) {  
-         video_height = crop->height;
-       }
+    GstVideoCropMeta *crop = gst_buffer_get_video_crop_meta (buffer);
+    if (crop) {
+      if (crop->width) {
+        video_width = crop->width;
+      }
+      if (crop->height) {
+        video_height = crop->height;
+      }
     }
     create_window (sink, sink->display, video_width, video_height);
-   }
+  }
 
   window = sink->window;
   display = sink->display;
@@ -817,13 +1099,14 @@ gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
     wl_display_dispatch (display->display);
   }
 
-  
+
   if (meta && meta->sink == sink) {
     GST_LOG_OBJECT (sink, "buffer %p from our pool, writing directly", buffer);
     to_render = buffer;
-  } else if(priv) {
+  } else if (priv) {
     to_render = buffer;
-    GST_LOG_OBJECT (sink, " priv buffer %p from drm pool, writing directly", buffer);
+    GST_LOG_OBJECT (sink, " priv buffer %p from drm pool, writing directly",
+        buffer);
   } else {
     GST_LOG_OBJECT (sink, "buffer %p not from our pool, copying", buffer);
 
@@ -852,12 +1135,12 @@ gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
   gst_video_sink_center_rect (src, dst, &res, FALSE);
 
   /* display the buffer stored in priv, if the buffer obtained returns a priv */
-  if(priv){
-   wl_surface_attach (sink->window->surface, priv->buffer, res.x, res.y);
+  if (priv) {
+    wl_surface_attach (sink->window->surface, priv->buffer, res.x, res.y);
   } else {
-  wl_surface_attach (sink->window->surface, meta->wbuffer, 0, 0);
+    wl_surface_attach (sink->window->surface, meta->wbuffer, 0, 0);
   }
-  
+
   wl_surface_damage (sink->window->surface, 0, 0, res.w, res.h);
   window->redraw_pending = TRUE;
   window->callback = wl_surface_frame (window->surface);
diff --git a/gstwaylandsink.h b/gstwaylandsink.h
index b3cef2a..fee7c1c 100644
--- a/gstwaylandsink.h
+++ b/gstwaylandsink.h
@@ -57,6 +57,27 @@
 #define GST_WAYLAND_SINK_GET_CLASS(inst) \
         (G_TYPE_INSTANCE_GET_CLASS ((inst), GST_TYPE_WAYLAND_SINK, GstWaylandSinkClass))
 
+struct touch_point
+{
+  int32_t id;
+  struct wl_list link;
+};
+	
+struct input
+{
+  struct display *display;
+  struct wl_seat *seat;
+  struct wl_pointer *pointer;
+  struct wl_touch *touch;
+  struct wl_list touch_point_list;
+  struct window *pointer_focus;
+  struct window *touch_focus;
+  struct wl_list link;	
+  struct window *grab;
+	
+};
+
+
 struct  display
 {
   struct wl_display *display;
@@ -69,6 +90,11 @@ struct  display
 
   uint32_t drm_formats[50];
   int drm_format_count;
+	
+  struct wl_list input_list;
+  int seat_version;
+  uint32_t serial;
+
   /* the drm device.. needed for sharing direct-render buffers..
    * TODO nothing about this should really be omapdrm specific.  But some
    * of the code, like hashtable of imported buffers in libdrm_omap should
