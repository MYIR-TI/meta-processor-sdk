From b6871c22bcb09fcc15b9d77cd0030118c463b3da Mon Sep 17 00:00:00 2001
From: Pooja Prajod <a0132412@ti.com>
Date: Thu, 16 Apr 2015 21:45:20 +0530
Subject: [PATCH] Improvise DRM bufferpool to solve memory leak

The DRM bufferpool was not deleting omap bo created during allocation.
This causes memory leak. This patch saves the bo as a metadata on buffer
which can be deleted while freeing the buffer.

Signed-off-by: Pooja Prajod <a0132412@ti.com>

SOlve DRM pool memleak

Signed-off-by: Pooja Prajod <a0132412@ti.com>
---
 gst-libs/gst/drm/gstdrmbufferpool.c | 81 ++++++++++++++++++++++++++++++++-----
 gst-libs/gst/drm/gstdrmbufferpool.h |  7 ++++
 2 files changed, 79 insertions(+), 9 deletions(-)

diff --git a/gst-libs/gst/drm/gstdrmbufferpool.c b/gst-libs/gst/drm/gstdrmbufferpool.c
index 6ac8044..3ce0dfe 100644
--- a/gst-libs/gst/drm/gstdrmbufferpool.c
+++ b/gst-libs/gst/drm/gstdrmbufferpool.c
@@ -52,6 +52,70 @@ static GstFlowReturn gst_drm_alloc_new_buffer (GstBufferPool * pool, GstBuffer *
 G_DEFINE_TYPE (GstDRMBufferPool, gst_drm_buffer_pool, GST_TYPE_BUFFER_POOL);
 
 
+static GType gst_meta_DRM_buffer_api_get_type (void);
+#define GST_META_DRM_BUFFER_API_TYPE (gst_meta_DRM_buffer_api_get_type())
+
+static const GstMetaInfo *gst_meta_DRM_buffer_get_info (void);
+#define GST_META_DRM_BUFFER_INFO (gst_meta_DRM_buffer_get_info())
+
+#define GST_META_DRM_BUFFER_GET(buf) ((GstMetaDRMBuffer *)gst_buffer_get_meta(buf,GST_META_DRM_BUFFER_API_TYPE))
+#define GST_META_DRM_BUFFER_ADD(buf) ((GstMetaDRMBuffer *)gst_buffer_add_meta(buf,GST_META_DRM_BUFFER_INFO,NULL))
+
+
+static gboolean
+drmbuffer_init_func (GstMeta * meta, gpointer params, GstBuffer * buffer)
+{
+  GST_DEBUG ("init called on buffer %p, meta %p", buffer, meta);
+  /* nothing to init really, the init function is mostly for allocating
+   * additional memory or doing special setup as part of adding the metadata to
+   * the buffer*/
+  return TRUE;
+}
+
+static void
+drmbuffer_free_func (GstMeta * drmmeta, GstBuffer * buffer)
+{
+  GstMetaDRMBuffer *meta = (GstMetaDRMBuffer *) drmmeta;
+
+    /* Free the DRM buffer */
+    omap_bo_del (meta->bo);
+}
+
+static gboolean
+drmbuffer_transform_func (GstBuffer * transbuf, GstMeta * meta,
+    GstBuffer * buffer, GQuark type, gpointer data)
+{
+  return FALSE;
+}
+
+static GType
+gst_meta_DRM_buffer_api_get_type (void)
+{
+  static volatile GType type;
+  static const gchar *tags[] = { "drmbuffer", NULL };
+
+  if (g_once_init_enter (&type)) {
+    GType _type = gst_meta_api_type_register ("GstMetaDRMBufferAPI", tags);
+    g_once_init_leave (&type, _type);
+  }
+  return type;
+}
+
+static const GstMetaInfo *
+gst_meta_DRM_buffer_get_info (void)
+{
+  static const GstMetaInfo *meta_drm_buffer_info = NULL;
+
+  if (g_once_init_enter (&meta_drm_buffer_info)) {
+    const GstMetaInfo *mi = gst_meta_register (GST_META_DRM_BUFFER_API_TYPE,
+        "GstMetaDRMBuffer",
+        sizeof (GstMetaDRMBuffer),
+        drmbuffer_init_func, drmbuffer_free_func, drmbuffer_transform_func);
+    g_once_init_leave (&meta_drm_buffer_info, mi);
+  }
+  return meta_drm_buffer_info;
+}
+
 /**
  * gst_drm_buffer_pool_set_config:
  * @pool: a #GstBufferPool
@@ -190,7 +254,7 @@ gst_drm_buffer_pool_new (GstElement * element,
       "Creating DRM buffer pool with caps %" GST_PTR_FORMAT, caps);
 
   gst_drm_buffer_pool_initialize (self, element, fd, caps, size);
-  
+  gst_buffer_pool_set_active (GST_BUFFER_POOL(self), TRUE);
   return self;
 }
 
@@ -252,7 +316,6 @@ gst_drm_buffer_pool_destroy (GstDRMBufferPool * self)
  /* Sets the buffer pool active to FALSE. Unrefs the buffer pool.
     If the the ref_count becomes zero, all buffers are freed and the bufferpool is destroyed */  
  if(GST_OBJECT_REFCOUNT(self)) {
-  gst_buffer_pool_set_active (GST_BUFFER_POOL(self), FALSE);
   gst_object_unref (self);
   }
 }
@@ -277,9 +340,6 @@ gst_drm_buffer_pool_get (GstDRMBufferPool * self, gboolean force_alloc)
   GstBuffer *buf = NULL; 
   g_return_val_if_fail (self, NULL);
 
-  /* Set the buffer pool to active so that acquire_buffer() is not blocked */
-  gst_buffer_pool_set_active (GST_BUFFER_POOL(self), TRUE);
-
   /* re-use a buffer off the queued buffers of pool if any are available */
   if (!force_alloc) {
      gst_buffer_pool_acquire_buffer (GST_BUFFER_POOL (self), &buf, NULL);
@@ -287,10 +347,7 @@ gst_drm_buffer_pool_get (GstDRMBufferPool * self, gboolean force_alloc)
      GST_BUFFER_POOL_CLASS(GST_DRM_BUFFER_POOL_GET_CLASS (self))->alloc_buffer(GST_BUFFER_POOL (self), &buf, NULL);
 
   }
-    
-  /* Set the buffer pool active to FALSE */
-  gst_buffer_pool_set_active (GST_BUFFER_POOL(self), FALSE);
-    
+       
   GST_LOG_OBJECT (self->element, "returning buf %p", buf);
 
   return GST_BUFFER (buf);
@@ -330,6 +387,7 @@ gst_drm_buffer_pool_finalize (GObject * pool)
     gst_object_unref (self->element);
   if (self->dev)
    omap_device_del (self->dev);
+
   G_OBJECT_CLASS (gst_drm_buffer_pool_parent_class)->finalize(pool);
 }
 
@@ -378,6 +436,9 @@ gst_drm_alloc_new_buffer (GstBufferPool * bufpool, GstBuffer ** buffer,
   GstVideoCropMeta *crop;
   GstMetaDmaBuf *dmabuf;
   GstVideoMeta *videometa;
+  GstMetaDRMBuffer *drmbuf;
+
+  drmbuf = GST_META_DRM_BUFFER_ADD (buf);
 
   /* TODO: if allocation could be handled via libkms then this
    * bufferpool implementation could be completely generic..
@@ -391,6 +452,8 @@ gst_drm_alloc_new_buffer (GstBufferPool * bufpool, GstBuffer ** buffer,
     return GST_FLOW_ERROR;;
   }
 
+  drmbuf->bo = bo;
+
   /* allocating a memory to the buffer we created */
   gst_buffer_append_memory (buf,
       gst_memory_new_wrapped (GST_MEMORY_FLAG_NO_SHARE, omap_bo_map (bo),
diff --git a/gst-libs/gst/drm/gstdrmbufferpool.h b/gst-libs/gst/drm/gstdrmbufferpool.h
index a9f3fba..b86ec0e 100644
--- a/gst-libs/gst/drm/gstdrmbufferpool.h
+++ b/gst-libs/gst/drm/gstdrmbufferpool.h
@@ -53,6 +53,13 @@ typedef struct _GstDRMBufferPool GstDRMBufferPool;
 typedef struct _GstDRMBufferPoolClass GstDRMBufferPoolClass;
 
 
+typedef struct
+{
+  GstMeta meta;
+  struct omap_bo *bo;
+} GstMetaDRMBuffer;
+
+
 /*
  * GstDRMBufferPool:
  */
-- 
1.7.12.4

