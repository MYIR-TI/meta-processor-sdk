From f383ddedeb19e87d987b4146a20b7c9e7ea2808e Mon Sep 17 00:00:00 2001
From: Manisha Agrawal <manisha.agrawal@ti.com>
Date: Fri, 18 May 2018 09:23:31 -0400
Subject: [PATCH] eglfs_kms: enhance the QPA for multiple display and user
 buffer

Enhance the QPA to support multiple screens and to accept the buffers
from user application to overlay on QT drawn surface utilizing the
underneath display IP scaling, overlaying and alphablending feature.

This QPA has following limitations -
1. It only supports importing user overlay buffer. It doesn't
suport allocating the buffer for overlay plane inside QPA and exporting to user
application.
2. Dynamic creation and destruction of user plane (createPlane,
distroyPlane) is not supported. Meaning you can create the plane once
at the start of application and destroy it before exiting the
application.
3. There is an API called startDispPlane which will trigger displaying
of user/overlay plane. There is no corresponding API as stopDispPlane to
stop displaying of user/overlay plane.

Signed-off-by: Manisha Agrawal <manisha.agrawal@ti.com>
---
 src/platformsupport/kmsconvenience/qkmsdevice.cpp  | 208 +++++++++++++++-
 src/platformsupport/kmsconvenience/qkmsdevice_p.h  |  14 +-
 .../eglfs/api/qeglfsdeviceintegration.cpp          |  87 +++++++
 .../eglfs/api/qeglfsdeviceintegration_p.h          |  14 ++
 .../platforms/eglfs/api/qeglfsintegration.cpp      | 106 +++++++-
 .../eglfs_kms/qeglfskmsgbmdevice.cpp               |  63 +++--
 .../eglfs_kms/qeglfskmsgbmdevice.h                 |  16 +-
 .../eglfs_kms/qeglfskmsgbmintegration.cpp          | 103 ++++++++
 .../eglfs_kms/qeglfskmsgbmintegration.h            |  13 +
 .../eglfs_kms/qeglfskmsgbmscreen.cpp               | 270 +++++++++++++++++++--
 .../eglfs_kms/qeglfskmsgbmscreen.h                 |  39 +++
 11 files changed, 886 insertions(+), 47 deletions(-)

diff --git a/src/platformsupport/kmsconvenience/qkmsdevice.cpp b/src/platformsupport/kmsconvenience/qkmsdevice.cpp
index a8eefe6..a6478ed 100644
--- a/src/platformsupport/kmsconvenience/qkmsdevice.cpp
+++ b/src/platformsupport/kmsconvenience/qkmsdevice.cpp
@@ -61,6 +61,179 @@ enum OutputConfiguration {
     OutputConfigModeline
 };
 
+int QKmsDevice::getDrmPropId(drmModeObjectPropertiesPtr props,
+                                  const char *name, uint32_t *propId)
+{
+    drmModePropertyPtr p;
+    unsigned int i;
+    *propId = 0;/* Property ID should always be > 0 */
+
+    for (i = 0; i < props->count_props; i++) {
+        p = drmModeGetProperty(m_dri_fd, props->props[i]);
+        if (!strcmp(p->name, name)){
+            *propId = p->prop_id;
+            break;
+        }
+        drmModeFreeProperty(p);
+    }
+    if (!*propId) {
+        qWarning() << "getDrmPropId: Could not find" <<  name << "property";
+        return(-1);
+    }
+
+    return i;
+}
+
+int QKmsDevice::setPlaneProperties(uint32_t objectType, uint32_t crtcId,
+                                        uint32_t planeId, uint8_t num_prop, const char **propName,
+                                        uint32_t *propVal)
+{
+    int ret, i;
+    uint32_t objectId;
+    if(objectType == DRM_MODE_OBJECT_PLANE){
+        objectId = planeId;
+    }
+    else{
+        objectId = crtcId;
+    }
+    drmModeObjectProperties	*props = drmModeObjectGetProperties(m_dri_fd, objectId,
+        objectType);
+
+    if(props == NULL){
+        qWarning() << "setPlaneProperties: drm object properties for objectId" << objectId << "is NULL";
+        return (-1);
+    }
+
+    drmModeAtomicReqPtr req = drmModeAtomicAlloc();
+    uint32_t propId;
+
+    for(i = 0; i < num_prop; i++)
+    {
+        if (getDrmPropId(props, propName[i], &propId) < 0){
+            qWarning() << "setPlaneProperties: failed to get the DRM property id for " <<  propName[i];
+            goto error_exit;
+        }
+        if(drmModeAtomicAddProperty(req, objectId, propId, propVal[i]) < 0){
+            qWarning() << "setPlaneProperties: failed to add DRM property for" << propName[i];
+            goto error_exit;
+        }
+    }
+
+    if(objectType == DRM_MODE_OBJECT_PLANE){
+        if(getDrmPropId(props, "CRTC_ID", &propId) < 0){
+            qWarning() << "setPlaneProperties: failed to get the DRM property id for CRTC_ID";
+            goto error_exit;
+        }
+        if(drmModeAtomicAddProperty(req, planeId, propId, crtcId) < 0){
+            qWarning() << "setPlaneProperties: failed to add DRM property for CRTC_ID";
+            goto error_exit;
+        }
+    }
+
+    ret = drmModeAtomicCommit(m_dri_fd, req, DRM_MODE_ATOMIC_TEST_ONLY, 0);
+
+    if(!ret){
+        drmModeAtomicCommit(m_dri_fd, req, 0, 0);
+    }
+    else{
+        qWarning() << "setPlaneProperties: ret from drmModeAtomicCommit = " <<  ret;
+        goto error_exit;
+    }
+
+    drmModeAtomicFree(req);
+    drmModeFreeObjectProperties(props);
+    return 0;
+
+error_exit:
+    drmModeAtomicFree(req);
+    drmModeFreeObjectProperties(props);
+    return -1;
+}
+
+int QKmsDevice::getPlaneProperty(uint32_t objectType, uint32_t planeId,
+                                      const char *propName)
+{
+    uint32_t propId;
+    int propVal = -1, propIndx;
+
+    drmModeObjectProperties	*props = drmModeObjectGetProperties(m_dri_fd, planeId,
+        objectType);
+
+    if(props == NULL){
+        qWarning() << "getPlaneProperty: drm obeject properties for plane type is NULL\n";
+        return (-1);
+    }
+
+    propIndx = getDrmPropId(props, propName, &propId);
+
+    if(propIndx >= 0){
+        propVal = props->prop_values[propIndx];
+    }
+    else{
+        qWarning() << "getPlaneProperty: Couldn't get DRM plane property for" << *propName;
+        return -1;
+    }
+    drmModeFreeObjectProperties(props);
+
+    return propVal;
+}
+
+int QKmsDevice::getPlane(uint32_t crtc_id, uint8_t planeType)
+{
+    uint32_t i;
+    drmModeObjectProperties *props;
+    drmModePlaneRes *res = drmModeGetPlaneResources(m_dri_fd);
+
+    if(res == NULL){
+        qWarning() << "plane resources not found\n";
+        return -1;
+    }
+
+    for (i = 0; i < res->count_planes; i++) {
+        uint32_t planeId = res->planes[i];
+        unsigned int typeVal;
+
+        drmModePlane *plane = drmModeGetPlane(m_dri_fd, planeId);
+        if(plane == NULL){
+            qWarning() << "getPlane: Plane not found";
+            goto error_exit;
+        }
+
+        props = drmModeObjectGetProperties(m_dri_fd, plane->plane_id, DRM_MODE_OBJECT_PLANE);
+
+        if(props == NULL){
+            qWarning() << "getPlane: plane (%d) properties not found\n" << plane->plane_id;
+            drmModeFreePlane(plane);
+            goto error_exit;
+        }
+
+        typeVal = getPlaneProperty(DRM_MODE_OBJECT_PLANE, plane->plane_id, "type");
+
+        drmModeFreeObjectProperties(props);
+        drmModeFreePlane(plane);
+
+        if(typeVal == planeType){
+            if(planeType == DRM_PLANE_TYPE_PRIMARY){
+                if((plane->crtc_id == crtc_id) || (!plane->crtc_id)){
+                    plane->crtc_id = crtc_id;
+                    drmModeFreePlaneResources(res);
+                    return planeId;
+                }
+            }
+            else if (!(m_plane_allocator & ((quint64)1<<planeId))){
+                m_plane_allocator |= ((quint64)1 << planeId);
+                drmModeFreePlaneResources(res);
+                return planeId;
+            }
+        }
+    }
+
+    qWarning("getPlane: Plane for crtc %d not found", crtc_id);
+error_exit:
+    drmModeFreePlaneResources(res);
+    return -1;
+}
+
 int QKmsDevice::crtcForConnector(drmModeResPtr resources, drmModeConnectorPtr connector)
 {
     for (int i = 0; i < connector->count_encoders; i++) {
@@ -175,6 +348,7 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
     OutputConfiguration configuration;
     QSize configurationSize;
     drmModeModeInfo configurationModeline;
+    int primary_plane_id;
 
     auto userConfig = m_screenConfig->outputSettings();
     auto userConnectorConfig = userConfig.value(QString::fromUtf8(connectorName));
@@ -286,14 +460,14 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
 
     int selected_mode = -1;
 
-    if (configured >= 0)
-        selected_mode = configured;
+    if (current >= 0)
+        selected_mode = current;
     else if (preferred >= 0)
         selected_mode = preferred;
-    else if (current >= 0)
-        selected_mode = current;
     else if (best >= 0)
         selected_mode = best;
+    else if (configured >= 0)
+        selected_mode = configured;
 
     if (selected_mode < 0) {
         qWarning() << "No modes available for output" << connectorName;
@@ -306,6 +480,12 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
                                   << '@' << refresh << "hz for output" << connectorName;
     }
 
+    primary_plane_id = getPlane(crtc_id, DRM_PLANE_TYPE_PRIMARY);
+
+    if(primary_plane_id < 0){
+        return Q_NULLPTR;
+    }
+
     // physical size from connector < config values < env vars
     int pwidth = qEnvironmentVariableIntValue("QT_QPA_EGLFS_PHYSICAL_WIDTH");
     if (!pwidth)
@@ -337,7 +517,8 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
         connectorProperty(connector, QByteArrayLiteral("DPMS")),
         false,
         0,
-        false
+        false,
+        primary_plane_id
     };
 
     bool ok;
@@ -363,6 +544,19 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
     m_crtc_allocator |= (1 << output.crtc_id);
     m_connector_allocator |= (1 << output.connector_id);
 
+    drmModeObjectProperties	*props = drmModeObjectGetProperties(m_dri_fd, primary_plane_id,
+        DRM_MODE_OBJECT_PLANE);
+    if(props == NULL){
+		qWarning() << "drm object properties for planeId:" << primary_plane_id << "is NULL";
+        return NULL;
+    }
+
+    if(getDrmPropId(props, "FB_ID", &m_prop_fbId) < 0){
+        drmModeFreeObjectProperties(props);
+        qWarning() << "Couldn't get DRM property id for FB_ID";
+        return NULL;
+    }
+    drmModeFreeObjectProperties(props);
     return createScreen(output);
 }
 
@@ -383,11 +577,13 @@ drmModePropertyPtr QKmsDevice::connectorProperty(drmModeConnectorPtr connector,
 }
 
 QKmsDevice::QKmsDevice(QKmsScreenConfig *screenConfig, const QString &path)
-    : m_screenConfig(screenConfig)
+    : m_prop_fbId(0)
+    , m_screenConfig(screenConfig)
     , m_path(path)
     , m_dri_fd(-1)
     , m_crtc_allocator(0)
     , m_connector_allocator(0)
+    , m_plane_allocator(0)
 {
     if (m_path.isEmpty()) {
         m_path = m_screenConfig->devicePath();
diff --git a/src/platformsupport/kmsconvenience/qkmsdevice_p.h b/src/platformsupport/kmsconvenience/qkmsdevice_p.h
index 35a51c1..e645157 100644
--- a/src/platformsupport/kmsconvenience/qkmsdevice_p.h
+++ b/src/platformsupport/kmsconvenience/qkmsdevice_p.h
@@ -109,6 +109,7 @@ struct QKmsOutput
     bool wants_plane;
     uint32_t plane_id;
     bool plane_set;
+    uint32_t primary_plane_id;
 
     void restoreMode(QKmsDevice *device);
     void cleanup(QKmsDevice *device);
@@ -139,6 +140,12 @@ public:
     QString devicePath() const;
 
     QKmsScreenConfig *screenConfig() const;
+    int setPlaneProperties(uint32_t objectType, uint32_t crtcId, uint32_t planeId,
+        uint8_t numProp, const char **propName, uint32_t *propVal);
+    int getPlaneProperty(uint32_t objectType, uint32_t planeId,
+        const char *propName);
+    int getPlane(uint32_t crtcId, uint8_t planeType);
+    uint32_t m_prop_fbId;
 
 protected:
     virtual QPlatformScreen *createScreen(const QKmsOutput &output) = 0;
@@ -158,10 +165,13 @@ protected:
     QString m_path;
     int m_dri_fd;
 
-    quint32 m_crtc_allocator;
-    quint32 m_connector_allocator;
+    quint64 m_crtc_allocator;
+    quint64 m_connector_allocator;
+    quint64 m_plane_allocator;
 
 private:
+    int getDrmPropId(drmModeObjectPropertiesPtr props,
+        const char *name, unsigned int *propId);
     Q_DISABLE_COPY(QKmsDevice)
 };
 
diff --git a/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp b/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
index e411ea5..1722d74 100644
--- a/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
+++ b/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
@@ -374,4 +374,91 @@ EGLConfig QEglFSDeviceIntegration::chooseConfig(EGLDisplay display, const QSurfa
     return chooser.chooseConfig();
 }
 
+int QEglFSDeviceIntegration::exportBuffer(const QScreen *screen, uint32_t width, uint32_t height,
+                                        uint32_t pixel_format, uint32_t *strides, uint32_t *offsets,
+                                        uint32_t buf_fd, uint32_t *bufId)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(width);
+    Q_UNUSED(height);
+    Q_UNUSED(pixel_format);
+    Q_UNUSED(strides);
+    Q_UNUSED(offsets);
+    Q_UNUSED(buf_fd);
+    Q_UNUSED(bufId);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::distroyBuffer(const QScreen *screen, uint32_t bufId)
+{
+    Q_UNUSED(screen)
+        Q_UNUSED(bufId);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::setPlaneProperties(const QScreen *screen,
+                                              uint8_t planeType, uint8_t idx, uint8_t numProp,
+                                              const char **propName, uint32_t *propVal)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(planeType);
+    Q_UNUSED(idx);
+    Q_UNUSED(numProp);
+    Q_UNUSED(propName);
+    Q_UNUSED(propVal);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::getPlaneProperty(const QScreen *screen,
+                                            uint8_t planeType, uint8_t idx,
+                                            const char *propName)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(planeType);
+    Q_UNUSED(idx);
+    Q_UNUSED(propName);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::createPlane(const QScreen *screen)
+{
+    Q_UNUSED(screen);
+    return -1;
+}
+
+int QEglFSDeviceIntegration::distroyPlane(const QScreen *screen, int planeId)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(planeId);
+    return -1;
+}
+
+int QEglFSDeviceIntegration::queuePlane(QScreen *screen,
+                                      uint32_t idx, uint32_t fbId)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(idx);
+    Q_UNUSED(fbId);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::startDispPlane(QScreen *screen)
+{
+    Q_UNUSED(screen);
+	return -1;
+}
+
+int QEglFSDeviceIntegration::userCallBackHandle(QScreen *screen, void (*fnPtr)(void *), void *data)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(fnPtr);
+    Q_UNUSED(data);
+    return -1;
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h b/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
index 4335554..b3d8fa0 100644
--- a/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
+++ b/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
@@ -107,6 +107,20 @@ public:
     virtual void *wlDisplay() const;
 
     static EGLConfig chooseConfig(EGLDisplay display, const QSurfaceFormat &format);
+    virtual int exportBuffer(const QScreen *screen, uint32_t width,
+        uint32_t height, uint32_t pixel_format, uint32_t *strides,
+        uint32_t *offsets, uint32_t buf_fd, uint32_t *buf_id);
+    virtual int distroyBuffer(const QScreen *screen, uint32_t buf_id);
+    virtual int setPlaneProperties(const QScreen *screen, uint8_t planeType,
+        uint8_t idx, uint8_t numProp, const char **propName,
+        uint32_t *propVal);
+    virtual int getPlaneProperty(const QScreen *screen, uint8_t planeType,
+        uint8_t idx, const char *propName);
+    virtual int createPlane(const QScreen *screen);
+    virtual int distroyPlane(const QScreen *screen, int plane_id);
+    virtual int queuePlane(QScreen *screen, uint32_t idx, uint32_t fb_id);
+    virtual int startDispPlane(QScreen *screen);
+    virtual int userCallBackHandle(QScreen *screen, void (*fnPtr)(void *), void *data);
 };
 
 class Q_EGLFS_EXPORT QEglFSDeviceIntegrationPlugin : public QObject
diff --git a/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp b/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
index 9a0be48..3bc4111 100644
--- a/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
+++ b/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
@@ -286,8 +286,17 @@ enum ResourceType {
     EglConfig,
     NativeDisplay,
     XlibDisplay,
-    WaylandDisplay,
-    EglSurface
+    WaylandDisplay,
+    EglSurface,
+    ExportBuffer,
+    DistroyBuffer,
+    SetPlaneProperties,
+    GetPlaneProperty,
+    CreatePlane,
+    DistroyPlane,
+    QueuePlane,
+    StartDispPlane,
+    UserCallBackHandl,
 };
 
 static int resourceType(const QByteArray &key)
@@ -300,7 +309,16 @@ static int resourceType(const QByteArray &key)
         QByteArrayLiteral("nativedisplay"),
         QByteArrayLiteral("display"),
         QByteArrayLiteral("server_wl_display"),
-        QByteArrayLiteral("eglsurface")
+        QByteArrayLiteral("eglsurface"),
+        QByteArrayLiteral("export_buffer"),
+        QByteArrayLiteral("distroy_buffer"),
+        QByteArrayLiteral("set_plane_properties"),
+        QByteArrayLiteral("get_plane_property"),
+        QByteArrayLiteral("create_plane"),
+        QByteArrayLiteral("distroy_plane"),
+        QByteArrayLiteral("queue_plane"),
+        QByteArrayLiteral("start_disp_plane"),
+        QByteArrayLiteral("user_call_back_handle"),
     };
     const QByteArray *end = names + sizeof(names) / sizeof(names[0]);
     const QByteArray *result = std::find(names, end, key);
@@ -309,6 +327,61 @@ static int resourceType(const QByteArray &key)
     return int(result - names);
 }
 
+static int exportBuffer(const QScreen *screen, uint32_t width, uint32_t height,
+                        uint32_t pixel_format, uint32_t *strides, uint32_t *offsets,
+                        uint32_t buf_fd, uint32_t *buf_id)
+{
+    return(qt_egl_device_integration()->exportBuffer(screen, width,
+        height, pixel_format, strides, offsets, buf_fd, buf_id));
+}
+
+static int distroyBuffer(const QScreen *screen, uint32_t buf_id)
+{
+    return(qt_egl_device_integration()->distroyBuffer(screen, buf_id));
+}
+
+static int setPlaneProperties(const QScreen *screen, uint8_t planeType,
+                              uint32_t idx, uint8_t num_prop, const char **prop_name, uint32_t *prop_val)
+{
+    return (qt_egl_device_integration()->setPlaneProperties(
+        screen, planeType, idx, num_prop, prop_name, prop_val));
+}
+
+static int getPlaneProperty(const QScreen *screen, uint8_t planeType, uint32_t idx,
+                            const char *propName)
+{
+    return (qt_egl_device_integration()->getPlaneProperty(
+        screen, planeType, idx, propName));
+}
+
+static int createPlane(QScreen *screen)
+{
+    return(qt_egl_device_integration()->createPlane(screen));
+}
+
+static int distroyPlane(QScreen *screen, int plane_id)
+{
+    return (qt_egl_device_integration()->distroyPlane(screen, plane_id));
+}
+
+static int queuePlane(QScreen *screen,
+                      uint32_t idx, uint32_t fb_id)
+{
+    return (qt_egl_device_integration()->queuePlane(screen,
+        idx, fb_id));
+}
+
+static int startDispPlane(QScreen *screen)
+{
+    return (qt_egl_device_integration()->startDispPlane(screen));
+}
+
+static int userCallBackHandle(QScreen *screen,  void (*funPtr)(void *), void *data)
+{
+    return (qt_egl_device_integration()->userCallBackHandle(screen,
+        funPtr, data));
+}
+
 void *QEglFSIntegration::nativeResourceForIntegration(const QByteArray &resource)
 {
     void *result = 0;
@@ -323,6 +396,33 @@ void *QEglFSIntegration::nativeResourceForIntegration(const QByteArray &resource
     case WaylandDisplay:
         result = qt_egl_device_integration()->wlDisplay();
         break;
+    case ExportBuffer:
+        result = reinterpret_cast<void *>(exportBuffer);
+        break;
+    case DistroyBuffer:
+        result = reinterpret_cast<void *>(distroyBuffer);
+        break;
+    case CreatePlane:
+        result = reinterpret_cast<void *>(createPlane);
+        break;
+    case DistroyPlane:
+        result = reinterpret_cast<void *>(distroyPlane);
+        break;
+    case SetPlaneProperties:
+        result = reinterpret_cast<void *>(setPlaneProperties);
+        break;
+    case GetPlaneProperty:
+        result = reinterpret_cast<void *>(getPlaneProperty);
+        break;
+    case QueuePlane:
+        result = reinterpret_cast<void *>(queuePlane);
+        break;
+    case StartDispPlane:
+        result = reinterpret_cast<void *>(startDispPlane);
+        break;
+    case UserCallBackHandl:
+        result = reinterpret_cast<void *>(userCallBackHandle);
+        break;
     default:
         break;
     }
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
index e218d58..9948ef7 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
@@ -45,7 +45,8 @@
 #include "qeglfsintegration_p.h"
 
 #include <QtCore/QLoggingCategory>
-#include <QtCore/private/qcore_unix_p.h>
+#include <QtCore/private/qcore_unix_p.h>
+#include <QThread>
 
 #define ARRAY_LENGTH(a) (sizeof (a) / sizeof (a)[0])
 
@@ -53,6 +54,31 @@ QT_BEGIN_NAMESPACE
 
 Q_DECLARE_LOGGING_CATEGORY(qLcEglfsKmsDebug)
 
+class DrmPageFlipHandler : public QThread
+{
+public:
+    DrmPageFlipHandler(QEglFSKmsGbmDevice *gbm_device)
+        : m_abort(false), m_gbm_device(gbm_device)  {}
+    bool m_abort;
+    void run();
+
+private:
+    QEglFSKmsGbmDevice *m_gbm_device;
+};
+
+void DrmPageFlipHandler::run()
+{
+    drmEventContext drmEvent = {
+        DRM_EVENT_CONTEXT_VERSION,
+        Q_NULLPTR,      // vblank handler
+        QEglFSKmsGbmDevice::pageFlipHandler // page flip handler
+    };
+
+    while(m_abort == false){
+        drmHandleEvent(m_gbm_device->fd(), &drmEvent);
+    }
+}
+
 void QEglFSKmsGbmDevice::pageFlipHandler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec, void *user_data)
 {
     Q_UNUSED(fd);
@@ -60,8 +86,17 @@ void QEglFSKmsGbmDevice::pageFlipHandler(int fd, unsigned int sequence, unsigned
     Q_UNUSED(tv_sec);
     Q_UNUSED(tv_usec);
 
-    QEglFSKmsScreen *screen = static_cast<QEglFSKmsScreen *>(user_data);
-    screen->flipFinished();
+    QEglFSKmsGbmScreen *screen = static_cast<QEglFSKmsGbmScreen *>(user_data);
+
+    if(screen->m_qpa_flip_call == true){
+        screen->flipFinished();
+    }
+
+    if(screen->m_user_flip_call == true){
+        screen->m_hndl_user_callback(screen->m_user_data);
+    }
+
+    screen->m_flip_event.release(1);
 }
 
 QEglFSKmsGbmDevice::QEglFSKmsGbmDevice(QKmsScreenConfig *screenConfig, const QString &path)
@@ -92,8 +127,12 @@ bool QEglFSKmsGbmDevice::open()
         return false;
     }
 
+    drmSetClientCap(fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+    drmSetClientCap(fd, DRM_CLIENT_CAP_ATOMIC, 1);
     setFd(fd);
 
+    m_drm_page_flip_handler = new DrmPageFlipHandler(this);
+    m_drm_page_flip_handler->start();
     return true;
 }
 
@@ -105,9 +144,16 @@ void QEglFSKmsGbmDevice::close()
         gbm_device_destroy(m_gbm_device);
         m_gbm_device = Q_NULLPTR;
     }
+    m_drm_page_flip_handler->m_abort = true;
+    m_drm_page_flip_handler->wait();
+    delete m_drm_page_flip_handler;
+    m_drm_page_flip_handler = 0;
 
     if (fd() != -1) {
+        drmSetClientCap(fd(), DRM_CLIENT_CAP_UNIVERSAL_PLANES, 0);
+        drmSetClientCap(fd(), DRM_CLIENT_CAP_ATOMIC, 0);
         qt_safe_close(fd());
+        qWarning("QEglFSKmsGBmDevice::close(): close DRM %d", fd());
         setFd(-1);
     }
 }
@@ -138,17 +184,6 @@ void QEglFSKmsGbmDevice::destroyGlobalCursor()
     }
 }
 
-void QEglFSKmsGbmDevice::handleDrmEvent()
-{
-    drmEventContext drmEvent;
-    memset(&drmEvent, 0, sizeof(drmEvent));
-    drmEvent.version = 2;
-    drmEvent.vblank_handler = nullptr;
-    drmEvent.page_flip_handler = pageFlipHandler;
-
-    drmHandleEvent(fd(), &drmEvent);
-}
-
 QPlatformScreen *QEglFSKmsGbmDevice::createScreen(const QKmsOutput &output)
 {
     QEglFSKmsGbmScreen *screen = new QEglFSKmsGbmScreen(this, output);
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
index 08ca28d..855c75a 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
@@ -50,7 +50,7 @@
 QT_BEGIN_NAMESPACE
 
 class QEglFSKmsScreen;
-
+class DrmPageFlipHandler;
 class QEglFSKmsGbmDevice: public QEglFSKmsDevice
 {
 public:
@@ -65,10 +65,14 @@ public:
     QPlatformCursor *globalCursor() const;
     void destroyGlobalCursor();
 
-    void handleDrmEvent();
-
     QPlatformScreen *createScreen(const QKmsOutput &output) override;
 
+    static void pageFlipHandler(int fd,
+                                unsigned int sequence,
+                                unsigned int tv_sec,
+                                unsigned int tv_usec,
+                                void *user_data);
+
 private:
     Q_DISABLE_COPY(QEglFSKmsGbmDevice)
 
@@ -76,11 +80,7 @@ private:
 
     QEglFSKmsGbmCursor *m_globalCursor;
 
-    static void pageFlipHandler(int fd,
-                                unsigned int sequence,
-                                unsigned int tv_sec,
-                                unsigned int tv_usec,
-                                void *user_data);
+    DrmPageFlipHandler *m_drm_page_flip_handler;
 };
 
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
index b6cdcf9..8339fe4 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
@@ -143,4 +143,107 @@ QKmsDevice *QEglFSKmsGbmIntegration::createDevice()
     return new QEglFSKmsGbmDevice(screenConfig(), path);
 }
 
+int QEglFSKmsGbmIntegration::exportBuffer(const QScreen *screen, uint32_t width, uint32_t height,
+                                          uint32_t pixel_format, uint32_t *strides, uint32_t *offsets,
+                                          uint32_t buf_fd, uint32_t *buf_id)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return (gbmScreen->addOverlayBuffer(width,
+            height, pixel_format, strides, offsets, buf_fd, buf_id));
+    }
+
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::distroyBuffer(const QScreen *screen, uint32_t buf_id)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return (gbmScreen->removeOverlayBuffer(buf_id));
+    }
+
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::setPlaneProperties(const QScreen *screen,
+                                                uint8_t planeType, uint8_t idx, uint8_t num_prop,
+                                                const char **propName, uint32_t *propVal)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->setPlaneProperties(planeType, idx, num_prop, propName, propVal));
+    }
+
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::getPlaneProperty(const QScreen *screen,
+                                              uint8_t planeType, uint8_t idx, const char *propName)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->getPlaneProperty(planeType, idx, propName));
+    }
+
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::createPlane(const QScreen *screen)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->createOverlayPlane());
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::distroyPlane(const QScreen *screen, int planeId)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->distroyOverlayPlane(planeId));
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::queuePlane(QScreen *screen,
+                                        uint32_t idx, uint32_t fbId)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->queueOverlayPlane(idx, fbId));
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::startDispPlane(QScreen *screen)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->startDispOverlayPlane());
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::userCallBackHandle(QScreen *screen,  void (*hndlUserCallBack)(void *), void *userData)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+		gbmScreen->m_hndl_user_callback = hndlUserCallBack;
+		gbmScreen->m_user_data = userData;
+        return 0;
+    }
+    return -1;
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.h b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.h
index 38f132d..ad11c6d 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.h
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.h
@@ -63,6 +63,19 @@ public:
 
     QPlatformCursor *createCursor(QPlatformScreen *screen) const override;
     void presentBuffer(QPlatformSurface *surface) override;
+    int exportBuffer(const QScreen *screen, uint32_t width,
+        uint32_t height, uint32_t pixel_format, uint32_t *strides,
+        uint32_t *offsets, uint32_t buf_fd, uint32_t *buf_id) override;
+    int distroyBuffer(const QScreen *screen,uint32_t buf_id) override;
+    int setPlaneProperties(const QScreen *screen, uint8_t planeType,
+        uint8_t idx, uint8_t numProp, const char **propName, uint32_t *propVal) override;
+    int getPlaneProperty(const QScreen *screen, uint8_t planeType,
+        uint8_t idx, const char *propName) override;
+    int createPlane(const QScreen *screen) override;
+    int distroyPlane(const QScreen *screen, int planeId) override;
+    int queuePlane(QScreen *screen, uint32_t idx, uint32_t fbId) override;
+    int startDispPlane(QScreen *screen) override;
+    int userCallBackHandle(QScreen *screen, void (*fnPtr)(void *), void *data) override;
 
 protected:
     QKmsDevice *createDevice() override;
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
index 87fb314..f498bf1 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
@@ -49,11 +49,26 @@
 #include <QtGui/private/qguiapplication_p.h>
 #include <QtFbSupport/private/qfbvthandler_p.h>
 
-#include <errno.h>
+#include <errno.h>
+#include <QThread>
+#include <QMutex>
+#include <string.h>
 
 QT_BEGIN_NAMESPACE
 
 Q_DECLARE_LOGGING_CATEGORY(qLcEglfsKmsDebug)
+class DrmPageFlip : public QThread
+{
+
+public:
+    DrmPageFlip(QEglFSKmsGbmScreen *screen)
+        : m_abort(false), m_gbm_screen(screen) {}
+    bool m_abort;
+    void run();
+
+private:
+    QEglFSKmsGbmScreen *m_gbm_screen;
+};
 
 void QEglFSKmsGbmScreen::bufferDestroyedHandler(gbm_bo *bo, void *data)
 {
@@ -96,11 +111,20 @@ QEglFSKmsGbmScreen::FrameBuffer *QEglFSKmsGbmScreen::framebufferForBufferObject(
 
 QEglFSKmsGbmScreen::QEglFSKmsGbmScreen(QKmsDevice *device, const QKmsOutput &output)
     : QEglFSKmsScreen(device, output)
+    , m_qpa_flip_call(false)
+    , m_user_flip_call(false)
+	, m_start_flip_overlay_plane(false)
     , m_gbm_surface(Q_NULLPTR)
     , m_gbm_bo_current(Q_NULLPTR)
     , m_gbm_bo_next(Q_NULLPTR)
     , m_cursor(Q_NULLPTR)
+    , m_flip_primary_plane(false)
+    , m_plane_id{0}
+    , m_plane_idx(0)
+    , m_primary_plane_fb(0)
 {
+    m_drm_page_flip = new DrmPageFlip(this);
+    m_drm_page_flip->start();
 }
 
 QEglFSKmsGbmScreen::~QEglFSKmsGbmScreen()
@@ -109,6 +133,100 @@ QEglFSKmsGbmScreen::~QEglFSKmsGbmScreen()
     qCDebug(qLcEglfsKmsDebug, "Screen dtor. Remaining screens: %d", remainingScreenCount);
     if (!remainingScreenCount && !device()->screenConfig()->separateScreens())
         static_cast<QEglFSKmsGbmDevice *>(device())->destroyGlobalCursor();
+    m_drm_page_flip->m_abort = true;
+    m_drm_page_flip->wait();
+    delete m_drm_page_flip;
+    m_drm_page_flip = 0;
+}
+
+/* This thread periodically cheks if there is any user submitted buffer for
+overlay with primary plane or if QT has drawn new surface (primary plane)
+to be displayed. In any or both of the case, this thread will do atomic
+submission of the new framebuffer id to the DRM device for display.
+Access to overlay plane queue and primary plane resources are Mutex protected
+with respective threads.
+*/
+void DrmPageFlip::run(){
+    while(m_abort == false){
+        drmModeAtomicReqPtr req = drmModeAtomicAlloc();
+        bool commit_overlay_plane = false;
+        bool commit_primary_plane = false;
+        uint32_t primary_plane_fb_id;
+        int ret = -1;
+
+        m_gbm_screen->m_primary_mutex.lock();
+        commit_primary_plane = m_gbm_screen->m_flip_primary_plane;
+        primary_plane_fb_id = m_gbm_screen->m_primary_plane_fb;
+        m_gbm_screen->m_flip_primary_plane = false;
+        m_gbm_screen->m_primary_mutex.unlock();
+
+        if(commit_primary_plane == true){
+            if((ret = drmModeAtomicAddProperty(req, m_gbm_screen->m_output.primary_plane_id,
+                m_gbm_screen->device()->m_prop_fbId, primary_plane_fb_id)) < 0){
+                    qWarning("failed to add property with error code = %d\n", ret);
+            }
+        }
+
+        //Check for any new buffer queued by user application
+        if (m_gbm_screen->m_start_flip_overlay_plane == true) {
+            m_gbm_screen->m_overlay_mutex.lock();
+            for(uint32_t i = 0 ; i < m_gbm_screen->m_plane_idx; i++) {
+                if (!m_gbm_screen->overlayPlaneFbIdQueue[i].isEmpty()) {
+                    uint32_t planeId = m_gbm_screen->m_plane_id[i];
+                    uint32_t fbId = m_gbm_screen->overlayPlaneFbIdQueue[i].dequeue();
+                    if((ret = drmModeAtomicAddProperty(req, planeId, m_gbm_screen->device()->m_prop_fbId, fbId)) < 0){
+                        qWarning("failed to add property with error code = %d\n", ret);
+                    }
+                    commit_overlay_plane = true;
+                }
+            }
+            m_gbm_screen->m_overlay_mutex.unlock();
+        }
+
+        if ((commit_primary_plane == true) || (commit_overlay_plane == true)) {
+            ret = drmModeAtomicCommit(m_gbm_screen->device()->fd(), req,
+                DRM_MODE_ATOMIC_TEST_ONLY, 0);
+
+            if (!ret) {
+                if(commit_overlay_plane == true) {
+                    m_gbm_screen->m_user_flip_call = true;
+                }
+
+                if(commit_primary_plane == true) {
+                    m_gbm_screen->m_qpa_flip_call = true;
+                }
+
+                drmModeAtomicCommit(m_gbm_screen->device()->fd(), req,
+                    DRM_MODE_PAGE_FLIP_EVENT | DRM_MODE_ATOMIC_NONBLOCK, m_gbm_screen);
+
+                //sleeping for 5 msec, assuming that display is not running at more than 120 fps
+                msleep(5);
+                while(m_gbm_screen->m_flip_event.tryAcquire(1) == false) {
+                    usleep(500);
+                }
+                m_gbm_screen->m_qpa_flip_call = false;
+                m_gbm_screen->m_user_flip_call = false;
+
+                msleep(1);
+            }
+            else {
+                if (m_gbm_screen->m_qpa_flip_call == true) {
+                    qErrnoWarning("Could not queue DRM page flip!");
+                    gbm_surface_release_buffer(m_gbm_screen->m_gbm_surface, m_gbm_screen->m_gbm_bo_next);
+                    m_gbm_screen->m_gbm_bo_next = Q_NULLPTR;
+                }
+
+                if (commit_overlay_plane == true) {
+                    qErrnoWarning("Could not page flip user overlay plane!");
+                    m_gbm_screen->m_hndl_user_callback(m_gbm_screen->m_user_data);
+                }
+            }
+        }
+        else{
+            msleep(1);
+        }
+        drmModeAtomicFree(req);
+    }
 }
 
 QPlatformCursor *QEglFSKmsGbmScreen::cursor() const
@@ -167,8 +285,10 @@ void QEglFSKmsGbmScreen::waitForFlip()
         return;
 
     QMutexLocker lock(&m_waitForFlipMutex);
-    while (m_gbm_bo_next)
-        static_cast<QEglFSKmsGbmDevice *>(device())->handleDrmEvent();
+    while (m_gbm_bo_next){
+        usleep(200);
+    }
+
 }
 
 void QEglFSKmsGbmScreen::flip()
@@ -200,7 +320,7 @@ void QEglFSKmsGbmScreen::flip()
                                  &op.modes[op.mode]);
 
         if (ret == -1) {
-            qErrnoWarning(errno, "Could not set DRM mode!");
+            qErrnoWarning(errno, "Could not set DRM (%d) CRTC (%d) mode!", fd, op.crtc_id);
         } else {
             op.mode_set = true;
             setPowerState(PowerStateOn);
@@ -219,16 +339,10 @@ void QEglFSKmsGbmScreen::flip()
         }
     }
 
-    int ret = drmModePageFlip(fd,
-                              op.crtc_id,
-                              fb->fb,
-                              DRM_MODE_PAGE_FLIP_EVENT,
-                              this);
-    if (ret) {
-        qErrnoWarning("Could not queue DRM page flip!");
-        gbm_surface_release_buffer(m_gbm_surface, m_gbm_bo_next);
-        m_gbm_bo_next = Q_NULLPTR;
-    }
+    m_primary_mutex.lock();
+    m_primary_plane_fb = fb->fb;
+    m_flip_primary_plane = true;
+    m_primary_mutex.unlock();
 }
 
 void QEglFSKmsGbmScreen::flipFinished()
@@ -241,4 +355,132 @@ void QEglFSKmsGbmScreen::flipFinished()
     m_gbm_bo_next = Q_NULLPTR;
 }
 
+int QEglFSKmsGbmScreen::addOverlayBuffer(uint32_t width,
+                                         uint32_t height,
+                                         uint32_t pixel_format,
+                                         uint32_t *strides,
+                                         uint32_t *offsets,
+                                         uint32_t buf_fd,
+                                         uint32_t *buf_id)
+{
+    /* Get the buffer handle from the exported buffer fd */
+    uint32_t bo_handle;
+    drmPrimeFDToHandle(m_device->fd(), buf_fd, &bo_handle);
+    int ret = drmModeAddFB2(m_device->fd(), width, height, pixel_format, &bo_handle,\
+        strides, offsets, buf_id, 0);
+
+    if (ret) {
+		qWarning() << "addOverlayBuffer: drmModeAddFB2 failed:" << strerror(errno) << ret;
+        return -1;
+    }
+    return ret;
+}
+
+int QEglFSKmsGbmScreen::removeOverlayBuffer(uint32_t buf_id)
+{
+    int ret = drmModeRmFB(m_device->fd(), buf_id);
+
+    if (ret) {
+		qWarning() << "removeOverlayBuffer: drmModeRmFB failed:" << strerror(errno) << ret;
+        return -1;
+    }
+    return ret;
+}
+
+int QEglFSKmsGbmScreen::setPlaneProperties(uint8_t planeType, uint8_t idx,
+                                           uint8_t numProp, const char **propName, uint32_t *propVal)
+{
+    uint32_t planeId, crtcId;
+    uint32_t objectType;
+    crtcId = m_output.crtc_id;
+
+	if (idx > MAX_NUM_PLANES){
+		qWarning("queueOverlayPlane: invalid plane index\n");
+		return -1;
+    }
+
+    if(planeType == DRM_PLANE_TYPE_OVERLAY){
+        planeId = m_plane_id[idx];
+        objectType = DRM_MODE_OBJECT_PLANE;
+    }
+    else if(planeType == DRM_PLANE_TYPE_PRIMARY){
+        objectType = DRM_MODE_OBJECT_CRTC;
+        planeId = crtcId;
+    }
+    else{
+		qWarning() << "setPlaneProperties: invalid plane type";
+        return -1;
+    }
+    return m_device->setPlaneProperties(objectType, crtcId, planeId, numProp, propName, propVal);
+}
+
+int QEglFSKmsGbmScreen::getPlaneProperty(uint8_t planeType, uint8_t idx, const char *propName)
+{
+    uint32_t planeId, crtcId;
+    uint32_t objectType;
+    crtcId = m_output.crtc_id;
+
+	if (idx > MAX_NUM_PLANES){
+		qWarning("queueOverlayPlane: invalid plane index\n");
+		return -1;
+    }
+
+    if(planeType == DRM_PLANE_TYPE_OVERLAY){
+        planeId = m_plane_id[idx];
+        objectType = DRM_MODE_OBJECT_PLANE;
+    }
+    else if(planeType == DRM_PLANE_TYPE_PRIMARY){
+        objectType = DRM_MODE_OBJECT_CRTC;
+        planeId = crtcId;
+    }
+    else{
+		qWarning() << "getPlaneProperty: invalid plane type";
+        return -1;
+    }
+    return m_device->getPlaneProperty(objectType, planeId, propName);
+}
+
+int QEglFSKmsGbmScreen::createOverlayPlane()
+{
+    int planeId = m_device->getPlane(0, DRM_PLANE_TYPE_OVERLAY);
+    if (planeId > 0){
+        uint8_t pcnt = m_plane_idx++;
+        if(pcnt > MAX_NUM_PLANES){
+			qWarning() << "createOverlayPlane: Don't support number of planes greater then" <<  MAX_NUM_PLANES;
+        }
+        m_plane_id[pcnt] = planeId;
+        return pcnt;
+    }
+    else {
+        qWarning() << "createOverlayPlane: cannot find free plane";
+        return -1;
+    }
+}
+
+int QEglFSKmsGbmScreen::distroyOverlayPlane(int pcnt)
+{
+    int planeId = m_plane_id[pcnt];
+    Q_UNUSED(planeId);
+    //nothing to be done to distroy the plane
+    return 0;
+}
+
+int QEglFSKmsGbmScreen::queueOverlayPlane(uint32_t idx, uint32_t fbId)
+{
+    if (idx > MAX_NUM_PLANES){
+        qWarning("queueOverlayPlane: invalid plane index\n");
+        return -1;
+    }
+    m_overlay_mutex.lock();
+    overlayPlaneFbIdQueue[idx].enqueue(fbId);
+    m_overlay_mutex.unlock();
+    return 0;
+}
+
+int QEglFSKmsGbmScreen::startDispOverlayPlane()
+{
+    m_start_flip_overlay_plane = true;
+    return 0;
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
index 341cc95..7faf6a1 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
@@ -44,12 +44,18 @@
 
 #include "qeglfskmsscreen.h"
 #include <QtCore/QMutex>
+#include <QtCore/QSemaphore>
+#include <QtCore/QQueue>
 
 #include <gbm.h>
 
 QT_BEGIN_NAMESPACE
 
+#define MAX_NUM_PLANES 10
+
 class QEglFSKmsGbmCursor;
+class DrmPageFlip;
+typedef void (*m_fnptr_user_callback)(void *data);
 
 class QEglFSKmsGbmScreen : public QEglFSKmsScreen
 {
@@ -67,6 +73,30 @@ public:
     void flip() override;
     void flipFinished() override;
 
+    int addOverlayBuffer(uint32_t width,
+        uint32_t height,
+        uint32_t pixel_format,
+        uint32_t *strides,
+        uint32_t *offsets,
+        uint32_t buf_fd,
+        uint32_t *buf_id);
+    int removeOverlayBuffer(uint32_t buf_id);
+    int setPlaneProperties(uint8_t planeType, uint8_t idx,
+        uint8_t numProp, const char **propName, uint32_t *propVal);
+    int getPlaneProperty(uint8_t planeType, uint8_t idx, const char *propName);
+    int createOverlayPlane();
+    int distroyOverlayPlane(int pcnt);
+    int queueOverlayPlane(uint32_t idx, uint32_t fbId);
+    int startDispOverlayPlane();
+    m_fnptr_user_callback m_hndl_user_callback;
+    void *m_user_data;
+    bool m_qpa_flip_call;
+    bool m_user_flip_call;
+    bool m_start_flip_overlay_plane;
+    QMutex m_flip_mutex;
+    QSemaphore m_flip_event;
+    friend class DrmPageFlip;
+
 private:
     gbm_surface *m_gbm_surface;
 
@@ -83,6 +113,15 @@ private:
     FrameBuffer *framebufferForBufferObject(gbm_bo *bo);
 
     static QMutex m_waitForFlipMutex;
+
+    bool m_flip_primary_plane;
+    QMutex m_overlay_mutex;
+    QMutex m_primary_mutex;
+    QQueue<uint32_t> overlayPlaneFbIdQueue[MAX_NUM_PLANES];
+    uint32_t m_plane_id[MAX_NUM_PLANES];
+    uint8_t m_plane_idx;
+    uint32_t m_primary_plane_fb;
+    DrmPageFlip *m_drm_page_flip;
 };
 
 QT_END_NAMESPACE
-- 
1.9.1

