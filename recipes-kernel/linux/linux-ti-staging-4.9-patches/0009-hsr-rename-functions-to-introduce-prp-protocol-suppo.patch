From 6eca829fceabe4c69c75b3d584ede802c067ec1e Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Thu, 16 Feb 2017 12:12:58 -0500
Subject: [PATCH 09/22] hsr: rename functions to introduce prp protocol support

There are many similarities between a DAN-H (using HSR protocol) and
DAN-P (using PRP protocol) node. So the code can be re-used across
both implementations. As a preparatory patch, rename functions that
are common across two protocol handlers. While at it also, rename some
of the private structure to indicate they are common and rephrase
applicable logs to indicate it is HSR/PRP network device.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
Signed-off-by: Jacob Stiffler <j-stiffler@ti.com>

hsr/prp: Fix misleading log.

Current log is misleading as driver is re-used for PRP.
Also avoid checkpatch warning.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
Signed-off-by: Jacob Stiffler <j-stiffler@ti.com>
---
 net/hsr/Makefile          |   6 +-
 net/hsr/hsr_device.c      | 348 +++++++++++++++++++++++-----------------------
 net/hsr/hsr_device.h      |  12 +-
 net/hsr/hsr_forward.c     | 158 ++++++++++-----------
 net/hsr/hsr_forward.h     |   2 +-
 net/hsr/hsr_framereg.c    | 199 +++++++++++++-------------
 net/hsr/hsr_framereg.h    |  66 ++++-----
 net/hsr/hsr_main.c        |  60 ++++----
 net/hsr/hsr_main.h        |  82 +++++------
 net/hsr/hsr_netlink.c     |  77 +++++-----
 net/hsr/hsr_netlink.h     |  10 +-
 net/hsr/hsr_prp_debugfs.c |  14 +-
 net/hsr/hsr_slave.c       |  65 +++++----
 net/hsr/hsr_slave.h       |  18 +--
 14 files changed, 559 insertions(+), 558 deletions(-)

diff --git a/net/hsr/Makefile b/net/hsr/Makefile
index d7ab933..704b939 100644
--- a/net/hsr/Makefile
+++ b/net/hsr/Makefile
@@ -2,8 +2,8 @@
 # Makefile for HSR
 #
 
-obj-$(CONFIG_HSR_PRP)	+= hsr.o
+obj-$(CONFIG_HSR_PRP)	+= hsr-prp.o
 
-hsr-y			:= hsr_main.o hsr_framereg.o hsr_device.o \
+hsr-prp-y		:= hsr_main.o hsr_framereg.o hsr_device.o \
 			   hsr_netlink.o hsr_slave.o hsr_forward.o
-hsr-$(CONFIG_DEBUG_FS) += hsr_prp_debugfs.o
+hsr-prp-$(CONFIG_DEBUG_FS) += hsr_prp_debugfs.o
diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index e0504bc..c64b41d 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -33,7 +33,7 @@ static bool is_slave_up(struct net_device *dev)
 	return dev && is_admin_up(dev) && netif_oper_up(dev);
 }
 
-static void __hsr_set_operstate(struct net_device *dev, int transition)
+static void __set_operstate(struct net_device *dev, int transition)
 {
 	write_lock_bh(&dev_base_lock);
 	if (dev->operstate != transition) {
@@ -45,29 +45,29 @@ static void __hsr_set_operstate(struct net_device *dev, int transition)
 	}
 }
 
-static void hsr_set_operstate(struct hsr_port *master, bool has_carrier)
+static void set_operstate(struct hsr_prp_port *master, bool has_carrier)
 {
 	if (!is_admin_up(master->dev)) {
-		__hsr_set_operstate(master->dev, IF_OPER_DOWN);
+		__set_operstate(master->dev, IF_OPER_DOWN);
 		return;
 	}
 
 	if (has_carrier)
-		__hsr_set_operstate(master->dev, IF_OPER_UP);
+		__set_operstate(master->dev, IF_OPER_UP);
 	else
-		__hsr_set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);
+		__set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);
 }
 
-static bool hsr_check_carrier(struct hsr_port *master)
+static bool hsr_prp_check_carrier(struct hsr_prp_port *master)
 {
-	struct hsr_port *port;
+	struct hsr_prp_port *port;
 	bool has_carrier;
 
 	has_carrier = false;
 
 	rcu_read_lock();
-	hsr_for_each_port(master->hsr, port)
-		if ((port->type != HSR_PT_MASTER) &&
+	hsr_prp_for_each_port(master->priv, port)
+		if ((port->type != HSR_PRP_PT_MASTER) &&
 		    is_slave_up(port->dev)) {
 			has_carrier = true;
 			break;
@@ -82,72 +82,73 @@ static bool hsr_check_carrier(struct hsr_port *master)
 	return has_carrier;
 }
 
-static void hsr_check_announce(struct net_device *hsr_dev,
-			       unsigned char old_operstate)
+static void hsr_prp_check_announce(struct net_device *hsr_dev,
+				   unsigned char old_operstate)
 {
-	struct hsr_priv *hsr;
+	struct hsr_prp_priv *priv;
 
-	hsr = netdev_priv(hsr_dev);
+	priv = netdev_priv(hsr_dev);
 
 	if ((hsr_dev->operstate == IF_OPER_UP) &&
 	    (old_operstate != IF_OPER_UP)) {
 		/* Went up */
-		hsr->announce_count = 0;
-		hsr->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
-		add_timer(&hsr->announce_timer);
+		priv->announce_count = 0;
+		priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_PRP_ANNOUNCE_INTERVAL);
+		add_timer(&priv->announce_timer);
 	}
 
 	if ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))
 		/* Went down */
-		del_timer(&hsr->announce_timer);
+		del_timer(&priv->announce_timer);
 }
 
-void hsr_check_carrier_and_operstate(struct hsr_priv *hsr)
+void hsr_prp_check_carrier_and_operstate(struct hsr_prp_priv *priv)
 {
-	struct hsr_port *master;
+	struct hsr_prp_port *master;
 	unsigned char old_operstate;
 	bool has_carrier;
 
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 	/* netif_stacked_transfer_operstate() cannot be used here since
 	 * it doesn't set IF_OPER_LOWERLAYERDOWN (?)
 	 */
 	old_operstate = master->dev->operstate;
-	has_carrier = hsr_check_carrier(master);
-	hsr_set_operstate(master, has_carrier);
-	hsr_check_announce(master->dev, old_operstate);
+	has_carrier = hsr_prp_check_carrier(master);
+	set_operstate(master, has_carrier);
+	hsr_prp_check_announce(master->dev, old_operstate);
 }
 
-int hsr_get_max_mtu(struct hsr_priv *hsr)
+int hsr_prp_get_max_mtu(struct hsr_prp_priv *priv)
 {
 	unsigned int mtu_max;
-	struct hsr_port *port;
+	struct hsr_prp_port *port;
 
 	mtu_max = ETH_DATA_LEN;
 	rcu_read_lock();
-	hsr_for_each_port(hsr, port)
-		if (port->type != HSR_PT_MASTER)
+	hsr_prp_for_each_port(priv, port)
+		if (port->type != HSR_PRP_PT_MASTER)
 			mtu_max = min(port->dev->mtu, mtu_max);
 	rcu_read_unlock();
 
-	if (mtu_max < HSR_HLEN)
+	if (mtu_max < HSR_PRP_HLEN)
 		return 0;
-	return mtu_max - HSR_HLEN;
+	return mtu_max - HSR_PRP_HLEN;
 }
 
-
-static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
+static int hsr_prp_dev_change_mtu(struct net_device *dev, int new_mtu)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *master;
-
-	hsr = netdev_priv(dev);
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
-
-	if (new_mtu > hsr_get_max_mtu(hsr)) {
-		netdev_info(master->dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",
-			    HSR_HLEN);
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *master;
+	int max;
+
+	priv = netdev_priv(dev);
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+	max = hsr_prp_get_max_mtu(priv);
+	if (new_mtu > max) {
+		netdev_info(master->dev,
+			    "HSR/PRP: Invalid MTU, expected (<= %d), Got %d.\n",
+			    max, new_mtu);
 		return -EINVAL;
 	}
 
@@ -156,31 +157,32 @@ static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 	return 0;
 }
 
-static int hsr_dev_open(struct net_device *dev)
+static int hsr_prp_dev_open(struct net_device *dev)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *port;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
 	char designation;
 
-	hsr = netdev_priv(dev);
+	priv = netdev_priv(dev);
 	designation = '\0';
 
 	rcu_read_lock();
-	hsr_for_each_port(hsr, port) {
-		if (port->type == HSR_PT_MASTER)
+	hsr_prp_for_each_port(priv, port) {
+		if (port->type == HSR_PRP_PT_MASTER)
 			continue;
 		switch (port->type) {
-		case HSR_PT_SLAVE_A:
+		case HSR_PRP_PT_SLAVE_A:
 			designation = 'A';
 			break;
-		case HSR_PT_SLAVE_B:
+		case HSR_PRP_PT_SLAVE_B:
 			designation = 'B';
 			break;
 		default:
 			designation = '?';
 		}
 		if (!is_slave_up(port->dev))
-			netdev_warn(dev, "Slave %c (%s) is not up; please bring it up to get a fully working HSR network\n",
+			netdev_warn(dev,
+				    "HSR/PRP: Please bringup Slave %c (%s)\n",
 				    designation, port->dev->name);
 	}
 	rcu_read_unlock();
@@ -191,17 +193,17 @@ static int hsr_dev_open(struct net_device *dev)
 	return 0;
 }
 
-static int hsr_dev_close(struct net_device *dev)
+static int hsr_prp_dev_close(struct net_device *dev)
 {
 	/* Nothing to do here. */
 	return 0;
 }
 
-static netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,
-						netdev_features_t features)
+static netdev_features_t hsr_prp_features_recompute(struct hsr_prp_priv *priv,
+						    netdev_features_t features)
 {
 	netdev_features_t mask;
-	struct hsr_port *port;
+	struct hsr_prp_port *port;
 
 	mask = features;
 
@@ -213,7 +215,7 @@ static netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,
 	 * may become enabled.
 	 */
 	features &= ~NETIF_F_ONE_FOR_ALL;
-	hsr_for_each_port(hsr, port)
+	hsr_prp_for_each_port(priv, port)
 		features = netdev_increment_features(features,
 						     port->dev->features,
 						     mask);
@@ -221,50 +223,49 @@ static netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,
 	return features;
 }
 
-static netdev_features_t hsr_fix_features(struct net_device *dev,
-					  netdev_features_t features)
+static netdev_features_t hsr_prp_fix_features(struct net_device *dev,
+					      netdev_features_t features)
 {
-	struct hsr_priv *hsr = netdev_priv(dev);
+	struct hsr_prp_priv *priv = netdev_priv(dev);
 
-	return hsr_features_recompute(hsr, features);
+	return hsr_prp_features_recompute(priv, features);
 }
 
-static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
+static int hsr_prp_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct hsr_priv *hsr = netdev_priv(dev);
-	struct hsr_port *master;
+	struct hsr_prp_priv *priv = netdev_priv(dev);
+	struct hsr_prp_port *master;
 
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 	skb->dev = master->dev;
-	hsr_forward_skb(skb, master);
+	hsr_prp_forward_skb(skb, master);
 	master->dev->stats.tx_packets++;
 	master->dev->stats.tx_bytes += skb->len;
 
 	return NETDEV_TX_OK;
 }
 
-static const struct header_ops hsr_header_ops = {
+static const struct header_ops hsr_prp_header_ops = {
 	.create	 = eth_header,
 	.parse	 = eth_header_parse,
 };
 
-static void send_hsr_supervision_frame(struct hsr_port *master,
-				       u8 type, u8 prot_ver)
+static void send_supervision_frame(struct hsr_prp_port *master,
+				   u8 type, u8 prot_ver)
 {
 	struct sk_buff *skb;
 	int hlen, tlen;
 	struct hsr_tag *hsr_tag;
-	struct hsr_sup_tag *hsr_stag;
-	struct hsr_sup_payload *hsr_sp;
+	struct hsr_prp_sup_tag *hsr_stag;
+	struct hsr_prp_sup_payload *hsr_sp;
 	unsigned long irqflags;
 
 	hlen = LL_RESERVED_SPACE(master->dev);
 	tlen = master->dev->needed_tailroom;
 	skb = dev_alloc_skb(
 			sizeof(struct hsr_tag) +
-			sizeof(struct hsr_sup_tag) +
-			sizeof(struct hsr_sup_payload) + hlen + tlen);
-
+			sizeof(struct hsr_prp_sup_tag) +
+			sizeof(struct hsr_prp_sup_payload) + hlen + tlen);
 	if (!skb)
 		return;
 
@@ -275,7 +276,7 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	skb->priority = TC_PRIO_CONTROL;
 
 	if (dev_hard_header(skb, skb->dev, (prot_ver ? ETH_P_HSR : ETH_P_PRP),
-			    master->hsr->sup_multicast_addr,
+			    master->priv->sup_multicast_addr,
 			    skb->dev->dev_addr, skb->len) <= 0)
 		goto out;
 
@@ -288,36 +289,35 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	}
 
 	hsr_stag = (typeof(hsr_stag))skb_put(skb,
-					     sizeof(struct hsr_sup_tag));
+					     sizeof(struct hsr_prp_sup_tag));
 	set_hsr_stag_path(hsr_stag, (prot_ver ? 0x0 : 0xf));
 	set_hsr_stag_HSR_ver(hsr_stag, prot_ver);
 
 	/* From HSRv1 on we have separate supervision sequence numbers. */
-	spin_lock_irqsave(&master->hsr->seqnr_lock, irqflags);
+	spin_lock_irqsave(&master->priv->seqnr_lock, irqflags);
 	if (prot_ver > 0) {
-		hsr_stag->sequence_nr = htons(master->hsr->sup_sequence_nr);
-		hsr_tag->sequence_nr = htons(master->hsr->sequence_nr);
-		master->hsr->sup_sequence_nr++;
-		master->hsr->sequence_nr++;
+		hsr_stag->sequence_nr = htons(master->priv->sup_sequence_nr);
+		hsr_tag->sequence_nr = htons(master->priv->sequence_nr);
+		master->priv->sup_sequence_nr++;
+		master->priv->sequence_nr++;
 	} else {
-		hsr_stag->sequence_nr = htons(master->hsr->sequence_nr);
-		master->hsr->sequence_nr++;
+		hsr_stag->sequence_nr = htons(master->priv->sequence_nr);
+		master->priv->sequence_nr++;
 	}
-	spin_unlock_irqrestore(&master->hsr->seqnr_lock, irqflags);
+	spin_unlock_irqrestore(&master->priv->seqnr_lock, irqflags);
 
 	hsr_stag->HSR_TLV_type = type;
 	/* TODO: Why 12 in HSRv0? */
 	hsr_stag->HSR_TLV_length =
-		prot_ver ? sizeof(struct hsr_sup_payload) : 12;
+		prot_ver ? sizeof(struct hsr_prp_sup_payload) : 12;
 
 	/* Payload: mac_address_a */
 	hsr_sp = (typeof(hsr_sp))skb_put(skb,
-					 sizeof(struct hsr_sup_payload));
+					 sizeof(struct hsr_prp_sup_payload));
 	ether_addr_copy(hsr_sp->mac_address_a, master->dev->dev_addr);
+	skb_put_padto(skb, ETH_ZLEN + HSR_PRP_HLEN);
 
-	skb_put_padto(skb, ETH_ZLEN + HSR_HLEN);
-
-	hsr_forward_skb(skb, master);
+	hsr_prp_forward_skb(skb, master);
 	return;
 
 out:
@@ -325,36 +325,35 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	kfree_skb(skb);
 }
 
-
 /* Announce (supervision frame) timer function
  */
-static void hsr_announce(unsigned long data)
+static void hsr_prp_announce(unsigned long data)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *master;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *master;
 
-	hsr = (struct hsr_priv *)data;
+	priv = (struct hsr_prp_priv *)data;
 
 	rcu_read_lock();
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 
-	if (hsr->announce_count < 3 && hsr->prot_version == 0) {
-		send_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE,
-					   hsr->prot_version);
-		hsr->announce_count++;
+	if (priv->announce_count < 3 && priv->prot_version == 0) {
+		send_supervision_frame(master, HSR_TLV_ANNOUNCE,
+				       priv->prot_version);
+		priv->announce_count++;
 
-		hsr->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
+		priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_PRP_ANNOUNCE_INTERVAL);
 	} else {
-		send_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK,
-					   hsr->prot_version);
+		send_supervision_frame(master, HSR_TLV_LIFE_CHECK,
+				       priv->prot_version);
 
-		hsr->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
+		priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_PRP_LIFE_CHECK_INTERVAL);
 	}
 
 	if (is_admin_up(master->dev))
-		add_timer(&hsr->announce_timer);
+		add_timer(&priv->announce_timer);
 
 	rcu_read_unlock();
 }
@@ -363,75 +362,74 @@ static void hsr_announce(unsigned long data)
 /* According to comments in the declaration of struct net_device, this function
  * is "Called from unregister, can be used to call free_netdev". Ok then...
  */
-static void hsr_dev_destroy(struct net_device *hsr_dev)
+static void hsr_prp_dev_destroy(struct net_device *hsr_prp_dev)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *port;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
 
-	hsr = netdev_priv(hsr_dev);
+	priv = netdev_priv(hsr_prp_dev);
 
-	hsr_prp_debugfs_term(hsr);
+	hsr_prp_debugfs_term(priv);
 
 	rtnl_lock();
-	hsr_for_each_port(hsr, port)
-		hsr_del_port(port);
+	hsr_prp_for_each_port(priv, port)
+		hsr_prp_del_port(port);
 	rtnl_unlock();
 
-	del_timer_sync(&hsr->prune_timer);
-	del_timer_sync(&hsr->announce_timer);
+	del_timer_sync(&priv->prune_timer);
+	del_timer_sync(&priv->announce_timer);
 
 	synchronize_rcu();
-	free_netdev(hsr_dev);
+	free_netdev(hsr_prp_dev);
 }
 
-static const struct net_device_ops hsr_device_ops = {
-	.ndo_change_mtu = hsr_dev_change_mtu,
-	.ndo_open = hsr_dev_open,
-	.ndo_stop = hsr_dev_close,
-	.ndo_start_xmit = hsr_dev_xmit,
-	.ndo_fix_features = hsr_fix_features,
+static const struct net_device_ops hsr_prp_device_ops = {
+	.ndo_change_mtu = hsr_prp_dev_change_mtu,
+	.ndo_open = hsr_prp_dev_open,
+	.ndo_stop = hsr_prp_dev_close,
+	.ndo_start_xmit = hsr_prp_dev_xmit,
+	.ndo_fix_features = hsr_prp_fix_features,
 };
 
 static struct device_type hsr_type = {
 	.name = "hsr",
 };
 
-void hsr_dev_setup(struct net_device *dev)
+void hsr_prp_dev_setup(struct net_device *ndev)
 {
-	random_ether_addr(dev->dev_addr);
+	random_ether_addr(ndev->dev_addr);
 
-	ether_setup(dev);
-	dev->header_ops = &hsr_header_ops;
-	dev->netdev_ops = &hsr_device_ops;
-	SET_NETDEV_DEVTYPE(dev, &hsr_type);
-	dev->priv_flags |= IFF_NO_QUEUE;
+	ether_setup(ndev);
+	ndev->header_ops = &hsr_prp_header_ops;
+	ndev->netdev_ops = &hsr_prp_device_ops;
+	SET_NETDEV_DEVTYPE(ndev, &hsr_type);
+	ndev->priv_flags |= IFF_NO_QUEUE;
 
-	dev->destructor = hsr_dev_destroy;
+	ndev->destructor = hsr_prp_dev_destroy;
 
-	dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+	ndev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
 			   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |
 			   NETIF_F_HW_VLAN_CTAG_TX;
 
-	dev->features = dev->hw_features;
+	ndev->features = ndev->hw_features;
 
 	/* Prevent recursive tx locking */
-	dev->features |= NETIF_F_LLTX;
+	ndev->features |= NETIF_F_LLTX;
 	/* VLAN on top of HSR needs testing and probably some work on
 	 * hsr_header_create() etc.
 	 */
-	dev->features |= NETIF_F_VLAN_CHALLENGED;
+	ndev->features |= NETIF_F_VLAN_CHALLENGED;
 	/* Not sure about this. Taken from bridge code. netdev_features.h says
 	 * it means "Does not change network namespaces".
 	 */
-	dev->features |= NETIF_F_NETNS_LOCAL;
+	ndev->features |= NETIF_F_NETNS_LOCAL;
 }
 
-
 /* Return true if dev is a HSR master; return false otherwise.
  */
-inline bool is_hsr_master(struct net_device *dev)
+inline bool is_hsr_prp_master(struct net_device *dev)
 {
-	return (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);
+	return (dev->netdev_ops->ndo_start_xmit == hsr_prp_dev_xmit);
 }
 
 /* Default multicast address for HSR Supervision frames */
@@ -439,42 +437,46 @@ inline bool is_hsr_master(struct net_device *dev)
 	0x01, 0x15, 0x4e, 0x00, 0x01, 0x00
 };
 
-int hsr_dev_finalize(struct net_device *hsr_dev,
-		     struct net_device *slave[2],
-		     unsigned char multicast_spec, u8 protocol_version)
+int hsr_prp_dev_finalize(struct net_device *hsr_prp_dev,
+			 struct net_device *slave[2],
+			 unsigned char multicast_spec, u8 protocol_version)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *port;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
 	int res;
 
-	hsr = netdev_priv(hsr_dev);
-	INIT_LIST_HEAD(&hsr->ports);
-	INIT_LIST_HEAD(&hsr->node_db);
-	INIT_LIST_HEAD(&hsr->self_node_db);
+	priv = netdev_priv(hsr_prp_dev);
+	INIT_LIST_HEAD(&priv->ports);
+	INIT_LIST_HEAD(&priv->node_db);
+	INIT_LIST_HEAD(&priv->self_node_db);
 
-	ether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);
+	ether_addr_copy(hsr_prp_dev->dev_addr, slave[0]->dev_addr);
 
-	/* Make sure we recognize frames from ourselves in hsr_rcv() */
-	res = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,
-				   slave[1]->dev_addr);
+	/* Make sure we recognize frames from ourselves in
+	 * hsr_rcv() or frame is addressed to me
+	 */
+	res = hsr_prp_create_self_node(&priv->self_node_db,
+				       hsr_prp_dev->dev_addr,
+				       slave[1]->dev_addr);
 	if (res < 0)
 		return res;
 
-	spin_lock_init(&hsr->seqnr_lock);
+	spin_lock_init(&priv->seqnr_lock);
 	/* Overflow soon to find bugs easier: */
-	hsr->sequence_nr = HSR_SEQNR_START;
-	hsr->sup_sequence_nr = HSR_SUP_SEQNR_START;
+	priv->sequence_nr = HSR_PRP_SEQNR_START;
+	priv->sup_sequence_nr = HSR_PRP_SUP_SEQNR_START;
 
-	setup_timer(&hsr->announce_timer, hsr_announce, (unsigned long)hsr);
+	setup_timer(&priv->announce_timer, hsr_prp_announce,
+		    (unsigned long)priv);
 
-	if (!hsr->rx_offloaded)
-		setup_timer(&hsr->prune_timer, hsr_prune_nodes,
-			    (unsigned long)hsr);
+	if (!priv->rx_offloaded)
+		setup_timer(&priv->prune_timer, hsr_prp_prune_nodes,
+			    (unsigned long)priv);
 
-	ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);
-	hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
+	ether_addr_copy(priv->sup_multicast_addr, def_multicast_addr);
+	priv->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
 
-	hsr->prot_version = protocol_version;
+	priv->prot_version = protocol_version;
 
 	/* FIXME: should I modify the value of these?
 	 *
@@ -487,56 +489,56 @@ int hsr_dev_finalize(struct net_device *hsr_dev,
 	 */
 
 	/* Make sure the 1st call to netif_carrier_on() gets through */
-	netif_carrier_off(hsr_dev);
+	netif_carrier_off(hsr_prp_dev);
 
-	res = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);
+	res = hsr_prp_add_port(priv, hsr_prp_dev, HSR_PRP_PT_MASTER);
 	if (res)
 		return res;
 
 	/* HSR LRE Rx offload supported in lower device? */
 	if ((slave[0]->features & NETIF_F_HW_HSR_RX_OFFLOAD) &&
 	    (slave[1]->features & NETIF_F_HW_HSR_RX_OFFLOAD))
-		hsr->rx_offloaded = true;
+		priv->rx_offloaded = true;
 
 	/* HSR LRE L2 forward offload supported in lower device? */
 	if ((slave[0]->features & NETIF_F_HW_L2FW_DOFFLOAD) &&
 	    (slave[1]->features & NETIF_F_HW_L2FW_DOFFLOAD))
-		hsr->l2_fwd_offloaded = true;
+		priv->l2_fwd_offloaded = true;
 
-	res = register_netdevice(hsr_dev);
+	res = register_netdevice(hsr_prp_dev);
 	if (res)
 		goto fail;
 
-	res = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);
+	res = hsr_prp_add_port(priv, slave[0], HSR_PRP_PT_SLAVE_A);
 	if (res)
 		goto fail;
-	res = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);
+	res = hsr_prp_add_port(priv, slave[1], HSR_PRP_PT_SLAVE_B);
 	if (res)
 		goto fail;
 
 	/* For LRE rx offload, pruning is expected to happen
 	 * at the hardware or firmware . So don't do this in software
 	 */
-	if (!hsr->rx_offloaded)
-		mod_timer(&hsr->prune_timer,
-			  jiffies + msecs_to_jiffies(PRUNE_PERIOD));
+	if (!priv->rx_offloaded)
+		mod_timer(&priv->prune_timer,
+			  jiffies + msecs_to_jiffies(HSR_PRP_PRUNE_PERIOD));
 	/* for offloaded case, expect both slaves have the
 	 * same MAC address configured. If not fail.
 	 */
-	if (hsr->rx_offloaded &&
+	if (priv->rx_offloaded &&
 	    !ether_addr_equal(slave[0]->dev_addr,
 			      slave[1]->dev_addr))
 		goto fail;
 
-	res = hsr_prp_debugfs_init(hsr);
+	res = hsr_prp_debugfs_init(priv);
 	if (res)
 		goto fail;
 
 	return 0;
 
 fail:
-	hsr_for_each_port(hsr, port)
-		hsr_del_port(port);
+	hsr_prp_for_each_port(priv, port)
+		hsr_prp_del_port(port);
 
 	return res;
 }
diff --git a/net/hsr/hsr_device.h b/net/hsr/hsr_device.h
index 9975e31..d6a4b2e 100644
--- a/net/hsr/hsr_device.h
+++ b/net/hsr/hsr_device.h
@@ -15,11 +15,11 @@
 #include <linux/netdevice.h>
 #include "hsr_main.h"
 
-void hsr_dev_setup(struct net_device *dev);
-int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
-		     unsigned char multicast_spec, u8 protocol_version);
-void hsr_check_carrier_and_operstate(struct hsr_priv *hsr);
-bool is_hsr_master(struct net_device *dev);
-int hsr_get_max_mtu(struct hsr_priv *hsr);
+void hsr_prp_dev_setup(struct net_device *dev);
+int hsr_prp_dev_finalize(struct net_device *dev, struct net_device *slave[2],
+			 unsigned char multicast_spec, u8 protocol_version);
+void hsr_prp_check_carrier_and_operstate(struct hsr_prp_priv *priv);
+bool is_hsr_prp_master(struct net_device *dev);
+int hsr_prp_get_max_mtu(struct hsr_prp_priv *priv);
 
 #endif /* __HSR_DEVICE_H */
diff --git a/net/hsr/hsr_forward.c b/net/hsr/hsr_forward.c
index 85f5a51..ff0d3f9 100644
--- a/net/hsr/hsr_forward.c
+++ b/net/hsr/hsr_forward.c
@@ -17,14 +17,13 @@
 #include "hsr_main.h"
 #include "hsr_framereg.h"
 
+struct hsr_prp_node;
 
-struct hsr_node;
-
-struct hsr_frame_info {
+struct hsr_prp_frame_info {
 	struct sk_buff *skb_std;
 	struct sk_buff *skb_hsr;
-	struct hsr_port *port_rcv;
-	struct hsr_node *node_src;
+	struct hsr_prp_port *port_rcv;
+	struct hsr_prp_node *node_src;
 	u16 sequence_nr;
 	bool is_supervision;
 	bool is_vlan;
@@ -47,10 +46,10 @@ struct hsr_frame_info {
  * 3) Allow different MAC addresses for the two slave interfaces, using the
  *    MacAddressA field.
  */
-static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)
+static bool is_supervision_frame(struct hsr_prp_priv *priv, struct sk_buff *skb)
 {
 	struct ethhdr *ethHdr;
-	struct hsr_sup_tag *hsr_sup_tag;
+	struct hsr_prp_sup_tag *hsr_sup_tag;
 	struct hsrv1_ethhdr_sp *hsr_v1_hdr;
 
 	WARN_ON_ONCE(!skb_mac_header_was_set(skb));
@@ -58,7 +57,7 @@ static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)
 
 	/* Correct addr? */
 	if (!ether_addr_equal(ethHdr->h_dest,
-			      hsr->sup_multicast_addr))
+			      priv->sup_multicast_addr))
 		return false;
 
 	/* Correct ether type?. */
@@ -83,31 +82,30 @@ static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)
 		return false;
 
 	if ((hsr_sup_tag->HSR_TLV_length != 12) &&
-	    (hsr_sup_tag->HSR_TLV_length != sizeof(struct hsr_sup_payload)))
+	    (hsr_sup_tag->HSR_TLV_length != sizeof(struct hsr_prp_sup_payload)))
 		return false;
 
 	return true;
 }
 
-
 static struct sk_buff *create_stripped_skb(struct sk_buff *skb_in,
-					   struct hsr_frame_info *frame)
+					   struct hsr_prp_frame_info *frame)
 {
 	struct sk_buff *skb;
 	int copylen;
 	unsigned char *dst, *src;
 
-	skb_pull(skb_in, HSR_HLEN);
+	skb_pull(skb_in, HSR_PRP_HLEN);
 	skb = __pskb_copy(skb_in,
-			  skb_headroom(skb_in) - HSR_HLEN, GFP_ATOMIC);
-	skb_push(skb_in, HSR_HLEN);
+			  skb_headroom(skb_in) - HSR_PRP_HLEN, GFP_ATOMIC);
+	skb_push(skb_in, HSR_PRP_HLEN);
 	if (!skb)
 		return NULL;
 
 	skb_reset_mac_header(skb);
 
 	if (skb->ip_summed == CHECKSUM_PARTIAL)
-		skb->csum_start -= HSR_HLEN;
+		skb->csum_start -= HSR_PRP_HLEN;
 
 	copylen = 2*ETH_ALEN;
 	if (frame->is_vlan)
@@ -120,8 +118,8 @@ static struct sk_buff *create_stripped_skb(struct sk_buff *skb_in,
 	return skb;
 }
 
-static struct sk_buff *frame_get_stripped_skb(struct hsr_frame_info *frame,
-					      struct hsr_port *port)
+static struct sk_buff *frame_get_stripped_skb(struct hsr_prp_frame_info *frame,
+					      struct hsr_prp_port *port)
 {
 	if (!frame->skb_std)
 		frame->skb_std = create_stripped_skb(frame->skb_hsr, frame);
@@ -129,14 +127,14 @@ static struct sk_buff *frame_get_stripped_skb(struct hsr_frame_info *frame,
 }
 
 
-static void hsr_fill_tag(struct sk_buff *skb, struct hsr_frame_info *frame,
-			 struct hsr_port *port, u8 proto_version)
+static void hsr_fill_tag(struct sk_buff *skb, struct hsr_prp_frame_info *frame,
+			 struct hsr_prp_port *port, u8 proto_version)
 {
 	struct hsr_ethhdr *hsr_ethhdr;
 	int lane_id;
 	int lsdu_size;
 
-	if (port->type == HSR_PT_SLAVE_A)
+	if (port->type == HSR_PRP_PT_SLAVE_A)
 		lane_id = 0;
 	else
 		lane_id = 1;
@@ -156,32 +154,33 @@ static void hsr_fill_tag(struct sk_buff *skb, struct hsr_frame_info *frame,
 }
 
 static struct sk_buff *create_tagged_skb(struct sk_buff *skb_o,
-					 struct hsr_frame_info *frame,
-					 struct hsr_port *port)
+					 struct hsr_prp_frame_info *frame,
+					 struct hsr_prp_port *port)
 {
 	int movelen;
 	unsigned char *dst, *src;
 	struct sk_buff *skb;
 
 	/* Create the new skb with enough headroom to fit the HSR tag */
-	skb = __pskb_copy(skb_o, skb_headroom(skb_o) + HSR_HLEN, GFP_ATOMIC);
+	skb = __pskb_copy(skb_o, skb_headroom(skb_o) + HSR_PRP_HLEN,
+			  GFP_ATOMIC);
 	if (skb == NULL)
 		return NULL;
 	skb_reset_mac_header(skb);
 
 	if (skb->ip_summed == CHECKSUM_PARTIAL)
-		skb->csum_start += HSR_HLEN;
+		skb->csum_start += HSR_PRP_HLEN;
 
 	movelen = ETH_HLEN;
 	if (frame->is_vlan)
 		movelen += VLAN_HLEN;
 
 	src = skb_mac_header(skb);
-	dst = skb_push(skb, HSR_HLEN);
+	dst = skb_push(skb, HSR_PRP_HLEN);
 	memmove(dst, src, movelen);
 	skb_reset_mac_header(skb);
 
-	hsr_fill_tag(skb, frame, port, port->hsr->prot_version);
+	hsr_fill_tag(skb, frame, port, port->priv->prot_version);
 
 	return skb;
 }
@@ -189,16 +188,16 @@ static struct sk_buff *create_tagged_skb(struct sk_buff *skb_o,
 /* If the original frame was an HSR tagged frame, just clone it to be sent
  * unchanged. Otherwise, create a private frame especially tagged for 'port'.
  */
-static struct sk_buff *frame_get_tagged_skb(struct hsr_frame_info *frame,
-					    struct hsr_port *port)
+static struct sk_buff *frame_get_tagged_skb(struct hsr_prp_frame_info *frame,
+					    struct hsr_prp_port *port)
 {
 	if (frame->skb_hsr)
 		return skb_clone(frame->skb_hsr, GFP_ATOMIC);
 
-	if ((port->type != HSR_PT_SLAVE_A) &&
-	    (port->type != HSR_PT_SLAVE_B)) {
+	if ((port->type != HSR_PRP_PT_SLAVE_A) &&
+	    (port->type != HSR_PRP_PT_SLAVE_B)) {
 		WARN_ONCE(1,
-			  "Bug: creating a tagged frame for a non-ring port");
+			  "Bug: creating a tagged frame for a non slave port");
 		return NULL;
 	}
 
@@ -206,8 +205,9 @@ static struct sk_buff *frame_get_tagged_skb(struct hsr_frame_info *frame,
 }
 
 
-static void hsr_deliver_master(struct sk_buff *skb, struct hsr_node *node_src,
-			       struct hsr_port *port)
+static void hsr_prp_deliver_master(struct sk_buff *skb,
+				   struct hsr_prp_node *node_src,
+				   struct hsr_prp_port *port)
 {
 	struct net_device *dev = port->dev;
 	bool was_multicast_frame;
@@ -218,7 +218,7 @@ static void hsr_deliver_master(struct sk_buff *skb, struct hsr_node *node_src,
 	 * interfaces of the remote node and hence no need to substitute
 	 * the source MAC address.
 	 */
-	if (!port->hsr->rx_offloaded)
+	if (!port->priv->rx_offloaded)
 		hsr_addr_subst_source(node_src, skb);
 
 	skb_pull(skb, ETH_HLEN);
@@ -233,11 +233,11 @@ static void hsr_deliver_master(struct sk_buff *skb, struct hsr_node *node_src,
 	}
 }
 
-static int hsr_xmit(struct sk_buff *skb, struct hsr_port *port,
-		    struct hsr_frame_info *frame)
+static int hsr_prp_xmit(struct sk_buff *skb, struct hsr_prp_port *port,
+			struct hsr_prp_frame_info *frame)
 {
-	if (!port->hsr->rx_offloaded &&
-	    frame->port_rcv->type == HSR_PT_MASTER) {
+	if (!port->priv->rx_offloaded &&
+	    frame->port_rcv->type == HSR_PRP_PT_MASTER) {
 		hsr_addr_subst_dest(frame->node_src, skb, port);
 
 		/* Address substitution (IEC62439-3 pp 26, 50): replace mac
@@ -259,29 +259,29 @@ static int hsr_xmit(struct sk_buff *skb, struct hsr_port *port,
  * tags if they're of the non-HSR type (but only after duplicate discard). The
  * master device always strips HSR tags.
  */
-static void hsr_forward_do(struct hsr_frame_info *frame)
+static void hsr_prp_forward_do(struct hsr_prp_frame_info *frame)
 {
-	struct hsr_port *port;
+	struct hsr_prp_port *port;
 	struct sk_buff *skb;
 
-	hsr_for_each_port(frame->port_rcv->hsr, port) {
+	hsr_prp_for_each_port(frame->port_rcv->priv, port) {
 		/* Don't send frame back the way it came */
 		if (port == frame->port_rcv)
 			continue;
 
 		/* Don't deliver locally unless we should */
-		if ((port->type == HSR_PT_MASTER) && !frame->is_local_dest)
+		if ((port->type == HSR_PRP_PT_MASTER) && !frame->is_local_dest)
 			continue;
 
 		/* Deliver frames directly addressed to us to master only */
-		if ((port->type != HSR_PT_MASTER) &&
+		if ((port->type != HSR_PRP_PT_MASTER) &&
 		    frame->is_local_exclusive)
 			continue;
 
 		/* Don't send frame over port where it has been sent before
 		 * if not rx offloaded
 		 */
-		if (!port->hsr->rx_offloaded &&
+		if (!port->priv->rx_offloaded &&
 		    hsr_register_frame_out(port, frame->node_src,
 					   frame->sequence_nr))
 			continue;
@@ -291,25 +291,25 @@ static void hsr_forward_do(struct hsr_frame_info *frame)
 		 * firmware
 		 */
 		if (frame->is_supervision &&
-		    (port->type == HSR_PT_MASTER) &&
-		    (!port->hsr->rx_offloaded)) {
-			hsr_handle_sup_frame(frame->skb_hsr,
-					     frame->node_src,
-					     frame->port_rcv);
+		    (port->type == HSR_PRP_PT_MASTER) &&
+		    (!port->priv->rx_offloaded)) {
+			hsr_prp_handle_sup_frame(frame->skb_hsr,
+						 frame->node_src,
+						 frame->port_rcv);
 			continue;
 		}
 
 		/* if L2 forward is offloaded, don't forward frame
 		 * across slaves
 		 */
-		if (port->hsr->l2_fwd_offloaded &&
-		    (((frame->port_rcv->type == HSR_PT_SLAVE_A) &&
-		    (port->type ==  HSR_PT_SLAVE_B)) ||
-		    ((frame->port_rcv->type == HSR_PT_SLAVE_B) &&
-		    (port->type ==  HSR_PT_SLAVE_A))))
+		if (port->priv->l2_fwd_offloaded &&
+		    (((frame->port_rcv->type == HSR_PRP_PT_SLAVE_A) &&
+		    (port->type ==  HSR_PRP_PT_SLAVE_B)) ||
+		    ((frame->port_rcv->type == HSR_PRP_PT_SLAVE_B) &&
+		    (port->type ==  HSR_PRP_PT_SLAVE_A))))
 			continue;
 
-		if (port->type != HSR_PT_MASTER)
+		if (port->type != HSR_PRP_PT_MASTER)
 			skb = frame_get_tagged_skb(frame, port);
 		else
 			skb = frame_get_stripped_skb(frame, port);
@@ -319,17 +319,17 @@ static void hsr_forward_do(struct hsr_frame_info *frame)
 			continue;
 
 		skb->dev = port->dev;
-		if (port->type == HSR_PT_MASTER)
-			hsr_deliver_master(skb, frame->node_src, port);
+		if (port->type == HSR_PRP_PT_MASTER)
+			hsr_prp_deliver_master(skb, frame->node_src, port);
 		else
-			hsr_xmit(skb, port, frame);
+			hsr_prp_xmit(skb, port, frame);
 	}
 }
 
-static void check_local_dest(struct hsr_priv *hsr, struct sk_buff *skb,
-			     struct hsr_frame_info *frame)
+static void check_local_dest(struct hsr_prp_priv *priv, struct sk_buff *skb,
+			     struct hsr_prp_frame_info *frame)
 {
-	if (hsr_addr_is_self(hsr, eth_hdr(skb)->h_dest)) {
+	if (hsr_prp_addr_is_self(priv, eth_hdr(skb)->h_dest)) {
 		frame->is_local_exclusive = true;
 		skb->pkt_type = PACKET_HOST;
 	} else {
@@ -344,16 +344,18 @@ static void check_local_dest(struct hsr_priv *hsr, struct sk_buff *skb,
 		frame->is_local_dest = false;
 	}
 }
-static int hsr_fill_frame_info(struct hsr_frame_info *frame,
-			       struct sk_buff *skb, struct hsr_port *port)
+
+static int hsr_prp_fill_frame_info(struct hsr_prp_frame_info *frame,
+				   struct sk_buff *skb,
+				   struct hsr_prp_port *port)
 {
 	struct ethhdr *ethhdr;
 	unsigned long irqflags;
-	struct hsr_priv *priv = port->hsr;
+	struct hsr_prp_priv *priv = port->priv;
 
-	frame->is_supervision = is_supervision_frame(port->hsr, skb);
+	frame->is_supervision = is_supervision_frame(priv, skb);
 	if (frame->is_supervision && priv->rx_offloaded &&
-	    (port->type != HSR_PT_MASTER)) {
+	    (port->type != HSR_PRP_PT_MASTER)) {
 		WARN_ONCE(1,
 			  "HSR: unexpected rx supervisor frame when offloaded");
 		return -1;
@@ -363,8 +365,8 @@ static int hsr_fill_frame_info(struct hsr_frame_info *frame,
 	 * firmware/hardware implements LRE function.
 	 */
 	if (!priv->rx_offloaded) {
-		frame->node_src = hsr_get_node(&port->hsr->node_db, skb,
-					       frame->is_supervision);
+		frame->node_src = hsr_prp_get_node(&priv->node_db, skb,
+						   frame->is_supervision);
 		/* Unknown node and !is_supervision, or no mem */
 		if (!frame->node_src) {
 			WARN_ONCE(1, "Unknown frame received\n");
@@ -388,22 +390,22 @@ static int hsr_fill_frame_info(struct hsr_frame_info *frame,
 		frame->skb_std = skb;
 		frame->skb_hsr = NULL;
 		/* Sequence nr for the master node */
-		spin_lock_irqsave(&port->hsr->seqnr_lock, irqflags);
-		frame->sequence_nr = port->hsr->sequence_nr;
-		port->hsr->sequence_nr++;
-		spin_unlock_irqrestore(&port->hsr->seqnr_lock, irqflags);
+		spin_lock_irqsave(&priv->seqnr_lock, irqflags);
+		frame->sequence_nr = priv->sequence_nr;
+		priv->sequence_nr++;
+		spin_unlock_irqrestore(&priv->seqnr_lock, irqflags);
 	}
 
 	frame->port_rcv = port;
-	check_local_dest(port->hsr, skb, frame);
+	check_local_dest(priv, skb, frame);
 
 	return 0;
 }
 
 /* Must be called holding rcu read lock (because of the port parameter) */
-void hsr_forward_skb(struct sk_buff *skb, struct hsr_port *port)
+void hsr_prp_forward_skb(struct sk_buff *skb, struct hsr_prp_port *port)
 {
-	struct hsr_frame_info frame;
+	struct hsr_prp_frame_info frame;
 
 	if (skb_mac_header(skb) != skb->data) {
 		WARN_ONCE(1, "%s:%d: Malformed frame (port_src %s)\n",
@@ -411,13 +413,13 @@ void hsr_forward_skb(struct sk_buff *skb, struct hsr_port *port)
 		goto out_drop;
 	}
 
-	if (hsr_fill_frame_info(&frame, skb, port) < 0)
+	if (hsr_prp_fill_frame_info(&frame, skb, port) < 0)
 		goto out_drop;
 	/* No need to register frame when rx offload is supported */
-	if (!port->hsr->rx_offloaded)
+	if (!port->priv->rx_offloaded)
 		hsr_register_frame_in(frame.node_src, port, frame.sequence_nr);
 
-	hsr_forward_do(&frame);
+	hsr_prp_forward_do(&frame);
 
 	if (frame.skb_hsr != NULL)
 		kfree_skb(frame.skb_hsr);
diff --git a/net/hsr/hsr_forward.h b/net/hsr/hsr_forward.h
index 5c5bc4b..2b14b5b 100644
--- a/net/hsr/hsr_forward.h
+++ b/net/hsr/hsr_forward.h
@@ -15,6 +15,6 @@
 #include <linux/netdevice.h>
 #include "hsr_main.h"
 
-void hsr_forward_skb(struct sk_buff *skb, struct hsr_port *port);
+void hsr_prp_forward_skb(struct sk_buff *skb, struct hsr_prp_port *port);
 
 #endif /* __HSR_FORWARD_H */
diff --git a/net/hsr/hsr_framereg.c b/net/hsr/hsr_framereg.c
index ebb238b..1ef1924 100644
--- a/net/hsr/hsr_framereg.c
+++ b/net/hsr/hsr_framereg.c
@@ -43,11 +43,11 @@ static bool seq_nr_after(u16 a, u16 b)
 #define seq_nr_before_or_eq(a, b)	(!seq_nr_after((a), (b)))
 
 
-bool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr)
+bool hsr_prp_addr_is_self(struct hsr_prp_priv *priv, unsigned char *addr)
 {
-	struct hsr_node *node;
+	struct hsr_prp_node *node;
 
-	node = list_first_or_null_rcu(&hsr->self_node_db, struct hsr_node,
+	node = list_first_or_null_rcu(&priv->self_node_db, struct hsr_prp_node,
 				      mac_list);
 	if (!node) {
 		WARN_ONCE(1, "HSR: No self node\n");
@@ -64,10 +64,11 @@ bool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr)
 
 /* Search for mac entry. Caller must hold rcu read lock.
  */
-static struct hsr_node *find_node_by_addr_a(struct list_head *node_db,
-					    const unsigned char addr[ETH_ALEN])
+static struct hsr_prp_node *
+find_node_by_addr_a(struct list_head *node_db,
+		    const unsigned char addr[ETH_ALEN])
 {
-	struct hsr_node *node;
+	struct hsr_prp_node *node;
 
 	list_for_each_entry_rcu(node, node_db, mac_list) {
 		if (ether_addr_equal(node->mac_address_a, addr))
@@ -81,11 +82,11 @@ static struct hsr_node *find_node_by_addr_a(struct list_head *node_db,
 /* Helper for device init; the self_node_db is used in hsr_rcv() to recognize
  * frames from self that's been looped over the HSR ring.
  */
-int hsr_create_self_node(struct list_head *self_node_db,
-			 unsigned char addr_a[ETH_ALEN],
-			 unsigned char addr_b[ETH_ALEN])
+int hsr_prp_create_self_node(struct list_head *self_node_db,
+			     unsigned char addr_a[ETH_ALEN],
+			     unsigned char addr_b[ETH_ALEN])
 {
-	struct hsr_node *node, *oldnode;
+	struct hsr_prp_node *node, *oldnode;
 
 	node = kmalloc(sizeof(*node), GFP_KERNEL);
 	if (!node)
@@ -96,7 +97,7 @@ int hsr_create_self_node(struct list_head *self_node_db,
 
 	rcu_read_lock();
 	oldnode = list_first_or_null_rcu(self_node_db,
-					 struct hsr_node, mac_list);
+					 struct hsr_prp_node, mac_list);
 	if (oldnode) {
 		list_replace_rcu(&oldnode->mac_list, &node->mac_list);
 		rcu_read_unlock();
@@ -114,10 +115,11 @@ int hsr_create_self_node(struct list_head *self_node_db,
  * seq_out is used to initialize filtering of outgoing duplicate frames
  * originating from the newly added node.
  */
-struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
-			      u16 seq_out)
+struct hsr_prp_node *hsr_prp_add_node(struct list_head *node_db,
+				      unsigned char addr[],
+				      u16 seq_out)
 {
-	struct hsr_node *node;
+	struct hsr_prp_node *node;
 	unsigned long now;
 	int i;
 
@@ -131,9 +133,9 @@ struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
 	 * as initialization. (0 could trigger an spurious ring error warning).
 	 */
 	now = jiffies;
-	for (i = 0; i < HSR_PT_PORTS; i++)
+	for (i = 0; i < HSR_PRP_PT_PORTS; i++)
 		node->time_in[i] = now;
-	for (i = 0; i < HSR_PT_PORTS; i++)
+	for (i = 0; i < HSR_PRP_PT_PORTS; i++)
 		node->seq_out[i] = seq_out;
 
 	list_add_tail_rcu(&node->mac_list, node_db);
@@ -143,10 +145,11 @@ struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
 
 /* Get the hsr_node from which 'skb' was sent.
  */
-struct hsr_node *hsr_get_node(struct list_head *node_db, struct sk_buff *skb,
-			      bool is_sup)
+struct hsr_prp_node *hsr_prp_get_node(struct list_head *node_db,
+				      struct sk_buff *skb,
+				      bool is_sup)
 {
-	struct hsr_node *node;
+	struct hsr_prp_node *node;
 	struct ethhdr *ethhdr;
 	u16 seq_out;
 
@@ -170,21 +173,22 @@ struct hsr_node *hsr_get_node(struct list_head *node_db, struct sk_buff *skb,
 		 */
 		seq_out = hsr_get_skb_sequence_nr(skb) - 1;
 	else
-		seq_out = HSR_SEQNR_START;
+		seq_out = HSR_PRP_SEQNR_START;
 
-	return hsr_add_node(node_db, ethhdr->h_source, seq_out);
+	return hsr_prp_add_node(node_db, ethhdr->h_source, seq_out);
 }
 
 /* Use the Supervision frame's info about an eventual mac_address_b for merging
  * nodes that has previously had their mac_address_b registered as a separate
  * node.
  */
-void hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,
-			  struct hsr_port *port_rcv)
+void hsr_prp_handle_sup_frame(struct sk_buff *skb,
+			      struct hsr_prp_node *node_curr,
+			      struct hsr_prp_port *port_rcv)
 {
 	struct ethhdr *ethhdr;
-	struct hsr_node *node_real;
-	struct hsr_sup_payload *hsr_sp;
+	struct hsr_prp_node *node_real;
+	struct hsr_prp_sup_payload *hsr_sp;
 	struct list_head *node_db;
 	int i;
 
@@ -198,17 +202,17 @@ void hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,
 		skb_pull(skb, sizeof(struct hsr_tag));
 
 	/* And leave the HSR sup tag. */
-	skb_pull(skb, sizeof(struct hsr_sup_tag));
+	skb_pull(skb, sizeof(struct hsr_prp_sup_tag));
 
-	hsr_sp = (struct hsr_sup_payload *)skb->data;
+	hsr_sp = (struct hsr_prp_sup_payload *)skb->data;
 
 	/* Merge node_curr (registered on mac_address_b) into node_real */
-	node_db = &port_rcv->hsr->node_db;
+	node_db = &port_rcv->priv->node_db;
 	node_real = find_node_by_addr_a(node_db, hsr_sp->mac_address_a);
 	if (!node_real)
 		/* No frame received from AddrA of this node yet */
-		node_real = hsr_add_node(node_db, hsr_sp->mac_address_a,
-					 HSR_SEQNR_START - 1);
+		node_real = hsr_prp_add_node(node_db, hsr_sp->mac_address_a,
+					     HSR_PRP_SEQNR_START - 1);
 	if (!node_real)
 		goto done; /* No mem */
 	if (node_real == node_curr)
@@ -216,7 +220,7 @@ void hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,
 		goto done;
 
 	ether_addr_copy(node_real->mac_address_b, ethhdr->h_source);
-	for (i = 0; i < HSR_PT_PORTS; i++) {
+	for (i = 0; i < HSR_PRP_PT_PORTS; i++) {
 		if (!node_curr->time_in_stale[i] &&
 		    time_after(node_curr->time_in[i], node_real->time_in[i])) {
 			node_real->time_in[i] = node_curr->time_in[i];
@@ -240,7 +244,7 @@ void hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,
  * address with that node's "official" address (mac_address_a) so that upper
  * layers recognize where it came from.
  */
-void hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb)
+void hsr_addr_subst_source(struct hsr_prp_node *node, struct sk_buff *skb)
 {
 	if (!skb_mac_header_was_set(skb)) {
 		WARN_ONCE(1, "%s: Mac header not set\n", __func__);
@@ -259,10 +263,10 @@ void hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb)
  * This is needed to keep the packets flowing through switches that learn on
  * which "side" the different interfaces are.
  */
-void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
-			 struct hsr_port *port)
+void hsr_addr_subst_dest(struct hsr_prp_node *node_src, struct sk_buff *skb,
+			 struct hsr_prp_port *port)
 {
-	struct hsr_node *node_dst;
+	struct hsr_prp_node *node_dst;
 
 	if (!skb_mac_header_was_set(skb)) {
 		WARN_ONCE(1, "%s: Mac header not set\n", __func__);
@@ -272,7 +276,7 @@ void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
 	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
 		return;
 
-	node_dst = find_node_by_addr_a(&port->hsr->node_db,
+	node_dst = find_node_by_addr_a(&port->priv->node_db,
 				       eth_hdr(skb)->h_dest);
 	if (!node_dst) {
 		WARN_ONCE(1, "%s: Unknown node\n", __func__);
@@ -287,8 +291,8 @@ void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
 		WARN_ONCE(1, "%s: mac address B not valid\n", __func__);
 }
 
-
-void hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,
+void hsr_register_frame_in(struct hsr_prp_node *node,
+			   struct hsr_prp_port *port,
 			   u16 sequence_nr)
 {
 	/* Don't register incoming frames without a valid sequence number. This
@@ -310,7 +314,8 @@ void hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,
  *	 0 otherwise, or
  *	 negative error code on error
  */
-int hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,
+int hsr_register_frame_out(struct hsr_prp_port *port,
+			   struct hsr_prp_node *node,
 			   u16 sequence_nr)
 {
 	if (seq_nr_before_or_eq(sequence_nr, node->seq_out[port->type]))
@@ -320,78 +325,76 @@ int hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,
 	return 0;
 }
 
-
-static struct hsr_port *get_late_port(struct hsr_priv *hsr,
-				      struct hsr_node *node)
+static struct hsr_prp_port *get_late_port(struct hsr_prp_priv *priv,
+					  struct hsr_prp_node *node)
 {
-	if (node->time_in_stale[HSR_PT_SLAVE_A])
-		return hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);
-	if (node->time_in_stale[HSR_PT_SLAVE_B])
-		return hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
-
-	if (time_after(node->time_in[HSR_PT_SLAVE_B],
-		       node->time_in[HSR_PT_SLAVE_A] +
-					msecs_to_jiffies(MAX_SLAVE_DIFF)))
-		return hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);
-	if (time_after(node->time_in[HSR_PT_SLAVE_A],
-		       node->time_in[HSR_PT_SLAVE_B] +
-					msecs_to_jiffies(MAX_SLAVE_DIFF)))
-		return hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
+	if (node->time_in_stale[HSR_PRP_PT_SLAVE_A])
+		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	if (node->time_in_stale[HSR_PRP_PT_SLAVE_B])
+		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+
+	if (time_after(node->time_in[HSR_PRP_PT_SLAVE_B],
+		       node->time_in[HSR_PRP_PT_SLAVE_A] +
+				msecs_to_jiffies(HSR_PRP_MAX_SLAVE_DIFF)))
+		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	if (time_after(node->time_in[HSR_PRP_PT_SLAVE_A],
+		       node->time_in[HSR_PRP_PT_SLAVE_B] +
+				msecs_to_jiffies(HSR_PRP_MAX_SLAVE_DIFF)))
+		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
 
 	return NULL;
 }
 
-
 /* Remove stale sequence_nr records. Called by timer every
  * HSR_LIFE_CHECK_INTERVAL (two seconds or so).
  */
-void hsr_prune_nodes(unsigned long data)
+void hsr_prp_prune_nodes(unsigned long data)
 {
-	struct hsr_priv *hsr;
-	struct hsr_node *node;
-	struct hsr_port *port;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_node *node;
+	struct hsr_prp_port *port;
 	unsigned long timestamp;
 	unsigned long time_a, time_b;
 
-	hsr = (struct hsr_priv *)data;
+	priv = (struct hsr_prp_priv *)data;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(node, &hsr->node_db, mac_list) {
+	list_for_each_entry_rcu(node, &priv->node_db, mac_list) {
 		/* Shorthand */
-		time_a = node->time_in[HSR_PT_SLAVE_A];
-		time_b = node->time_in[HSR_PT_SLAVE_B];
+		time_a = node->time_in[HSR_PRP_PT_SLAVE_A];
+		time_b = node->time_in[HSR_PRP_PT_SLAVE_B];
 
 		/* Check for timestamps old enough to risk wrap-around */
 		if (time_after(jiffies, time_a + MAX_JIFFY_OFFSET / 2))
-			node->time_in_stale[HSR_PT_SLAVE_A] = true;
+			node->time_in_stale[HSR_PRP_PT_SLAVE_A] = true;
 		if (time_after(jiffies, time_b + MAX_JIFFY_OFFSET / 2))
-			node->time_in_stale[HSR_PT_SLAVE_B] = true;
+			node->time_in_stale[HSR_PRP_PT_SLAVE_B] = true;
 
 		/* Get age of newest frame from node.
 		 * At least one time_in is OK here; nodes get pruned long
 		 * before both time_ins can get stale
 		 */
 		timestamp = time_a;
-		if (node->time_in_stale[HSR_PT_SLAVE_A] ||
-		    (!node->time_in_stale[HSR_PT_SLAVE_B] &&
+		if (node->time_in_stale[HSR_PRP_PT_SLAVE_A] ||
+		    (!node->time_in_stale[HSR_PRP_PT_SLAVE_B] &&
 		    time_after(time_b, time_a)))
 			timestamp = time_b;
 
 		/* Warn of ring error only as long as we get frames at all */
 		if (time_is_after_jiffies(timestamp +
-			msecs_to_jiffies(1.5 * MAX_SLAVE_DIFF))) {
+			msecs_to_jiffies(1.5 * HSR_PRP_MAX_SLAVE_DIFF))) {
 			rcu_read_lock();
-			port = get_late_port(hsr, node);
+			port = get_late_port(priv, node);
 			if (port)
-				hsr_nl_ringerror(hsr,
+				hsr_nl_ringerror(priv,
 						 node->mac_address_a, port);
 			rcu_read_unlock();
 		}
 
 		/* Prune old entries */
 		if (time_is_before_jiffies(timestamp +
-			msecs_to_jiffies(HSR_NODE_FORGET_TIME))) {
-			hsr_nl_nodedown(hsr, node->mac_address_a);
+			msecs_to_jiffies(HSR_PRP_NODE_FORGET_TIME))) {
+			hsr_nl_nodedown(priv, node->mac_address_a);
 			list_del_rcu(&node->mac_list);
 			/* Note that we need to free this entry later: */
 			kfree_rcu(node, rcu_head);
@@ -400,22 +403,21 @@ void hsr_prune_nodes(unsigned long data)
 	rcu_read_unlock();
 }
 
-
-void *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,
-			unsigned char addr[ETH_ALEN])
+void *hsr_prp_get_next_node(struct hsr_prp_priv *priv, void *_pos,
+			    unsigned char addr[ETH_ALEN])
 {
-	struct hsr_node *node;
+	struct hsr_prp_node *node;
 
 	if (!_pos) {
-		node = list_first_or_null_rcu(&hsr->node_db,
-					      struct hsr_node, mac_list);
+		node = list_first_or_null_rcu(&priv->node_db,
+					      struct hsr_prp_node, mac_list);
 		if (node)
 			ether_addr_copy(addr, node->mac_address_a);
 		return node;
 	}
 
 	node = _pos;
-	list_for_each_entry_continue_rcu(node, &hsr->node_db, mac_list) {
+	list_for_each_entry_continue_rcu(node, &priv->node_db, mac_list) {
 		ether_addr_copy(addr, node->mac_address_a);
 		return node;
 	}
@@ -423,22 +425,19 @@ void *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,
 	return NULL;
 }
 
-
-int hsr_get_node_data(struct hsr_priv *hsr,
-		      const unsigned char *addr,
-		      unsigned char addr_b[ETH_ALEN],
-		      unsigned int *addr_b_ifindex,
-		      int *if1_age,
-		      u16 *if1_seq,
-		      int *if2_age,
-		      u16 *if2_seq)
+int hsr_prp_get_node_data(struct hsr_prp_priv *priv,
+			  const unsigned char *addr,
+			  unsigned char addr_b[ETH_ALEN],
+			  unsigned int *addr_b_ifindex,
+			  int *if1_age, u16 *if1_seq,
+			  int *if2_age, u16 *if2_seq)
 {
-	struct hsr_node *node;
-	struct hsr_port *port;
+	struct hsr_prp_node *node;
+	struct hsr_prp_port *port;
 	unsigned long tdiff;
 
 	rcu_read_lock();
-	node = find_node_by_addr_a(&hsr->node_db, addr);
+	node = find_node_by_addr_a(&priv->node_db, addr);
 	if (!node) {
 		rcu_read_unlock();
 		return -ENOENT;	/* No such entry */
@@ -446,8 +445,8 @@ int hsr_get_node_data(struct hsr_priv *hsr,
 
 	ether_addr_copy(addr_b, node->mac_address_b);
 
-	tdiff = jiffies - node->time_in[HSR_PT_SLAVE_A];
-	if (node->time_in_stale[HSR_PT_SLAVE_A])
+	tdiff = jiffies - node->time_in[HSR_PRP_PT_SLAVE_A];
+	if (node->time_in_stale[HSR_PRP_PT_SLAVE_A])
 		*if1_age = INT_MAX;
 #if HZ <= MSEC_PER_SEC
 	else if (tdiff > msecs_to_jiffies(INT_MAX))
@@ -456,8 +455,8 @@ int hsr_get_node_data(struct hsr_priv *hsr,
 	else
 		*if1_age = jiffies_to_msecs(tdiff);
 
-	tdiff = jiffies - node->time_in[HSR_PT_SLAVE_B];
-	if (node->time_in_stale[HSR_PT_SLAVE_B])
+	tdiff = jiffies - node->time_in[HSR_PRP_PT_SLAVE_B];
+	if (node->time_in_stale[HSR_PRP_PT_SLAVE_B])
 		*if2_age = INT_MAX;
 #if HZ <= MSEC_PER_SEC
 	else if (tdiff > msecs_to_jiffies(INT_MAX))
@@ -467,11 +466,11 @@ int hsr_get_node_data(struct hsr_priv *hsr,
 		*if2_age = jiffies_to_msecs(tdiff);
 
 	/* Present sequence numbers as if they were incoming on interface */
-	*if1_seq = node->seq_out[HSR_PT_SLAVE_B];
-	*if2_seq = node->seq_out[HSR_PT_SLAVE_A];
+	*if1_seq = node->seq_out[HSR_PRP_PT_SLAVE_B];
+	*if2_seq = node->seq_out[HSR_PRP_PT_SLAVE_A];
 
-	if (node->addr_b_port != HSR_PT_NONE) {
-		port = hsr_port_get_hsr(hsr, node->addr_b_port);
+	if (node->addr_b_port != HSR_PRP_PT_NONE) {
+		port = hsr_prp_get_port(priv, node->addr_b_port);
 		*addr_b_ifindex = port->dev->ifindex;
 	} else {
 		*addr_b_ifindex = -1;
diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index 31ed0d2..caa5792 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -14,52 +14,52 @@
 
 #include "hsr_main.h"
 
-struct hsr_node;
+struct hsr_prp_node;
 
-struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
-			      u16 seq_out);
-struct hsr_node *hsr_get_node(struct list_head *node_db, struct sk_buff *skb,
-			      bool is_sup);
-void hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,
-			  struct hsr_port *port);
-bool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr);
+struct hsr_prp_node *hsr_prp_add_node(struct list_head *node_db,
+				      unsigned char addr[], u16 seq_out);
+struct hsr_prp_node *hsr_prp_get_node(struct list_head *node_db,
+				      struct sk_buff *skb, bool is_sup);
+void hsr_prp_handle_sup_frame(struct sk_buff *skb,
+			      struct hsr_prp_node *node_curr,
+			      struct hsr_prp_port *port);
+bool hsr_prp_addr_is_self(struct hsr_prp_priv *priv, unsigned char *addr);
 
-void hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb);
-void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
-			 struct hsr_port *port);
+void hsr_addr_subst_source(struct hsr_prp_node *node, struct sk_buff *skb);
+void hsr_addr_subst_dest(struct hsr_prp_node *node_src, struct sk_buff *skb,
+			 struct hsr_prp_port *port);
 
-void hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,
-			   u16 sequence_nr);
-int hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,
+void hsr_register_frame_in(struct hsr_prp_node *node,
+			   struct hsr_prp_port *port, u16 sequence_nr);
+int hsr_register_frame_out(struct hsr_prp_port *port,
+			   struct hsr_prp_node *node,
 			   u16 sequence_nr);
 
-void hsr_prune_nodes(unsigned long data);
+void hsr_prp_prune_nodes(unsigned long data);
 
-int hsr_create_self_node(struct list_head *self_node_db,
-			 unsigned char addr_a[ETH_ALEN],
-			 unsigned char addr_b[ETH_ALEN]);
+int hsr_prp_create_self_node(struct list_head *self_node_db,
+			     unsigned char addr_a[ETH_ALEN],
+			     unsigned char addr_b[ETH_ALEN]);
 
-void *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,
-			unsigned char addr[ETH_ALEN]);
+void *hsr_prp_get_next_node(struct hsr_prp_priv *priv, void *_pos,
+			    unsigned char addr[ETH_ALEN]);
 
-int hsr_get_node_data(struct hsr_priv *hsr,
-		      const unsigned char *addr,
-		      unsigned char addr_b[ETH_ALEN],
-		      unsigned int *addr_b_ifindex,
-		      int *if1_age,
-		      u16 *if1_seq,
-		      int *if2_age,
-		      u16 *if2_seq);
+int hsr_prp_get_node_data(struct hsr_prp_priv *priv,
+			  const unsigned char *addr,
+			  unsigned char addr_b[ETH_ALEN],
+			  unsigned int *addr_b_ifindex,
+			  int *if1_age, u16 *if1_seq,
+			  int *if2_age, u16 *if2_seq);
 
-struct hsr_node {
+struct hsr_prp_node {
 	struct list_head	mac_list;
 	unsigned char		mac_address_a[ETH_ALEN];
 	unsigned char		mac_address_b[ETH_ALEN];
 	/* Local slave through which AddrB frames are received from this node */
-	enum hsr_port_type	addr_b_port;
-	unsigned long		time_in[HSR_PT_PORTS];
-	bool			time_in_stale[HSR_PT_PORTS];
-	u16			seq_out[HSR_PT_PORTS];
+	enum hsr_prp_port_type	addr_b_port;
+	unsigned long		time_in[HSR_PRP_PT_PORTS];
+	bool			time_in_stale[HSR_PRP_PT_PORTS];
+	u16			seq_out[HSR_PRP_PT_PORTS];
 	struct rcu_head		rcu_head;
 };
 
diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index cd37d00..9100b25 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -19,39 +19,38 @@
 #include "hsr_framereg.h"
 #include "hsr_slave.h"
 
-
-static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
-			     void *ptr)
+int hsr_prp_netdev_notify(struct notifier_block *nb, unsigned long event,
+			  void *ptr)
 {
 	struct net_device *dev;
-	struct hsr_port *port, *master;
-	struct hsr_priv *hsr;
+	struct hsr_prp_port *port, *master;
+	struct hsr_prp_priv *priv;
 	int mtu_max;
 	int res;
 
 	dev = netdev_notifier_info_to_dev(ptr);
-	port = hsr_port_get_rtnl(dev);
+	port = hsr_prp_port_get_rtnl(dev);
 	if (port == NULL) {
-		if (!is_hsr_master(dev))
+		if (!is_hsr_prp_master(dev))
 			return NOTIFY_DONE;	/* Not an HSR device */
-		hsr = netdev_priv(dev);
-		port = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+		priv = netdev_priv(dev);
+		port = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 		if (port == NULL) {
 			/* Resend of notification concerning removed device? */
 			return NOTIFY_DONE;
 		}
 	} else {
-		hsr = port->hsr;
+		priv = port->priv;
 	}
 
 	switch (event) {
 	case NETDEV_UP:		/* Administrative state DOWN */
 	case NETDEV_DOWN:	/* Administrative state UP */
 	case NETDEV_CHANGE:	/* Link (carrier) state changes */
-		hsr_check_carrier_and_operstate(hsr);
+		hsr_prp_check_carrier_and_operstate(priv);
 		break;
 	case NETDEV_CHANGEADDR:
-		if (port->type == HSR_PT_MASTER) {
+		if (port->type == HSR_PRP_PT_MASTER) {
 			/* This should not happen since there's no
 			 * ndo_set_mac_address() for HSR devices - i.e. not
 			 * supported.
@@ -59,33 +58,33 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			break;
 		}
 
-		master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+		master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 
-		if (port->type == HSR_PT_SLAVE_A) {
+		if (port->type == HSR_PRP_PT_SLAVE_A) {
 			ether_addr_copy(master->dev->dev_addr, dev->dev_addr);
 			call_netdevice_notifiers(NETDEV_CHANGEADDR, master->dev);
 		}
 
 		/* Make sure we recognize frames from ourselves in hsr_rcv() */
-		port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
-		res = hsr_create_self_node(&hsr->self_node_db,
-					   master->dev->dev_addr,
-					   port ?
-						port->dev->dev_addr :
-						master->dev->dev_addr);
+		port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+		res = hsr_prp_create_self_node(&priv->self_node_db,
+					       master->dev->dev_addr,
+					       port ?
+					       port->dev->dev_addr :
+					       master->dev->dev_addr);
 		if (res)
 			netdev_warn(master->dev,
 				    "Could not update HSR node address.\n");
 		break;
 	case NETDEV_CHANGEMTU:
-		if (port->type == HSR_PT_MASTER)
+		if (port->type == HSR_PRP_PT_MASTER)
 			break; /* Handled in ndo_change_mtu() */
-		mtu_max = hsr_get_max_mtu(port->hsr);
-		master = hsr_port_get_hsr(port->hsr, HSR_PT_MASTER);
+		mtu_max = hsr_prp_get_max_mtu(port->priv);
+		master = hsr_prp_get_port(port->priv, HSR_PRP_PT_MASTER);
 		master->dev->mtu = mtu_max;
 		break;
 	case NETDEV_UNREGISTER:
-		hsr_del_port(port);
+		hsr_prp_del_port(port);
 		break;
 	case NETDEV_PRE_TYPE_CHANGE:
 		/* HSR works only on Ethernet devices. Refuse slave to change
@@ -97,27 +96,26 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 	return NOTIFY_DONE;
 }
 
-
-struct hsr_port *hsr_port_get_hsr(struct hsr_priv *hsr, enum hsr_port_type pt)
+struct hsr_prp_port *hsr_prp_get_port(struct hsr_prp_priv *priv,
+				      enum hsr_prp_port_type pt)
 {
-	struct hsr_port *port;
+	struct hsr_prp_port *port;
 
-	hsr_for_each_port(hsr, port)
+	hsr_prp_for_each_port(priv, port)
 		if (port->type == pt)
 			return port;
 	return NULL;
 }
 
 static struct notifier_block hsr_nb = {
-	.notifier_call = hsr_netdev_notify,	/* Slave event notifications */
+	.notifier_call = hsr_prp_netdev_notify,	/* Slave event notifications */
 };
 
-
 static int __init hsr_init(void)
 {
 	int res;
 
-	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_HLEN);
+	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_PRP_HLEN);
 
 	register_netdevice_notifier(&hsr_nb);
 	res = hsr_netlink_init();
diff --git a/net/hsr/hsr_main.h b/net/hsr/hsr_main.h
index 7f39cd8..b1669c4 100644
--- a/net/hsr/hsr_main.h
+++ b/net/hsr/hsr_main.h
@@ -20,29 +20,24 @@
  * Table 8.
  * All values in milliseconds.
  */
-#define HSR_LIFE_CHECK_INTERVAL		 2000 /* ms */
-#define HSR_NODE_FORGET_TIME		60000 /* ms */
-#define HSR_ANNOUNCE_INTERVAL		  100 /* ms */
-
+#define HSR_PRP_LIFE_CHECK_INTERVAL              2000 /* ms */
+#define HSR_PRP_NODE_FORGET_TIME                60000 /* ms */
+#define HSR_PRP_ANNOUNCE_INTERVAL                 100 /* ms */
 
 /* By how much may slave1 and slave2 timestamps of latest received frame from
  * each node differ before we notify of communication problem?
  */
-#define MAX_SLAVE_DIFF			 3000 /* ms */
-#define HSR_SEQNR_START			(USHRT_MAX - 1024)
-#define HSR_SUP_SEQNR_START		(HSR_SEQNR_START / 2)
-
-
+#define HSR_PRP_MAX_SLAVE_DIFF			 3000 /* ms */
+#define HSR_PRP_SEQNR_START			(USHRT_MAX - 1024)
+#define HSR_PRP_SUP_SEQNR_START		(HSR_PRP_SEQNR_START / 2)
 /* How often shall we check for broken ring and remove node entries older than
  * HSR_NODE_FORGET_TIME?
  */
-#define PRUNE_PERIOD			 3000 /* ms */
-
+#define HSR_PRP_PRUNE_PERIOD			 3000 /* ms */
 
 #define HSR_TLV_ANNOUNCE		   22
 #define HSR_TLV_LIFE_CHECK		   23
 
-
 /* HSR Tag.
  * As defined in IEC-62439-3:2010, the HSR tag is really { ethertype = 0x88FB,
  * path, LSDU_size, sequence Nr }. But we let eth_header() create { h_dest,
@@ -57,7 +52,7 @@ struct hsr_tag {
 	__be16		encap_proto;
 } __packed;
 
-#define HSR_HLEN	6
+#define HSR_PRP_HLEN	6
 
 #define HSR_V1_SUP_LSDUSIZE		52
 
@@ -100,69 +95,70 @@ struct hsr_ethhdr {
 } __packed;
 
 
-/* HSR Supervision Frame data types.
- * Field names as defined in the IEC:2010 standard for HSR.
+/* HSR/PRP Supervision Frame data types.
+ * Field names as defined in the IEC:2012 standard for HSR.
  */
-struct hsr_sup_tag {
+struct hsr_prp_sup_tag {
 	__be16		path_and_HSR_Ver;
 	__be16		sequence_nr;
 	__u8		HSR_TLV_type;
 	__u8		HSR_TLV_length;
 } __packed;
 
-struct hsr_sup_payload {
+struct hsr_prp_sup_payload {
 	unsigned char	mac_address_a[ETH_ALEN];
 } __packed;
 
-static inline u16 get_hsr_stag_path(struct hsr_sup_tag *hst)
+static inline u16 get_hsr_stag_path(struct hsr_prp_sup_tag *hst)
 {
 	return get_hsr_tag_path((struct hsr_tag *)hst);
 }
 
-static inline u16 get_hsr_stag_HSR_ver(struct hsr_sup_tag *hst)
+static inline u16 get_hsr_stag_HSR_ver(struct hsr_prp_sup_tag *hst)
 {
 	return get_hsr_tag_LSDU_size((struct hsr_tag *)hst);
 }
 
-static inline void set_hsr_stag_path(struct hsr_sup_tag *hst, u16 path)
+static inline void set_hsr_stag_path(struct hsr_prp_sup_tag *hst, u16 path)
 {
 	set_hsr_tag_path((struct hsr_tag *)hst, path);
 }
 
-static inline void set_hsr_stag_HSR_ver(struct hsr_sup_tag *hst, u16 HSR_ver)
+static inline void set_hsr_stag_HSR_ver(struct hsr_prp_sup_tag *hst,
+					u16 HSR_ver)
 {
 	set_hsr_tag_LSDU_size((struct hsr_tag *)hst, HSR_ver);
 }
 
 struct hsrv0_ethhdr_sp {
 	struct ethhdr		ethhdr;
-	struct hsr_sup_tag	hsr_sup;
+	struct hsr_prp_sup_tag	hsr_sup;
 } __packed;
 
 struct hsrv1_ethhdr_sp {
 	struct ethhdr		ethhdr;
 	struct hsr_tag		hsr;
-	struct hsr_sup_tag	hsr_sup;
+	struct hsr_prp_sup_tag	hsr_sup;
 } __packed;
 
 
-enum hsr_port_type {
-	HSR_PT_NONE = 0,	/* Must be 0, used by framereg */
-	HSR_PT_SLAVE_A,
-	HSR_PT_SLAVE_B,
-	HSR_PT_INTERLINK,
-	HSR_PT_MASTER,
-	HSR_PT_PORTS,	/* This must be the last item in the enum */
+enum hsr_prp_port_type {
+	HSR_PRP_PT_NONE = 0,	/* Must be 0, used by framereg */
+	HSR_PRP_PT_SLAVE_A,
+	HSR_PRP_PT_SLAVE_B,
+	HSR_PRP_PT_INTERLINK,
+	HSR_PRP_PT_MASTER,
+	HSR_PRP_PT_PORTS,	/* This must be the last item in the enum */
 };
 
-struct hsr_port {
+struct hsr_prp_port {
 	struct list_head	port_list;
 	struct net_device	*dev;
-	struct hsr_priv		*hsr;
-	enum hsr_port_type	type;
+	struct hsr_prp_priv	*priv;
+	enum hsr_prp_port_type	type;
 };
 
-struct hsr_priv {
+struct hsr_prp_priv {
 	struct rcu_head		rcu_head;
 	struct list_head	ports;
 	struct list_head	node_db;	/* Known HSR nodes */
@@ -183,10 +179,13 @@ struct hsr_priv {
 #endif
 };
 
-#define hsr_for_each_port(hsr, port) \
-	list_for_each_entry_rcu((port), &(hsr)->ports, port_list)
+#define hsr_prp_for_each_port(hsr_prp, port) \
+	list_for_each_entry_rcu((port), &(hsr_prp)->ports, port_list)
 
-struct hsr_port *hsr_port_get_hsr(struct hsr_priv *hsr, enum hsr_port_type pt);
+struct hsr_prp_port *hsr_prp_get_port(struct hsr_prp_priv *hsr_prp,
+				      enum hsr_prp_port_type pt);
+int hsr_prp_netdev_notify(struct notifier_block *nb, unsigned long event,
+			  void *ptr);
 
 /* Caller must ensure skb is a valid HSR frame */
 static inline u16 hsr_get_skb_sequence_nr(struct sk_buff *skb)
@@ -194,19 +193,20 @@ static inline u16 hsr_get_skb_sequence_nr(struct sk_buff *skb)
 	struct hsr_ethhdr *hsr_ethhdr;
 
 	hsr_ethhdr = (struct hsr_ethhdr *)skb_mac_header(skb);
+
 	return ntohs(hsr_ethhdr->hsr_tag.sequence_nr);
 }
 
 #if IS_ENABLED(CONFIG_DEBUG_FS)
-int hsr_prp_debugfs_init(struct hsr_priv *priv);
-void hsr_prp_debugfs_term(struct hsr_priv *priv);
+int hsr_prp_debugfs_init(struct hsr_prp_priv *priv);
+void hsr_prp_debugfs_term(struct hsr_prp_priv *priv);
 #else
-static inline int hsr_prp_debugfs_init(struct hsr_priv *priv)
+static inline int hsr_prp_debugfs_init(struct hsr_prp_priv *priv)
 {
 	return 0;
 }
 
-static inline void hsr_prp_debugfs_term(struct hsr_priv *priv)
+static inline void hsr_prp_debugfs_term(struct hsr_prp_priv *priv)
 {}
 #endif
 
diff --git a/net/hsr/hsr_netlink.c b/net/hsr/hsr_netlink.c
index 4b1b64a..2519107 100644
--- a/net/hsr/hsr_netlink.c
+++ b/net/hsr/hsr_netlink.c
@@ -28,7 +28,6 @@
 	[IFLA_HSR_SEQ_NR]		= { .type = NLA_U16 },
 };
 
-
 /* Here, it seems a netdevice has already been allocated for us, and the
  * hsr_dev_setup routine has been executed. Nice!
  */
@@ -68,21 +67,21 @@ static int hsr_newlink(struct net *src_net, struct net_device *dev,
 	else
 		hsr_version = nla_get_u8(data[IFLA_HSR_VERSION]);
 
-	return hsr_dev_finalize(dev, link, multicast_spec, hsr_version);
+	return hsr_prp_dev_finalize(dev, link, multicast_spec, hsr_version);
 }
 
 static int hsr_fill_info(struct sk_buff *skb, const struct net_device *dev)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *port;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
 	int res;
 
-	hsr = netdev_priv(dev);
+	priv = netdev_priv(dev);
 
 	res = 0;
 
 	rcu_read_lock();
-	port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);
+	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
 	if (port)
 		res = nla_put_u32(skb, IFLA_HSR_SLAVE1, port->dev->ifindex);
 	rcu_read_unlock();
@@ -90,7 +89,7 @@ static int hsr_fill_info(struct sk_buff *skb, const struct net_device *dev)
 		goto nla_put_failure;
 
 	rcu_read_lock();
-	port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
+	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
 	if (port)
 		res = nla_put_u32(skb, IFLA_HSR_SLAVE2, port->dev->ifindex);
 	rcu_read_unlock();
@@ -98,8 +97,8 @@ static int hsr_fill_info(struct sk_buff *skb, const struct net_device *dev)
 		goto nla_put_failure;
 
 	if (nla_put(skb, IFLA_HSR_SUPERVISION_ADDR, ETH_ALEN,
-		    hsr->sup_multicast_addr) ||
-	    nla_put_u16(skb, IFLA_HSR_SEQ_NR, hsr->sequence_nr))
+		    priv->sup_multicast_addr) ||
+	    nla_put_u16(skb, IFLA_HSR_SEQ_NR, priv->sequence_nr))
 		goto nla_put_failure;
 
 	return 0;
@@ -112,8 +111,8 @@ static int hsr_fill_info(struct sk_buff *skb, const struct net_device *dev)
 	.kind		= "hsr",
 	.maxtype	= IFLA_HSR_MAX,
 	.policy		= hsr_policy,
-	.priv_size	= sizeof(struct hsr_priv),
-	.setup		= hsr_dev_setup,
+	.priv_size	= sizeof(struct hsr_prp_priv),
+	.setup		= hsr_prp_dev_setup,
 	.newlink	= hsr_newlink,
 	.fill_info	= hsr_fill_info,
 };
@@ -145,12 +144,12 @@ static int hsr_fill_info(struct sk_buff *skb, const struct net_device *dev)
  * over one of the slave interfaces. This would indicate an open network ring
  * (i.e. a link has failed somewhere).
  */
-void hsr_nl_ringerror(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN],
-		      struct hsr_port *port)
+void hsr_nl_ringerror(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN],
+		      struct hsr_prp_port *port)
 {
 	struct sk_buff *skb;
 	void *msg_head;
-	struct hsr_port *master;
+	struct hsr_prp_port *master;
 	int res;
 
 	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
@@ -179,7 +178,7 @@ void hsr_nl_ringerror(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN],
 
 fail:
 	rcu_read_lock();
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 	netdev_warn(master->dev, "Could not send HSR ring error message\n");
 	rcu_read_unlock();
 }
@@ -187,11 +186,11 @@ void hsr_nl_ringerror(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN],
 /* This is called when we haven't heard from the node with MAC address addr for
  * some time (just before the node is removed from the node table/list).
  */
-void hsr_nl_nodedown(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN])
+void hsr_nl_nodedown(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN])
 {
 	struct sk_buff *skb;
 	void *msg_head;
-	struct hsr_port *master;
+	struct hsr_prp_port *master;
 	int res;
 
 	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
@@ -217,7 +216,7 @@ void hsr_nl_nodedown(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN])
 
 fail:
 	rcu_read_lock();
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 	netdev_warn(master->dev, "Could not send HSR node down\n");
 	rcu_read_unlock();
 }
@@ -239,8 +238,8 @@ static int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)
 	/* For sending */
 	struct sk_buff *skb_out;
 	void *msg_head;
-	struct hsr_priv *hsr;
-	struct hsr_port *port;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
 	unsigned char hsr_node_addr_b[ETH_ALEN];
 	int hsr_node_if1_age;
 	u16 hsr_node_if1_seq;
@@ -263,7 +262,7 @@ static int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)
 					nla_get_u32(info->attrs[HSR_A_IFINDEX]));
 	if (!hsr_dev)
 		goto invalid;
-	if (!is_hsr_master(hsr_dev))
+	if (!is_hsr_prp_master(hsr_dev))
 		goto invalid;
 
 
@@ -287,16 +286,17 @@ static int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)
 	if (res < 0)
 		goto nla_put_failure;
 
-	hsr = netdev_priv(hsr_dev);
-	res = hsr_get_node_data(hsr,
-				(unsigned char *)
-				nla_data(info->attrs[HSR_A_NODE_ADDR]),
-				hsr_node_addr_b,
-				&addr_b_ifindex,
-				&hsr_node_if1_age,
-				&hsr_node_if1_seq,
-				&hsr_node_if2_age,
-				&hsr_node_if2_seq);
+	priv = netdev_priv(hsr_dev);
+	res =
+	hsr_prp_get_node_data(priv,
+			      (unsigned char *)
+			      nla_data(info->attrs[HSR_A_NODE_ADDR]),
+			      hsr_node_addr_b,
+			      &addr_b_ifindex,
+			      &hsr_node_if1_age,
+			      &hsr_node_if1_seq,
+			      &hsr_node_if2_age,
+			      &hsr_node_if2_seq);
 	if (res < 0)
 		goto nla_put_failure;
 
@@ -323,7 +323,7 @@ static int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)
 	if (res < 0)
 		goto nla_put_failure;
 	rcu_read_lock();
-	port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);
+	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
 	if (port)
 		res = nla_put_u32(skb_out, HSR_A_IF1_IFINDEX,
 				  port->dev->ifindex);
@@ -338,7 +338,7 @@ static int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)
 	if (res < 0)
 		goto nla_put_failure;
 	rcu_read_lock();
-	port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
+	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
 	if (port)
 		res = nla_put_u32(skb_out, HSR_A_IF2_IFINDEX,
 				  port->dev->ifindex);
@@ -374,7 +374,7 @@ static int hsr_get_node_list(struct sk_buff *skb_in, struct genl_info *info)
 	/* For sending */
 	struct sk_buff *skb_out;
 	void *msg_head;
-	struct hsr_priv *hsr;
+	struct hsr_prp_priv *priv;
 	void *pos;
 	unsigned char addr[ETH_ALEN];
 	int res;
@@ -390,7 +390,7 @@ static int hsr_get_node_list(struct sk_buff *skb_in, struct genl_info *info)
 				     nla_get_u32(info->attrs[HSR_A_IFINDEX]));
 	if (!hsr_dev)
 		goto invalid;
-	if (!is_hsr_master(hsr_dev))
+	if (!is_hsr_prp_master(hsr_dev))
 		goto invalid;
 
 
@@ -414,17 +414,17 @@ static int hsr_get_node_list(struct sk_buff *skb_in, struct genl_info *info)
 	if (res < 0)
 		goto nla_put_failure;
 
-	hsr = netdev_priv(hsr_dev);
+	priv = netdev_priv(hsr_dev);
 
 	rcu_read_lock();
-	pos = hsr_get_next_node(hsr, NULL, addr);
+	pos = hsr_prp_get_next_node(priv, NULL, addr);
 	while (pos) {
 		res = nla_put(skb_out, HSR_A_NODE_ADDR, ETH_ALEN, addr);
 		if (res < 0) {
 			rcu_read_unlock();
 			goto nla_put_failure;
 		}
-		pos = hsr_get_next_node(hsr, pos, addr);
+		pos = hsr_prp_get_next_node(priv, pos, addr);
 	}
 	rcu_read_unlock();
 
@@ -445,7 +445,6 @@ static int hsr_get_node_list(struct sk_buff *skb_in, struct genl_info *info)
 	return res;
 }
 
-
 static const struct genl_ops hsr_ops[] = {
 	{
 		.cmd = HSR_C_GET_NODE_STATUS,
diff --git a/net/hsr/hsr_netlink.h b/net/hsr/hsr_netlink.h
index 48db53a..aed62be 100644
--- a/net/hsr/hsr_netlink.h
+++ b/net/hsr/hsr_netlink.h
@@ -16,14 +16,14 @@
 #include <linux/module.h>
 #include <uapi/linux/hsr_netlink.h>
 
-struct hsr_priv;
-struct hsr_port;
+struct hsr_prp_priv;
+struct hsr_prp_port;
 
 int __init hsr_netlink_init(void);
 void __exit hsr_netlink_exit(void);
 
-void hsr_nl_ringerror(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN],
-		      struct hsr_port *port);
-void hsr_nl_nodedown(struct hsr_priv *hsr, unsigned char addr[ETH_ALEN]);
+void hsr_nl_ringerror(struct hsr_prp_priv *hsr, unsigned char addr[ETH_ALEN],
+		      struct hsr_prp_port *port);
+void hsr_nl_nodedown(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN]);
 
 #endif /* __HSR_NETLINK_H */
diff --git a/net/hsr/hsr_prp_debugfs.c b/net/hsr/hsr_prp_debugfs.c
index ef8c492..bb86ea1 100644
--- a/net/hsr/hsr_prp_debugfs.c
+++ b/net/hsr/hsr_prp_debugfs.c
@@ -31,8 +31,8 @@ static void print_mac_address(struct seq_file *sfp, unsigned char *mac)
 static int
 hsr_prp_node_table_show (struct seq_file *sfp, void *data)
 {
-	struct hsr_priv *priv = (struct hsr_priv *) sfp->private;
-	struct hsr_node *node;
+	struct hsr_prp_priv *priv = (struct hsr_prp_priv *)sfp->private;
+	struct hsr_prp_node *node;
 
 	seq_printf(sfp, "Node Table entries\n");
 	seq_printf(sfp, "MAC-Address-A,   MAC-Address-B, time_in[A], ");
@@ -41,13 +41,13 @@ static void print_mac_address(struct seq_file *sfp, unsigned char *mac)
 	rcu_read_lock();
 	list_for_each_entry_rcu(node, &priv->node_db, mac_list) {
 		/* skip self node */
-		if (hsr_addr_is_self(priv, node->mac_address_a))
+		if (hsr_prp_addr_is_self(priv, node->mac_address_a))
 			continue;
 		print_mac_address(sfp, &node->mac_address_a[0]);
 		seq_printf(sfp, " ");
 		print_mac_address(sfp, &node->mac_address_b[0]);
-		seq_printf(sfp, "0x%lx, ", node->time_in[HSR_PT_SLAVE_A]);
-		seq_printf(sfp, "0x%lx ", node->time_in[HSR_PT_SLAVE_B]);
+		seq_printf(sfp, "0x%lx, ", node->time_in[HSR_PRP_PT_SLAVE_A]);
+		seq_printf(sfp, "0x%lx ", node->time_in[HSR_PRP_PT_SLAVE_B]);
 		seq_printf(sfp, "0x%x", node->addr_b_port);
 		seq_printf(sfp, "\n");
 	}
@@ -83,7 +83,7 @@ static void print_mac_address(struct seq_file *sfp, unsigned char *mac)
  * When debugfs is configured this routine sets up the node_table file per
  * hsr/prp device for dumping the node_table entries
  */
-int hsr_prp_debugfs_init(struct hsr_priv *priv)
+int hsr_prp_debugfs_init(struct hsr_prp_priv *priv)
 {
 	int rc = -1;
 	struct dentry *de = NULL;
@@ -117,7 +117,7 @@ int hsr_prp_debugfs_init(struct hsr_priv *priv)
  * elements that are specific to hsr-prp
  */
 void
-hsr_prp_debugfs_term(struct hsr_priv *priv)
+hsr_prp_debugfs_term(struct hsr_prp_priv *priv)
 {
 	debugfs_remove(priv->node_tbl_file);
 	priv->node_tbl_file = NULL;
diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index f5b6038..3c8b166 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -17,11 +17,10 @@
 #include "hsr_forward.h"
 #include "hsr_framereg.h"
 
-
-static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
+static rx_handler_result_t hsr_prp_handle_frame(struct sk_buff **pskb)
 {
 	struct sk_buff *skb = *pskb;
-	struct hsr_port *port;
+	struct hsr_prp_port *port;
 	u16 protocol;
 
 	if (!skb_mac_header_was_set(skb)) {
@@ -30,9 +29,9 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 	}
 
 	rcu_read_lock(); /* hsr->node_db, hsr->ports */
-	port = hsr_port_get_rcu(skb->dev);
+	port = hsr_prp_port_get_rcu(skb->dev);
 
-	if (hsr_addr_is_self(port->hsr, eth_hdr(skb)->h_source)) {
+	if (hsr_prp_addr_is_self(port->priv, eth_hdr(skb)->h_source)) {
 		/* Directly kill frames sent by ourselves */
 		kfree_skb(skb);
 		goto finish_consume;
@@ -44,7 +43,7 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 
 	skb_push(skb, ETH_HLEN);
 
-	hsr_forward_skb(skb, port);
+	hsr_prp_forward_skb(skb, port);
 
 finish_consume:
 	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
@@ -55,13 +54,12 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 	return RX_HANDLER_PASS;
 }
 
-bool hsr_port_exists(const struct net_device *dev)
+bool hsr_prp_port_exists(const struct net_device *dev)
 {
-	return rcu_access_pointer(dev->rx_handler) == hsr_handle_frame;
+	return rcu_access_pointer(dev->rx_handler) == hsr_prp_handle_frame;
 }
 
-
-static int hsr_check_dev_ok(struct net_device *dev)
+static int hsr_prp_check_dev_ok(struct net_device *dev)
 {
 	/* Don't allow HSR on non-ethernet like devices */
 	if ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||
@@ -71,12 +69,12 @@ static int hsr_check_dev_ok(struct net_device *dev)
 	}
 
 	/* Don't allow enslaving hsr devices */
-	if (is_hsr_master(dev)) {
+	if (is_hsr_prp_master(dev)) {
 		netdev_info(dev, "Cannot create trees of HSR devices.\n");
 		return -EINVAL;
 	}
 
-	if (hsr_port_exists(dev)) {
+	if (hsr_prp_port_exists(dev)) {
 		netdev_info(dev, "This device is already a HSR slave.\n");
 		return -EINVAL;
 	}
@@ -100,7 +98,8 @@ static int hsr_check_dev_ok(struct net_device *dev)
 
 
 /* Setup device to be added to the HSR bridge. */
-static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
+static int hsr_prp_portdev_setup(struct net_device *dev,
+				 struct hsr_prp_port *port)
 {
 	int res;
 
@@ -114,7 +113,7 @@ static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
 	 * res = netdev_master_upper_dev_link(port->dev, port->hsr->dev); ?
 	 */
 
-	res = netdev_rx_handler_register(dev, hsr_handle_frame, port);
+	res = netdev_rx_handler_register(dev, hsr_prp_handle_frame, port);
 	if (res)
 		goto fail_rx_handler;
 	dev_disable_lro(dev);
@@ -129,19 +128,19 @@ static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
 	return res;
 }
 
-int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
-		 enum hsr_port_type type)
+int hsr_prp_add_port(struct hsr_prp_priv *priv, struct net_device *dev,
+		     enum hsr_prp_port_type type)
 {
-	struct hsr_port *port, *master;
+	struct hsr_prp_port *port, *master;
 	int res;
 
-	if (type != HSR_PT_MASTER) {
-		res = hsr_check_dev_ok(dev);
+	if (type != HSR_PRP_PT_MASTER) {
+		res = hsr_prp_check_dev_ok(dev);
 		if (res)
 			return res;
 	}
 
-	port = hsr_port_get_hsr(hsr, type);
+	port = hsr_prp_get_port(priv, type);
 	if (port != NULL)
 		return -EBUSY;	/* This port already exists */
 
@@ -149,22 +148,22 @@ int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
 	if (port == NULL)
 		return -ENOMEM;
 
-	if (type != HSR_PT_MASTER) {
-		res = hsr_portdev_setup(dev, port);
+	if (type != HSR_PRP_PT_MASTER) {
+		res = hsr_prp_portdev_setup(dev, port);
 		if (res)
 			goto fail_dev_setup;
 	}
 
-	port->hsr = hsr;
+	port->priv = priv;
 	port->dev = dev;
 	port->type = type;
 
-	list_add_tail_rcu(&port->port_list, &hsr->ports);
+	list_add_tail_rcu(&port->port_list, &priv->ports);
 	synchronize_rcu();
 
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 	netdev_update_features(master->dev);
-	dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
+	dev_set_mtu(master->dev, hsr_prp_get_max_mtu(priv));
 
 	return 0;
 
@@ -173,26 +172,26 @@ int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
 	return res;
 }
 
-void hsr_del_port(struct hsr_port *port)
+void hsr_prp_del_port(struct hsr_prp_port *port)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *master;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *master;
 
-	hsr = port->hsr;
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	priv = port->priv;
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
 	list_del_rcu(&port->port_list);
 
 	if (port != master) {
 		if (master != NULL) {
 			netdev_update_features(master->dev);
-			dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
+			dev_set_mtu(master->dev, hsr_prp_get_max_mtu(priv));
 		}
 		netdev_rx_handler_unregister(port->dev);
 		dev_set_promiscuity(port->dev, -1);
 	}
 
 	/* FIXME?
-	 * netdev_upper_dev_unlink(port->dev, port->hsr->dev);
+	 * netdev_upper_dev_unlink(port->dev, port->priv->dev);
 	 */
 
 	synchronize_rcu();
diff --git a/net/hsr/hsr_slave.h b/net/hsr/hsr_slave.h
index 3ccfbf7..09c3e09 100644
--- a/net/hsr/hsr_slave.h
+++ b/net/hsr/hsr_slave.h
@@ -17,21 +17,23 @@
 #include <linux/rtnetlink.h>
 #include "hsr_main.h"
 
-int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
-		 enum hsr_port_type pt);
-void hsr_del_port(struct hsr_port *port);
-bool hsr_port_exists(const struct net_device *dev);
+int hsr_prp_add_port(struct hsr_prp_priv *priv, struct net_device *dev,
+		     enum hsr_prp_port_type pt);
+void hsr_prp_del_port(struct hsr_prp_port *port);
+bool hsr_prp_port_exists(const struct net_device *dev);
 
-static inline struct hsr_port *hsr_port_get_rtnl(const struct net_device *dev)
+static inline struct hsr_prp_port
+*hsr_prp_port_get_rtnl(const struct net_device *dev)
 {
 	ASSERT_RTNL();
-	return hsr_port_exists(dev) ?
+	return hsr_prp_port_exists(dev) ?
 				rtnl_dereference(dev->rx_handler_data) : NULL;
 }
 
-static inline struct hsr_port *hsr_port_get_rcu(const struct net_device *dev)
+static inline struct hsr_prp_port
+*hsr_prp_port_get_rcu(const struct net_device *dev)
 {
-	return hsr_port_exists(dev) ?
+	return hsr_prp_port_exists(dev) ?
 				rcu_dereference(dev->rx_handler_data) : NULL;
 }
 
-- 
1.9.1

