From 2abcb381c8b9cebc7407cd64f3e4de71df0a7a8f Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Thu, 16 Feb 2017 14:06:44 -0500
Subject: [PATCH 10/22] hsr: rename files to introduce prp protocol support

To re-use files for PRP implementation, rename some of the files
which are common across both protocol implementation. While at
it rename the directory under net to net/hsr-prp as well.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
Signed-off-by: Jacob Stiffler <j-stiffler@ti.com>
---
 MAINTAINERS                    |   1 +
 net/Kconfig                    |   2 +-
 net/Makefile                   |   2 +-
 net/hsr-prp/Kconfig            |  36 +++
 net/hsr-prp/Makefile           |   9 +
 net/hsr-prp/hsr_main.c         | 135 ++++++++++
 net/hsr-prp/hsr_netlink.c      | 492 +++++++++++++++++++++++++++++++++++++
 net/hsr-prp/hsr_netlink.h      |  29 +++
 net/hsr-prp/hsr_prp_debugfs.c  | 125 ++++++++++
 net/hsr-prp/hsr_prp_device.c   | 543 ++++++++++++++++++++++++++++++++++++++++
 net/hsr-prp/hsr_prp_device.h   |  25 ++
 net/hsr-prp/hsr_prp_forward.c  | 431 ++++++++++++++++++++++++++++++++
 net/hsr-prp/hsr_prp_forward.h  |  20 ++
 net/hsr-prp/hsr_prp_framereg.c | 481 ++++++++++++++++++++++++++++++++++++
 net/hsr-prp/hsr_prp_framereg.h |  66 +++++
 net/hsr-prp/hsr_prp_main.h     | 212 ++++++++++++++++
 net/hsr-prp/hsr_prp_slave.c    | 200 +++++++++++++++
 net/hsr-prp/hsr_prp_slave.h    |  40 +++
 net/hsr/Kconfig                |  36 ---
 net/hsr/Makefile               |   9 -
 net/hsr/hsr_device.c           | 544 -----------------------------------------
 net/hsr/hsr_device.h           |  25 --
 net/hsr/hsr_forward.c          | 433 --------------------------------
 net/hsr/hsr_forward.h          |  20 --
 net/hsr/hsr_framereg.c         | 482 ------------------------------------
 net/hsr/hsr_framereg.h         |  66 -----
 net/hsr/hsr_main.c             | 134 ----------
 net/hsr/hsr_main.h             | 213 ----------------
 net/hsr/hsr_netlink.c          | 493 -------------------------------------
 net/hsr/hsr_netlink.h          |  29 ---
 net/hsr/hsr_prp_debugfs.c      | 126 ----------
 net/hsr/hsr_slave.c            | 201 ---------------
 net/hsr/hsr_slave.h            |  40 ---
 33 files changed, 2847 insertions(+), 2853 deletions(-)
 create mode 100644 net/hsr-prp/Kconfig
 create mode 100644 net/hsr-prp/Makefile
 create mode 100644 net/hsr-prp/hsr_main.c
 create mode 100644 net/hsr-prp/hsr_netlink.c
 create mode 100644 net/hsr-prp/hsr_netlink.h
 create mode 100644 net/hsr-prp/hsr_prp_debugfs.c
 create mode 100644 net/hsr-prp/hsr_prp_device.c
 create mode 100644 net/hsr-prp/hsr_prp_device.h
 create mode 100644 net/hsr-prp/hsr_prp_forward.c
 create mode 100644 net/hsr-prp/hsr_prp_forward.h
 create mode 100644 net/hsr-prp/hsr_prp_framereg.c
 create mode 100644 net/hsr-prp/hsr_prp_framereg.h
 create mode 100644 net/hsr-prp/hsr_prp_main.h
 create mode 100644 net/hsr-prp/hsr_prp_slave.c
 create mode 100644 net/hsr-prp/hsr_prp_slave.h
 delete mode 100644 net/hsr/Kconfig
 delete mode 100644 net/hsr/Makefile
 delete mode 100644 net/hsr/hsr_device.c
 delete mode 100644 net/hsr/hsr_device.h
 delete mode 100644 net/hsr/hsr_forward.c
 delete mode 100644 net/hsr/hsr_forward.h
 delete mode 100644 net/hsr/hsr_framereg.c
 delete mode 100644 net/hsr/hsr_framereg.h
 delete mode 100644 net/hsr/hsr_main.c
 delete mode 100644 net/hsr/hsr_main.h
 delete mode 100644 net/hsr/hsr_netlink.c
 delete mode 100644 net/hsr/hsr_netlink.h
 delete mode 100644 net/hsr/hsr_prp_debugfs.c
 delete mode 100644 net/hsr/hsr_slave.c
 delete mode 100644 net/hsr/hsr_slave.h

diff --git a/MAINTAINERS b/MAINTAINERS
index b677d0e..935b4e6 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -5825,6 +5825,7 @@ F:	drivers/net/usb/hso.c
 
 HSR NETWORK PROTOCOL
 M:	Arvid Brodin <arvid.brodin@alten.se>
+M:	Murali Karicheri <m-karicheri2@ti.com>
 L:	netdev@vger.kernel.org
 S:	Maintained
 F:	net/hsr/
diff --git a/net/Kconfig b/net/Kconfig
index 7b6cd34..936aa34 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -233,7 +233,7 @@ source "net/openvswitch/Kconfig"
 source "net/vmw_vsock/Kconfig"
 source "net/netlink/Kconfig"
 source "net/mpls/Kconfig"
-source "net/hsr/Kconfig"
+source "net/hsr-prp/Kconfig"
 source "net/switchdev/Kconfig"
 source "net/l3mdev/Kconfig"
 source "net/qrtr/Kconfig"
diff --git a/net/Makefile b/net/Makefile
index baf377e..6fd9ec1 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -72,7 +72,7 @@ obj-$(CONFIG_NFC)		+= nfc/
 obj-$(CONFIG_OPENVSWITCH)	+= openvswitch/
 obj-$(CONFIG_VSOCKETS)	+= vmw_vsock/
 obj-$(CONFIG_MPLS)		+= mpls/
-obj-$(CONFIG_HSR_PRP)		+= hsr/
+obj-$(CONFIG_HSR_PRP)		+= hsr-prp/
 ifneq ($(CONFIG_NET_SWITCHDEV),)
 obj-y				+= switchdev/
 endif
diff --git a/net/hsr-prp/Kconfig b/net/hsr-prp/Kconfig
new file mode 100644
index 0000000..3684735
--- /dev/null
+++ b/net/hsr-prp/Kconfig
@@ -0,0 +1,36 @@
+#
+# IEC 62439-3 High-availability Seamless Redundancy (HSR) /
+# IEC 62439-4 Parallel Redundancy Protocol (PRP) support
+#
+config HSR_PRP
+	tristate "IEC 62439 HSR/PRP Support"
+	---help---
+	  This enables IEC 62439 defined High-availability Seamless
+	  Redundancy (HSR) and Parallel Redundancy Protocol (PRP) support.
+	  If you say Y here, then your Linux box will be able to act as a
+	  DANH ("Doubly attached node implementing HSR") or DANP ("Doubly
+	  attached node implementing PRP"). For this to work, your Linux
+	  box needs (at least) two physical Ethernet interfaces.
+
+	  For DANH, it must be connected as a node in a ring network together
+	  with other HSR capable nodes. All Ethernet frames sent over the hsr
+	  device will be sent in both directions on the ring (over both slave
+	  ports), giving a redundant, instant fail-over network. Each HSR node
+	  in the ring acts like a bridge for HSR frames, but filters frames
+	  that have been forwarded earlier.
+
+	  For DANP, it must be connected as a node connecting to two
+	  separate networks over the two slave interfaces. Like HSR, Ethernet
+	  frames sent over the prp device will be sent to both networks giving
+	  a redundant, instant fail-over network.
+
+	  This code is a "best effort" to comply with the HSR standard as
+	  described in IEC 62439-3:2010 (HSRv0) and IEC 62439-3:2012 (HSRv1),
+	  and PRP standard described in IEC 62439-4:2012 (PRP), but no
+	  compliancy tests have been made. Use iproute2 to select the protocol
+	  you would like to use.
+
+	  You need to perform any and all necessary tests yourself before
+	  relying on this code in a safety critical system!
+
+	  If unsure, say N.
diff --git a/net/hsr-prp/Makefile b/net/hsr-prp/Makefile
new file mode 100644
index 0000000..1076497
--- /dev/null
+++ b/net/hsr-prp/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for HSR
+#
+
+obj-$(CONFIG_HSR_PRP)	+= hsr-prp.o
+
+hsr-prp-y		:= hsr_main.o hsr_prp_framereg.o hsr_prp_device.o \
+			   hsr_netlink.o hsr_prp_slave.o hsr_prp_forward.o
+hsr-prp-$(CONFIG_DEBUG_FS) += hsr_prp_debugfs.o
diff --git a/net/hsr-prp/hsr_main.c b/net/hsr-prp/hsr_main.c
new file mode 100644
index 0000000..cc1bacf
--- /dev/null
+++ b/net/hsr-prp/hsr_main.c
@@ -0,0 +1,135 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#include <linux/netdevice.h>
+#include <linux/rculist.h>
+#include <linux/timer.h>
+#include <linux/etherdevice.h>
+#include "hsr_prp_main.h"
+#include "hsr_prp_device.h"
+#include "hsr_netlink.h"
+#include "hsr_prp_framereg.h"
+#include "hsr_prp_slave.h"
+
+int hsr_prp_netdev_notify(struct notifier_block *nb, unsigned long event,
+			  void *ptr)
+{
+	struct net_device *dev;
+	struct hsr_prp_port *port, *master;
+	struct hsr_prp_priv *priv;
+	int mtu_max;
+	int res;
+
+	dev = netdev_notifier_info_to_dev(ptr);
+	port = hsr_prp_port_get_rtnl(dev);
+	if (!port) {
+		if (!is_hsr_prp_master(dev))
+			return NOTIFY_DONE;	/* Not an HSR device */
+		priv = netdev_priv(dev);
+		port = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+		if (!port) {
+			/* Resend of notification concerning removed device? */
+			return NOTIFY_DONE;
+		}
+	} else {
+		priv = port->priv;
+	}
+
+	switch (event) {
+	case NETDEV_UP:		/* Administrative state DOWN */
+	case NETDEV_DOWN:	/* Administrative state UP */
+	case NETDEV_CHANGE:	/* Link (carrier) state changes */
+		hsr_prp_check_carrier_and_operstate(priv);
+		break;
+	case NETDEV_CHANGEADDR:
+		if (port->type == HSR_PRP_PT_MASTER) {
+			/* This should not happen since there's no
+			 * ndo_set_mac_address() for HSR devices - i.e. not
+			 * supported.
+			 */
+			break;
+		}
+
+		master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+
+		if (port->type == HSR_PRP_PT_SLAVE_A) {
+			ether_addr_copy(master->dev->dev_addr, dev->dev_addr);
+			call_netdevice_notifiers(NETDEV_CHANGEADDR,
+						 master->dev);
+		}
+
+		/* Make sure we recognize frames from ourselves in hsr_rcv() */
+		port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+		res = hsr_prp_create_self_node(&priv->self_node_db,
+					       master->dev->dev_addr,
+					       port ?
+					       port->dev->dev_addr :
+					       master->dev->dev_addr);
+		if (res)
+			netdev_warn(master->dev,
+				    "Could not update HSR node address.\n");
+		break;
+	case NETDEV_CHANGEMTU:
+		if (port->type == HSR_PRP_PT_MASTER)
+			break; /* Handled in ndo_change_mtu() */
+		mtu_max = hsr_prp_get_max_mtu(port->priv);
+		master = hsr_prp_get_port(port->priv, HSR_PRP_PT_MASTER);
+		master->dev->mtu = mtu_max;
+		break;
+	case NETDEV_UNREGISTER:
+		hsr_prp_del_port(port);
+		break;
+	case NETDEV_PRE_TYPE_CHANGE:
+		/* HSR works only on Ethernet devices. Refuse slave to change
+		 * its type.
+		 */
+		return NOTIFY_BAD;
+	}
+
+	return NOTIFY_DONE;
+}
+
+struct hsr_prp_port *hsr_prp_get_port(struct hsr_prp_priv *priv,
+				      enum hsr_prp_port_type pt)
+{
+	struct hsr_prp_port *port;
+
+	hsr_prp_for_each_port(priv, port)
+		if (port->type == pt)
+			return port;
+	return NULL;
+}
+
+static struct notifier_block hsr_nb = {
+	.notifier_call = hsr_prp_netdev_notify,	/* Slave event notifications */
+};
+
+static int __init hsr_init(void)
+{
+	int res;
+
+	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_PRP_HLEN);
+
+	register_netdevice_notifier(&hsr_nb);
+	res = hsr_netlink_init();
+
+	return res;
+}
+
+static void __exit hsr_exit(void)
+{
+	unregister_netdevice_notifier(&hsr_nb);
+	hsr_netlink_exit();
+}
+
+module_init(hsr_init);
+module_exit(hsr_exit);
+MODULE_LICENSE("GPL");
diff --git a/net/hsr-prp/hsr_netlink.c b/net/hsr-prp/hsr_netlink.c
new file mode 100644
index 0000000..300623f
--- /dev/null
+++ b/net/hsr-prp/hsr_netlink.c
@@ -0,0 +1,492 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ *
+ * Routines for handling Netlink messages for HSR.
+ */
+
+#include "hsr_netlink.h"
+#include <linux/kernel.h>
+#include <net/rtnetlink.h>
+#include <net/genetlink.h>
+#include "hsr_prp_main.h"
+#include "hsr_prp_device.h"
+#include "hsr_prp_framereg.h"
+
+static const struct nla_policy hsr_policy[IFLA_HSR_MAX + 1] = {
+	[IFLA_HSR_SLAVE1]		= { .type = NLA_U32 },
+	[IFLA_HSR_SLAVE2]		= { .type = NLA_U32 },
+	[IFLA_HSR_MULTICAST_SPEC]	= { .type = NLA_U8 },
+	[IFLA_HSR_VERSION]	= { .type = NLA_U8 },
+	[IFLA_HSR_SUPERVISION_ADDR]	= { .len = ETH_ALEN },
+	[IFLA_HSR_SEQ_NR]		= { .type = NLA_U16 },
+};
+
+/* Here, it seems a netdevice has already been allocated for us, and the
+ * hsr_dev_setup routine has been executed. Nice!
+ */
+static int hsr_newlink(struct net *src_net, struct net_device *dev,
+		       struct nlattr *tb[], struct nlattr *data[])
+{
+	struct net_device *link[2];
+	unsigned char multicast_spec, hsr_version;
+
+	if (!data) {
+		netdev_info(dev, "HSR: No slave devices specified\n");
+		return -EINVAL;
+	}
+	if (!data[IFLA_HSR_SLAVE1]) {
+		netdev_info(dev, "HSR: Slave1 device not specified\n");
+		return -EINVAL;
+	}
+	link[0] = __dev_get_by_index(src_net,
+				     nla_get_u32(data[IFLA_HSR_SLAVE1]));
+	if (!data[IFLA_HSR_SLAVE2]) {
+		netdev_info(dev, "HSR: Slave2 device not specified\n");
+		return -EINVAL;
+	}
+	link[1] = __dev_get_by_index(src_net,
+				     nla_get_u32(data[IFLA_HSR_SLAVE2]));
+
+	if (!link[0] || !link[1])
+		return -ENODEV;
+	if (link[0] == link[1])
+		return -EINVAL;
+
+	if (!data[IFLA_HSR_MULTICAST_SPEC])
+		multicast_spec = 0;
+	else
+		multicast_spec = nla_get_u8(data[IFLA_HSR_MULTICAST_SPEC]);
+
+	if (!data[IFLA_HSR_VERSION])
+		hsr_version = 0;
+	else
+		hsr_version = nla_get_u8(data[IFLA_HSR_VERSION]);
+
+	return hsr_prp_dev_finalize(dev, link, multicast_spec, hsr_version);
+}
+
+static int hsr_fill_info(struct sk_buff *skb, const struct net_device *dev)
+{
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
+	int res;
+
+	priv = netdev_priv(dev);
+
+	res = 0;
+
+	rcu_read_lock();
+	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	if (port)
+		res = nla_put_u32(skb, IFLA_HSR_SLAVE1, port->dev->ifindex);
+	rcu_read_unlock();
+	if (res)
+		goto nla_put_failure;
+
+	rcu_read_lock();
+	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+	if (port)
+		res = nla_put_u32(skb, IFLA_HSR_SLAVE2, port->dev->ifindex);
+	rcu_read_unlock();
+	if (res)
+		goto nla_put_failure;
+
+	if (nla_put(skb, IFLA_HSR_SUPERVISION_ADDR, ETH_ALEN,
+		    priv->sup_multicast_addr) ||
+	    nla_put_u16(skb, IFLA_HSR_SEQ_NR, priv->sequence_nr))
+		goto nla_put_failure;
+
+	return 0;
+
+nla_put_failure:
+	return -EMSGSIZE;
+}
+
+static struct rtnl_link_ops hsr_link_ops __read_mostly = {
+	.kind		= "hsr",
+	.maxtype	= IFLA_HSR_MAX,
+	.policy		= hsr_policy,
+	.priv_size	= sizeof(struct hsr_prp_priv),
+	.setup		= hsr_prp_dev_setup,
+	.newlink	= hsr_newlink,
+	.fill_info	= hsr_fill_info,
+};
+
+/* attribute policy */
+static const struct nla_policy hsr_genl_policy[HSR_A_MAX + 1] = {
+	[HSR_A_NODE_ADDR] = { .len = ETH_ALEN },
+	[HSR_A_NODE_ADDR_B] = { .len = ETH_ALEN },
+	[HSR_A_IFINDEX] = { .type = NLA_U32 },
+	[HSR_A_IF1_AGE] = { .type = NLA_U32 },
+	[HSR_A_IF2_AGE] = { .type = NLA_U32 },
+	[HSR_A_IF1_SEQ] = { .type = NLA_U16 },
+	[HSR_A_IF2_SEQ] = { .type = NLA_U16 },
+};
+
+static struct genl_family hsr_genl_family = {
+	.id = GENL_ID_GENERATE,
+	.hdrsize = 0,
+	.name = "HSR",
+	.version = 1,
+	.maxattr = HSR_A_MAX,
+};
+
+static const struct genl_multicast_group hsr_mcgrps[] = {
+	{ .name = "hsr-network", },
+};
+
+/* This is called if for some node with MAC address addr, we only get frames
+ * over one of the slave interfaces. This would indicate an open network ring
+ * (i.e. a link has failed somewhere).
+ */
+void hsr_nl_ringerror(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN],
+		      struct hsr_prp_port *port)
+{
+	struct sk_buff *skb;
+	void *msg_head;
+	struct hsr_prp_port *master;
+	int res;
+
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (!skb)
+		goto fail;
+
+	msg_head = genlmsg_put(skb, 0, 0, &hsr_genl_family, 0,
+			       HSR_C_RING_ERROR);
+	if (!msg_head)
+		goto nla_put_failure;
+
+	res = nla_put(skb, HSR_A_NODE_ADDR, ETH_ALEN, addr);
+	if (res < 0)
+		goto nla_put_failure;
+
+	res = nla_put_u32(skb, HSR_A_IFINDEX, port->dev->ifindex);
+	if (res < 0)
+		goto nla_put_failure;
+
+	genlmsg_end(skb, msg_head);
+	genlmsg_multicast(&hsr_genl_family, skb, 0, 0, GFP_ATOMIC);
+
+	return;
+
+nla_put_failure:
+	kfree_skb(skb);
+
+fail:
+	rcu_read_lock();
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+	netdev_warn(master->dev, "Could not send HSR ring error message\n");
+	rcu_read_unlock();
+}
+
+/* This is called when we haven't heard from the node with MAC address addr for
+ * some time (just before the node is removed from the node table/list).
+ */
+void hsr_nl_nodedown(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN])
+{
+	struct sk_buff *skb;
+	void *msg_head;
+	struct hsr_prp_port *master;
+	int res;
+
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (!skb)
+		goto fail;
+
+	msg_head = genlmsg_put(skb, 0, 0, &hsr_genl_family, 0, HSR_C_NODE_DOWN);
+	if (!msg_head)
+		goto nla_put_failure;
+
+	res = nla_put(skb, HSR_A_NODE_ADDR, ETH_ALEN, addr);
+	if (res < 0)
+		goto nla_put_failure;
+
+	genlmsg_end(skb, msg_head);
+	genlmsg_multicast(&hsr_genl_family, skb, 0, 0, GFP_ATOMIC);
+
+	return;
+
+nla_put_failure:
+	kfree_skb(skb);
+
+fail:
+	rcu_read_lock();
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+	netdev_warn(master->dev, "Could not send HSR node down\n");
+	rcu_read_unlock();
+}
+
+/* HSR_C_GET_NODE_STATUS lets userspace query the internal HSR node table
+ * about the status of a specific node in the network, defined by its MAC
+ * address.
+ *
+ * Input: hsr ifindex, node mac address
+ * Output: hsr ifindex, node mac address (copied from request),
+ *	   age of latest frame from node over slave 1, slave 2 [ms]
+ */
+static int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)
+{
+	/* For receiving */
+	struct nlattr *na;
+	struct net_device *hsr_dev;
+
+	/* For sending */
+	struct sk_buff *skb_out;
+	void *msg_head;
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
+	unsigned char hsr_node_addr_b[ETH_ALEN];
+	int hsr_node_if1_age;
+	u16 hsr_node_if1_seq;
+	int hsr_node_if2_age;
+	u16 hsr_node_if2_seq;
+	int addr_b_ifindex;
+	int res;
+
+	if (!info)
+		goto invalid;
+
+	na = info->attrs[HSR_A_IFINDEX];
+	if (!na)
+		goto invalid;
+	na = info->attrs[HSR_A_NODE_ADDR];
+	if (!na)
+		goto invalid;
+
+	hsr_dev = __dev_get_by_index(genl_info_net(info),
+				     nla_get_u32(info->attrs[HSR_A_IFINDEX]));
+	if (!hsr_dev)
+		goto invalid;
+	if (!is_hsr_prp_master(hsr_dev))
+		goto invalid;
+
+	/* Send reply */
+	skb_out = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb_out) {
+		res = -ENOMEM;
+		goto fail;
+	}
+
+	msg_head = genlmsg_put(skb_out, NETLINK_CB(skb_in).portid,
+			       info->snd_seq, &hsr_genl_family, 0,
+			       HSR_C_SET_NODE_STATUS);
+	if (!msg_head) {
+		res = -ENOMEM;
+		goto nla_put_failure;
+	}
+
+	res = nla_put_u32(skb_out, HSR_A_IFINDEX, hsr_dev->ifindex);
+	if (res < 0)
+		goto nla_put_failure;
+
+	priv = netdev_priv(hsr_dev);
+	res =
+	hsr_prp_get_node_data(priv,
+			      (unsigned char *)
+			      nla_data(info->attrs[HSR_A_NODE_ADDR]),
+			      hsr_node_addr_b,
+			      &addr_b_ifindex,
+			      &hsr_node_if1_age,
+			      &hsr_node_if1_seq,
+			      &hsr_node_if2_age,
+			      &hsr_node_if2_seq);
+	if (res < 0)
+		goto nla_put_failure;
+
+	res = nla_put(skb_out, HSR_A_NODE_ADDR, ETH_ALEN,
+		      nla_data(info->attrs[HSR_A_NODE_ADDR]));
+	if (res < 0)
+		goto nla_put_failure;
+
+	if (addr_b_ifindex > -1) {
+		res = nla_put(skb_out, HSR_A_NODE_ADDR_B, ETH_ALEN,
+			      hsr_node_addr_b);
+		if (res < 0)
+			goto nla_put_failure;
+
+		res = nla_put_u32(skb_out, HSR_A_ADDR_B_IFINDEX,
+				  addr_b_ifindex);
+		if (res < 0)
+			goto nla_put_failure;
+	}
+
+	res = nla_put_u32(skb_out, HSR_A_IF1_AGE, hsr_node_if1_age);
+	if (res < 0)
+		goto nla_put_failure;
+	res = nla_put_u16(skb_out, HSR_A_IF1_SEQ, hsr_node_if1_seq);
+	if (res < 0)
+		goto nla_put_failure;
+	rcu_read_lock();
+	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	if (port)
+		res = nla_put_u32(skb_out, HSR_A_IF1_IFINDEX,
+				  port->dev->ifindex);
+	rcu_read_unlock();
+	if (res < 0)
+		goto nla_put_failure;
+
+	res = nla_put_u32(skb_out, HSR_A_IF2_AGE, hsr_node_if2_age);
+	if (res < 0)
+		goto nla_put_failure;
+	res = nla_put_u16(skb_out, HSR_A_IF2_SEQ, hsr_node_if2_seq);
+	if (res < 0)
+		goto nla_put_failure;
+	rcu_read_lock();
+	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+	if (port)
+		res = nla_put_u32(skb_out, HSR_A_IF2_IFINDEX,
+				  port->dev->ifindex);
+	rcu_read_unlock();
+	if (res < 0)
+		goto nla_put_failure;
+
+	genlmsg_end(skb_out, msg_head);
+	genlmsg_unicast(genl_info_net(info), skb_out, info->snd_portid);
+
+	return 0;
+
+invalid:
+	netlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL);
+	return 0;
+
+nla_put_failure:
+	kfree_skb(skb_out);
+	/* Fall through */
+
+fail:
+	return res;
+}
+
+/* Get a list of MacAddressA of all nodes known to this node (including self).
+ */
+static int hsr_get_node_list(struct sk_buff *skb_in, struct genl_info *info)
+{
+	/* For receiving */
+	struct nlattr *na;
+	struct net_device *hsr_dev;
+
+	/* For sending */
+	struct sk_buff *skb_out;
+	void *msg_head;
+	struct hsr_prp_priv *priv;
+	void *pos;
+	unsigned char addr[ETH_ALEN];
+	int res;
+
+	if (!info)
+		goto invalid;
+
+	na = info->attrs[HSR_A_IFINDEX];
+	if (!na)
+		goto invalid;
+
+	hsr_dev = __dev_get_by_index(genl_info_net(info),
+				     nla_get_u32(info->attrs[HSR_A_IFINDEX]));
+	if (!hsr_dev)
+		goto invalid;
+	if (!is_hsr_prp_master(hsr_dev))
+		goto invalid;
+
+	/* Send reply */
+	skb_out = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb_out) {
+		res = -ENOMEM;
+		goto fail;
+	}
+
+	msg_head = genlmsg_put(skb_out, NETLINK_CB(skb_in).portid,
+			       info->snd_seq, &hsr_genl_family, 0,
+			       HSR_C_SET_NODE_LIST);
+	if (!msg_head) {
+		res = -ENOMEM;
+		goto nla_put_failure;
+	}
+
+	res = nla_put_u32(skb_out, HSR_A_IFINDEX, hsr_dev->ifindex);
+	if (res < 0)
+		goto nla_put_failure;
+
+	priv = netdev_priv(hsr_dev);
+
+	rcu_read_lock();
+	pos = hsr_prp_get_next_node(priv, NULL, addr);
+	while (pos) {
+		res = nla_put(skb_out, HSR_A_NODE_ADDR, ETH_ALEN, addr);
+		if (res < 0) {
+			rcu_read_unlock();
+			goto nla_put_failure;
+		}
+		pos = hsr_prp_get_next_node(priv, pos, addr);
+	}
+	rcu_read_unlock();
+
+	genlmsg_end(skb_out, msg_head);
+	genlmsg_unicast(genl_info_net(info), skb_out, info->snd_portid);
+
+	return 0;
+
+invalid:
+	netlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL);
+	return 0;
+
+nla_put_failure:
+	kfree_skb(skb_out);
+	/* Fall through */
+
+fail:
+	return res;
+}
+
+static const struct genl_ops hsr_ops[] = {
+	{
+		.cmd = HSR_C_GET_NODE_STATUS,
+		.flags = 0,
+		.policy = hsr_genl_policy,
+		.doit = hsr_get_node_status,
+		.dumpit = NULL,
+	},
+	{
+		.cmd = HSR_C_GET_NODE_LIST,
+		.flags = 0,
+		.policy = hsr_genl_policy,
+		.doit = hsr_get_node_list,
+		.dumpit = NULL,
+	},
+};
+
+int __init hsr_netlink_init(void)
+{
+	int rc;
+
+	rc = rtnl_link_register(&hsr_link_ops);
+	if (rc)
+		goto fail_rtnl_link_register;
+
+	rc = genl_register_family_with_ops_groups(&hsr_genl_family, hsr_ops,
+						  hsr_mcgrps);
+	if (rc)
+		goto fail_genl_register_family;
+
+	return 0;
+
+fail_genl_register_family:
+	rtnl_link_unregister(&hsr_link_ops);
+fail_rtnl_link_register:
+
+	return rc;
+}
+
+void __exit hsr_netlink_exit(void)
+{
+	genl_unregister_family(&hsr_genl_family);
+	rtnl_link_unregister(&hsr_link_ops);
+}
+
+MODULE_ALIAS_RTNL_LINK("hsr");
diff --git a/net/hsr-prp/hsr_netlink.h b/net/hsr-prp/hsr_netlink.h
new file mode 100644
index 0000000..aed62be
--- /dev/null
+++ b/net/hsr-prp/hsr_netlink.h
@@ -0,0 +1,29 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#ifndef __HSR_NETLINK_H
+#define __HSR_NETLINK_H
+
+#include <linux/if_ether.h>
+#include <linux/module.h>
+#include <uapi/linux/hsr_netlink.h>
+
+struct hsr_prp_priv;
+struct hsr_prp_port;
+
+int __init hsr_netlink_init(void);
+void __exit hsr_netlink_exit(void);
+
+void hsr_nl_ringerror(struct hsr_prp_priv *hsr, unsigned char addr[ETH_ALEN],
+		      struct hsr_prp_port *port);
+void hsr_nl_nodedown(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN]);
+
+#endif /* __HSR_NETLINK_H */
diff --git a/net/hsr-prp/hsr_prp_debugfs.c b/net/hsr-prp/hsr_prp_debugfs.c
new file mode 100644
index 0000000..02345c4
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_debugfs.c
@@ -0,0 +1,125 @@
+/*
+ * hsr_prp_debugfs code
+ * Copyright (C) 2017 Texas Instruments Incorporated
+ *
+ * Author(s):
+ *	Murali Karicheri <m-karicheri2@ti.com?
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/debugfs.h>
+#include "hsr_prp_main.h"
+#include "hsr_prp_framereg.h"
+
+static void print_mac_address(struct seq_file *sfp, unsigned char *mac)
+{
+	seq_printf(sfp, "%02x:%02x:%02x:%02x:%02x:%02x:",
+		   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+}
+
+/* hsr_prp_node_table_show - Formats and prints node_table entries
+ */
+static int
+hsr_prp_node_table_show(struct seq_file *sfp, void *data)
+{
+	struct hsr_prp_priv *priv = (struct hsr_prp_priv *)sfp->private;
+	struct hsr_prp_node *node;
+
+	seq_puts(sfp, "Node Table entries\n");
+	seq_puts(sfp, "MAC-Address-A,   MAC-Address-B, time_in[A], ");
+	seq_puts(sfp, "time_in[B], Address-B port");
+	seq_puts(sfp, "\n");
+	rcu_read_lock();
+	list_for_each_entry_rcu(node, &priv->node_db, mac_list) {
+		/* skip self node */
+		if (hsr_prp_addr_is_self(priv, node->mac_address_a))
+			continue;
+		print_mac_address(sfp, &node->mac_address_a[0]);
+		seq_puts(sfp, " ");
+		print_mac_address(sfp, &node->mac_address_b[0]);
+		seq_printf(sfp, "0x%lx, ", node->time_in[HSR_PRP_PT_SLAVE_A]);
+		seq_printf(sfp, "0x%lx ", node->time_in[HSR_PRP_PT_SLAVE_B]);
+		seq_printf(sfp, "0x%x", node->addr_b_port);
+		seq_puts(sfp, "\n");
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+/* hsr_prp_node_table_open - Open the node_table file
+ *
+ * Description:
+ * This routine opens a debugfs file node_table of specific hsr device
+ */
+static int
+hsr_prp_node_table_open(struct inode *inode, struct file *filp)
+{
+	return single_open(filp, hsr_prp_node_table_show, inode->i_private);
+}
+
+static const struct file_operations hsr_prp_fops = {
+	.owner	= THIS_MODULE,
+	.open	= hsr_prp_node_table_open,
+	.read	= seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+/* hsr_prp_debugfs_init - create hsr-prp node_table file for dumping
+ * the node table
+ *
+ * Description:
+ * When debugfs is configured this routine sets up the node_table file per
+ * hsr/prp device for dumping the node_table entries
+ */
+int hsr_prp_debugfs_init(struct hsr_prp_priv *priv,
+			 struct net_device *hsr_prp_dev)
+{
+	int rc = -1;
+	struct dentry *de = NULL;
+
+	de = debugfs_create_dir("hsr", NULL);
+	if (!de) {
+		netdev_err(hsr_prp_dev, "Cannot create hsr-prp debugfs root\n");
+		return rc;
+	}
+
+	priv->node_tbl_root = de;
+
+	de = debugfs_create_file("node_table", S_IFREG | S_IRUGO,
+				 priv->node_tbl_root, priv,
+				 &hsr_prp_fops);
+	if (!de) {
+		netdev_err(hsr_prp_dev,
+			   "Cannot create hsr-prp node_table directory\n");
+		return rc;
+	}
+	priv->node_tbl_file = de;
+	rc = 0;
+
+	return rc;
+} /* end of hst_prp_debugfs_init */
+
+/* hsr_prp_debugfs_term - Tear down debugfs intrastructure
+ *
+ * Description:
+ * When Debufs is configured this routine removes debugfs file system
+ * elements that are specific to hsr-prp
+ */
+void
+hsr_prp_debugfs_term(struct hsr_prp_priv *priv)
+{
+	debugfs_remove(priv->node_tbl_file);
+	priv->node_tbl_file = NULL;
+	debugfs_remove(priv->node_tbl_root);
+	priv->node_tbl_root = NULL;
+}
diff --git a/net/hsr-prp/hsr_prp_device.c b/net/hsr-prp/hsr_prp_device.c
new file mode 100644
index 0000000..3b864a9
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_device.c
@@ -0,0 +1,543 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ *
+ * This file contains device methods for creating, using and destroying
+ * virtual HSR devices.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/pkt_sched.h>
+#include "hsr_prp_device.h"
+#include "hsr_prp_slave.h"
+#include "hsr_prp_framereg.h"
+#include "hsr_prp_main.h"
+#include "hsr_prp_forward.h"
+
+static bool is_admin_up(struct net_device *dev)
+{
+	return dev && (dev->flags & IFF_UP);
+}
+
+static bool is_slave_up(struct net_device *dev)
+{
+	return dev && is_admin_up(dev) && netif_oper_up(dev);
+}
+
+static void __set_operstate(struct net_device *dev, int transition)
+{
+	write_lock_bh(&dev_base_lock);
+	if (dev->operstate != transition) {
+		dev->operstate = transition;
+		write_unlock_bh(&dev_base_lock);
+		netdev_state_change(dev);
+	} else {
+		write_unlock_bh(&dev_base_lock);
+	}
+}
+
+static void set_operstate(struct hsr_prp_port *master, bool has_carrier)
+{
+	if (!is_admin_up(master->dev)) {
+		__set_operstate(master->dev, IF_OPER_DOWN);
+		return;
+	}
+
+	if (has_carrier)
+		__set_operstate(master->dev, IF_OPER_UP);
+	else
+		__set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);
+}
+
+static bool hsr_prp_check_carrier(struct hsr_prp_port *master)
+{
+	struct hsr_prp_port *port;
+	bool has_carrier;
+
+	has_carrier = false;
+
+	rcu_read_lock();
+	hsr_prp_for_each_port(master->priv, port)
+		if ((port->type != HSR_PRP_PT_MASTER) &&
+		    is_slave_up(port->dev)) {
+			has_carrier = true;
+			break;
+		}
+	rcu_read_unlock();
+
+	if (has_carrier)
+		netif_carrier_on(master->dev);
+	else
+		netif_carrier_off(master->dev);
+
+	return has_carrier;
+}
+
+static void hsr_prp_check_announce(struct net_device *hsr_dev,
+				   unsigned char old_operstate)
+{
+	struct hsr_prp_priv *priv;
+
+	priv = netdev_priv(hsr_dev);
+
+	if ((hsr_dev->operstate == IF_OPER_UP) &&
+	    (old_operstate != IF_OPER_UP)) {
+		/* Went up */
+		priv->announce_count = 0;
+		priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_PRP_ANNOUNCE_INTERVAL);
+		add_timer(&priv->announce_timer);
+	}
+
+	if ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))
+		/* Went down */
+		del_timer(&priv->announce_timer);
+}
+
+void hsr_prp_check_carrier_and_operstate(struct hsr_prp_priv *priv)
+{
+	struct hsr_prp_port *master;
+	unsigned char old_operstate;
+	bool has_carrier;
+
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+	/* netif_stacked_transfer_operstate() cannot be used here since
+	 * it doesn't set IF_OPER_LOWERLAYERDOWN (?)
+	 */
+	old_operstate = master->dev->operstate;
+	has_carrier = hsr_prp_check_carrier(master);
+	set_operstate(master, has_carrier);
+	hsr_prp_check_announce(master->dev, old_operstate);
+}
+
+int hsr_prp_get_max_mtu(struct hsr_prp_priv *priv)
+{
+	unsigned int mtu_max;
+	struct hsr_prp_port *port;
+
+	mtu_max = ETH_DATA_LEN;
+	rcu_read_lock();
+	hsr_prp_for_each_port(priv, port)
+		if (port->type != HSR_PRP_PT_MASTER)
+			mtu_max = min(port->dev->mtu, mtu_max);
+	rcu_read_unlock();
+
+	if (mtu_max < HSR_PRP_HLEN)
+		return 0;
+	return mtu_max - HSR_PRP_HLEN;
+}
+
+static int hsr_prp_dev_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *master;
+	int max;
+
+	priv = netdev_priv(dev);
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+	max = hsr_prp_get_max_mtu(priv);
+	if (new_mtu > max) {
+		netdev_info(master->dev,
+			    "HSR/PRP: Invalid MTU, expected (<= %d), Got %d.\n",
+			    max, new_mtu);
+		return -EINVAL;
+	}
+
+	dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static int hsr_prp_dev_open(struct net_device *dev)
+{
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
+	char designation;
+
+	priv = netdev_priv(dev);
+	designation = '\0';
+
+	rcu_read_lock();
+	hsr_prp_for_each_port(priv, port) {
+		if (port->type == HSR_PRP_PT_MASTER)
+			continue;
+		switch (port->type) {
+		case HSR_PRP_PT_SLAVE_A:
+			designation = 'A';
+			break;
+		case HSR_PRP_PT_SLAVE_B:
+			designation = 'B';
+			break;
+		default:
+			designation = '?';
+		}
+		if (!is_slave_up(port->dev))
+			netdev_warn(dev,
+				    "HSR/PRP: Please bringup Slave %c (%s)\n",
+				    designation, port->dev->name);
+	}
+	rcu_read_unlock();
+
+	if (designation == '\0')
+		netdev_warn(dev, "No slave devices configured\n");
+
+	return 0;
+}
+
+static int hsr_prp_dev_close(struct net_device *dev)
+{
+	/* Nothing to do here. */
+	return 0;
+}
+
+static netdev_features_t hsr_prp_features_recompute(struct hsr_prp_priv *priv,
+						    netdev_features_t features)
+{
+	netdev_features_t mask;
+	struct hsr_prp_port *port;
+
+	mask = features;
+
+	/* Mask out all features that, if supported by one device, should be
+	 * enabled for all devices (see NETIF_F_ONE_FOR_ALL).
+	 *
+	 * Anything that's off in mask will not be enabled - so only things
+	 * that were in features originally, and also is in NETIF_F_ONE_FOR_ALL,
+	 * may become enabled.
+	 */
+	features &= ~NETIF_F_ONE_FOR_ALL;
+	hsr_prp_for_each_port(priv, port)
+		features = netdev_increment_features(features,
+						     port->dev->features,
+						     mask);
+
+	return features;
+}
+
+static netdev_features_t hsr_prp_fix_features(struct net_device *dev,
+					      netdev_features_t features)
+{
+	struct hsr_prp_priv *priv = netdev_priv(dev);
+
+	return hsr_prp_features_recompute(priv, features);
+}
+
+static int hsr_prp_dev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct hsr_prp_priv *priv = netdev_priv(dev);
+	struct hsr_prp_port *master;
+
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+	skb->dev = master->dev;
+	hsr_prp_forward_skb(skb, master);
+	master->dev->stats.tx_packets++;
+	master->dev->stats.tx_bytes += skb->len;
+
+	return NETDEV_TX_OK;
+}
+
+static const struct header_ops hsr_prp_header_ops = {
+	.create	 = eth_header,
+	.parse	 = eth_header_parse,
+};
+
+static void send_supervision_frame(struct hsr_prp_port *master,
+				   u8 type, u8 prot_ver)
+{
+	struct sk_buff *skb;
+	int hlen, tlen;
+	struct hsr_tag *hsr_tag;
+	struct hsr_prp_sup_tag *hsr_stag;
+	struct hsr_prp_sup_payload *hsr_sp;
+	unsigned long irqflags;
+
+	hlen = LL_RESERVED_SPACE(master->dev);
+	tlen = master->dev->needed_tailroom;
+	skb = dev_alloc_skb(
+			sizeof(struct hsr_tag) +
+			sizeof(struct hsr_prp_sup_tag) +
+			sizeof(struct hsr_prp_sup_payload) + hlen + tlen);
+	if (!skb)
+		return;
+
+	skb_reserve(skb, hlen);
+
+	skb->dev = master->dev;
+	skb->protocol = htons(prot_ver ? ETH_P_HSR : ETH_P_PRP);
+	skb->priority = TC_PRIO_CONTROL;
+
+	if (dev_hard_header(skb, skb->dev, (prot_ver ? ETH_P_HSR : ETH_P_PRP),
+			    master->priv->sup_multicast_addr,
+			    skb->dev->dev_addr, skb->len) <= 0)
+		goto out;
+
+	skb_reset_mac_header(skb);
+	if (prot_ver > 0) {
+		hsr_tag = (typeof(hsr_tag))skb_put(skb,
+						   sizeof(struct hsr_tag));
+		hsr_tag->encap_proto = htons(ETH_P_PRP);
+		set_hsr_tag_LSDU_size(hsr_tag, HSR_V1_SUP_LSDUSIZE);
+	}
+
+	hsr_stag = (typeof(hsr_stag))skb_put(skb,
+					     sizeof(struct hsr_prp_sup_tag));
+	set_hsr_stag_path(hsr_stag, (prot_ver ? 0x0 : 0xf));
+	set_hsr_stag_HSR_ver(hsr_stag, prot_ver);
+
+	/* From HSRv1 on we have separate supervision sequence numbers. */
+	spin_lock_irqsave(&master->priv->seqnr_lock, irqflags);
+	if (prot_ver > 0) {
+		hsr_stag->sequence_nr = htons(master->priv->sup_sequence_nr);
+		hsr_tag->sequence_nr = htons(master->priv->sequence_nr);
+		master->priv->sup_sequence_nr++;
+		master->priv->sequence_nr++;
+	} else {
+		hsr_stag->sequence_nr = htons(master->priv->sequence_nr);
+		master->priv->sequence_nr++;
+	}
+	spin_unlock_irqrestore(&master->priv->seqnr_lock, irqflags);
+
+	hsr_stag->HSR_TLV_type = type;
+	/* TODO: Why 12 in HSRv0? */
+	hsr_stag->HSR_TLV_length =
+		prot_ver ? sizeof(struct hsr_prp_sup_payload) : 12;
+
+	/* Payload: mac_address_a */
+	hsr_sp = (typeof(hsr_sp))skb_put(skb,
+					 sizeof(struct hsr_prp_sup_payload));
+	ether_addr_copy(hsr_sp->mac_address_a, master->dev->dev_addr);
+	skb_put_padto(skb, ETH_ZLEN + HSR_PRP_HLEN);
+
+	hsr_prp_forward_skb(skb, master);
+	return;
+
+out:
+	WARN_ONCE(1, "HSR: Could not send supervision frame\n");
+	kfree_skb(skb);
+}
+
+/* Announce (supervision frame) timer function
+ */
+static void hsr_prp_announce(unsigned long data)
+{
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *master;
+
+	priv = (struct hsr_prp_priv *)data;
+
+	rcu_read_lock();
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+
+	if (priv->announce_count < 3 && priv->prot_version == 0) {
+		send_supervision_frame(master, HSR_TLV_ANNOUNCE,
+				       priv->prot_version);
+		priv->announce_count++;
+
+		priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_PRP_ANNOUNCE_INTERVAL);
+	} else {
+		send_supervision_frame(master, HSR_TLV_LIFE_CHECK,
+				       priv->prot_version);
+
+		priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_PRP_LIFE_CHECK_INTERVAL);
+	}
+
+	if (is_admin_up(master->dev))
+		add_timer(&priv->announce_timer);
+
+	rcu_read_unlock();
+}
+
+/* According to comments in the declaration of struct net_device, this function
+ * is "Called from unregister, can be used to call free_netdev". Ok then...
+ */
+static void hsr_prp_dev_destroy(struct net_device *hsr_prp_dev)
+{
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
+
+	priv = netdev_priv(hsr_prp_dev);
+
+	hsr_prp_debugfs_term(priv);
+
+	rtnl_lock();
+	hsr_prp_for_each_port(priv, port)
+		hsr_prp_del_port(port);
+	rtnl_unlock();
+
+	del_timer_sync(&priv->prune_timer);
+	del_timer_sync(&priv->announce_timer);
+
+	synchronize_rcu();
+	free_netdev(hsr_prp_dev);
+}
+
+static const struct net_device_ops hsr_prp_device_ops = {
+	.ndo_change_mtu = hsr_prp_dev_change_mtu,
+	.ndo_open = hsr_prp_dev_open,
+	.ndo_stop = hsr_prp_dev_close,
+	.ndo_start_xmit = hsr_prp_dev_xmit,
+	.ndo_fix_features = hsr_prp_fix_features,
+};
+
+static struct device_type hsr_type = {
+	.name = "hsr",
+};
+
+void hsr_prp_dev_setup(struct net_device *ndev)
+{
+	random_ether_addr(ndev->dev_addr);
+
+	ether_setup(ndev);
+	ndev->header_ops = &hsr_prp_header_ops;
+	ndev->netdev_ops = &hsr_prp_device_ops;
+	SET_NETDEV_DEVTYPE(ndev, &hsr_type);
+	ndev->priv_flags |= IFF_NO_QUEUE;
+
+	ndev->destructor = hsr_prp_dev_destroy;
+
+	ndev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+			   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |
+			   NETIF_F_HW_VLAN_CTAG_TX;
+
+	ndev->features = ndev->hw_features;
+
+	/* Prevent recursive tx locking */
+	ndev->features |= NETIF_F_LLTX;
+	/* VLAN on top of HSR needs testing and probably some work on
+	 * hsr_header_create() etc.
+	 */
+	ndev->features |= NETIF_F_VLAN_CHALLENGED;
+	/* Not sure about this. Taken from bridge code. netdev_features.h says
+	 * it means "Does not change network namespaces".
+	 */
+	ndev->features |= NETIF_F_NETNS_LOCAL;
+}
+
+/* Return true if dev is a HSR master; return false otherwise.
+ */
+inline bool is_hsr_prp_master(struct net_device *dev)
+{
+	return (dev->netdev_ops->ndo_start_xmit == hsr_prp_dev_xmit);
+}
+
+/* Default multicast address for HSR Supervision frames */
+static const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {
+	0x01, 0x15, 0x4e, 0x00, 0x01, 0x00
+};
+
+int hsr_prp_dev_finalize(struct net_device *hsr_prp_dev,
+			 struct net_device *slave[2],
+			 unsigned char multicast_spec, u8 protocol_version)
+{
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *port;
+	int res;
+
+	priv = netdev_priv(hsr_prp_dev);
+	INIT_LIST_HEAD(&priv->ports);
+	INIT_LIST_HEAD(&priv->node_db);
+	INIT_LIST_HEAD(&priv->self_node_db);
+
+	ether_addr_copy(hsr_prp_dev->dev_addr, slave[0]->dev_addr);
+
+	/* Make sure we recognize frames from ourselves in
+	 * hsr_rcv() or frame is addressed to me
+	 */
+	res = hsr_prp_create_self_node(&priv->self_node_db,
+				       hsr_prp_dev->dev_addr,
+				       slave[1]->dev_addr);
+	if (res < 0)
+		return res;
+
+	spin_lock_init(&priv->seqnr_lock);
+	/* Overflow soon to find bugs easier: */
+	priv->sequence_nr = HSR_PRP_SEQNR_START;
+	priv->sup_sequence_nr = HSR_PRP_SUP_SEQNR_START;
+
+	setup_timer(&priv->announce_timer, hsr_prp_announce,
+		    (unsigned long)priv);
+
+	if (!priv->rx_offloaded)
+		setup_timer(&priv->prune_timer, hsr_prp_prune_nodes,
+			    (unsigned long)priv);
+
+	ether_addr_copy(priv->sup_multicast_addr, def_multicast_addr);
+	priv->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
+
+	priv->prot_version = protocol_version;
+
+	/* FIXME: should I modify the value of these?
+	 *
+	 * - hsr_dev->flags - i.e.
+	 *			IFF_MASTER/SLAVE?
+	 * - hsr_dev->priv_flags - i.e.
+	 *			IFF_EBRIDGE?
+	 *			IFF_TX_SKB_SHARING?
+	 *			IFF_HSR_MASTER/SLAVE?
+	 */
+
+	/* Make sure the 1st call to netif_carrier_on() gets through */
+	netif_carrier_off(hsr_prp_dev);
+
+	res = hsr_prp_add_port(priv, hsr_prp_dev, HSR_PRP_PT_MASTER);
+	if (res)
+		return res;
+
+	/* HSR LRE Rx offload supported in lower device? */
+	if ((slave[0]->features & NETIF_F_HW_HSR_RX_OFFLOAD) &&
+	    (slave[1]->features & NETIF_F_HW_HSR_RX_OFFLOAD))
+		priv->rx_offloaded = true;
+
+	/* HSR LRE L2 forward offload supported in lower device? */
+	if ((slave[0]->features & NETIF_F_HW_L2FW_DOFFLOAD) &&
+	    (slave[1]->features & NETIF_F_HW_L2FW_DOFFLOAD))
+		priv->l2_fwd_offloaded = true;
+
+	res = register_netdevice(hsr_prp_dev);
+	if (res)
+		goto fail;
+
+	res = hsr_prp_add_port(priv, slave[0], HSR_PRP_PT_SLAVE_A);
+	if (res)
+		goto fail;
+	res = hsr_prp_add_port(priv, slave[1], HSR_PRP_PT_SLAVE_B);
+	if (res)
+		goto fail;
+
+	/* For LRE rx offload, pruning is expected to happen
+	 * at the hardware or firmware . So don't do this in software
+	 */
+	if (!priv->rx_offloaded)
+		mod_timer(&priv->prune_timer,
+			  jiffies + msecs_to_jiffies(HSR_PRP_PRUNE_PERIOD));
+	/* for offloaded case, expect both slaves have the
+	 * same MAC address configured. If not fail.
+	 */
+	if (priv->rx_offloaded &&
+	    !ether_addr_equal(slave[0]->dev_addr,
+			      slave[1]->dev_addr))
+		goto fail;
+
+	res = hsr_prp_debugfs_init(priv, hsr_prp_dev);
+	if (res)
+		goto fail;
+
+	return 0;
+
+fail:
+	hsr_prp_for_each_port(priv, port)
+		hsr_prp_del_port(port);
+
+	return res;
+}
diff --git a/net/hsr-prp/hsr_prp_device.h b/net/hsr-prp/hsr_prp_device.h
new file mode 100644
index 0000000..2ede0f4
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_device.h
@@ -0,0 +1,25 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#ifndef __HSR_PRP_DEVICE_H
+#define __HSR_PRP_DEVICE_H
+
+#include <linux/netdevice.h>
+#include "hsr_prp_main.h"
+
+void hsr_prp_dev_setup(struct net_device *dev);
+int hsr_prp_dev_finalize(struct net_device *dev, struct net_device *slave[2],
+			 unsigned char multicast_spec, u8 protocol_version);
+void hsr_prp_check_carrier_and_operstate(struct hsr_prp_priv *priv);
+bool is_hsr_prp_master(struct net_device *dev);
+int hsr_prp_get_max_mtu(struct hsr_prp_priv *priv);
+
+#endif /* __HSR_PRP_DEVICE_H */
diff --git a/net/hsr-prp/hsr_prp_forward.c b/net/hsr-prp/hsr_prp_forward.c
new file mode 100644
index 0000000..9b061f8
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_forward.c
@@ -0,0 +1,431 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#include "hsr_prp_forward.h"
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include "hsr_prp_main.h"
+#include "hsr_prp_framereg.h"
+
+struct hsr_prp_node;
+
+struct hsr_prp_frame_info {
+	struct sk_buff *skb_std;
+	struct sk_buff *skb_hsr;
+	struct hsr_prp_port *port_rcv;
+	struct hsr_prp_node *node_src;
+	u16 sequence_nr;
+	bool is_supervision;
+	bool is_vlan;
+	bool is_local_dest;
+	bool is_local_exclusive;
+};
+
+/* The uses I can see for these HSR supervision frames are:
+ * 1) Use the frames that are sent after node initialization ("HSR_TLV.Type =
+ *    22") to reset any sequence_nr counters belonging to that node. Useful if
+ *    the other node's counter has been reset for some reason.
+ *    --
+ *    Or not - resetting the counter and bridging the frame would create a
+ *    loop, unfortunately.
+ *
+ * 2) Use the LifeCheck frames to detect ring breaks. I.e. if no LifeCheck
+ *    frame is received from a particular node, we know something is wrong.
+ *    We just register these (as with normal frames) and throw them away.
+ *
+ * 3) Allow different MAC addresses for the two slave interfaces, using the
+ *    MacAddressA field.
+ */
+static bool is_supervision_frame(struct hsr_prp_priv *priv, struct sk_buff *skb)
+{
+	struct ethhdr *eth_hdr;
+	struct hsr_prp_sup_tag *hsr_sup_tag;
+	struct hsrv1_ethhdr_sp *hsr_v1_hdr;
+
+	WARN_ON_ONCE(!skb_mac_header_was_set(skb));
+	eth_hdr = (struct ethhdr *)skb_mac_header(skb);
+
+	/* Correct addr? */
+	if (!ether_addr_equal(eth_hdr->h_dest,
+			      priv->sup_multicast_addr))
+		return false;
+
+	/* Correct ether type?. */
+	if (!(eth_hdr->h_proto == htons(ETH_P_PRP) ||
+	      eth_hdr->h_proto == htons(ETH_P_HSR)))
+		return false;
+
+	/* Get the supervision header from correct location. */
+	if (eth_hdr->h_proto == htons(ETH_P_HSR)) { /* Okay HSRv1. */
+		hsr_v1_hdr = (struct hsrv1_ethhdr_sp *)skb_mac_header(skb);
+		if (hsr_v1_hdr->hsr.encap_proto != htons(ETH_P_PRP))
+			return false;
+
+		hsr_sup_tag = &hsr_v1_hdr->hsr_sup;
+	} else {
+		hsr_sup_tag = &((struct hsrv0_ethhdr_sp *)
+				skb_mac_header(skb))->hsr_sup;
+	}
+
+	if ((hsr_sup_tag->HSR_TLV_type != HSR_TLV_ANNOUNCE) &&
+	    (hsr_sup_tag->HSR_TLV_type != HSR_TLV_LIFE_CHECK))
+		return false;
+
+	if ((hsr_sup_tag->HSR_TLV_length != 12) &&
+	    (hsr_sup_tag->HSR_TLV_length != sizeof(struct hsr_prp_sup_payload)))
+		return false;
+
+	return true;
+}
+
+static struct sk_buff *create_stripped_skb(struct sk_buff *skb_in,
+					   struct hsr_prp_frame_info *frame)
+{
+	struct sk_buff *skb;
+	int copylen;
+	unsigned char *dst, *src;
+
+	skb_pull(skb_in, HSR_PRP_HLEN);
+	skb = __pskb_copy(skb_in,
+			  skb_headroom(skb_in) - HSR_PRP_HLEN, GFP_ATOMIC);
+	skb_push(skb_in, HSR_PRP_HLEN);
+	if (!skb)
+		return NULL;
+
+	skb_reset_mac_header(skb);
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL)
+		skb->csum_start -= HSR_PRP_HLEN;
+
+	copylen = 2 * ETH_ALEN;
+	if (frame->is_vlan)
+		copylen += VLAN_HLEN;
+	src = skb_mac_header(skb_in);
+	dst = skb_mac_header(skb);
+	memcpy(dst, src, copylen);
+
+	skb->protocol = eth_hdr(skb)->h_proto;
+	return skb;
+}
+
+static struct sk_buff *frame_get_stripped_skb(struct hsr_prp_frame_info *frame,
+					      struct hsr_prp_port *port)
+{
+	if (!frame->skb_std)
+		frame->skb_std = create_stripped_skb(frame->skb_hsr, frame);
+	return skb_clone(frame->skb_std, GFP_ATOMIC);
+}
+
+static void hsr_fill_tag(struct sk_buff *skb, struct hsr_prp_frame_info *frame,
+			 struct hsr_prp_port *port, u8 proto_version)
+{
+	struct hsr_ethhdr *hsr_ethhdr;
+	int lane_id;
+	int lsdu_size;
+
+	if (port->type == HSR_PRP_PT_SLAVE_A)
+		lane_id = 0;
+	else
+		lane_id = 1;
+
+	lsdu_size = skb->len - 14;
+	if (frame->is_vlan)
+		lsdu_size -= 4;
+
+	hsr_ethhdr = (struct hsr_ethhdr *)skb_mac_header(skb);
+
+	set_hsr_tag_path(&hsr_ethhdr->hsr_tag, lane_id);
+	set_hsr_tag_LSDU_size(&hsr_ethhdr->hsr_tag, lsdu_size);
+	hsr_ethhdr->hsr_tag.sequence_nr = htons(frame->sequence_nr);
+	hsr_ethhdr->hsr_tag.encap_proto = hsr_ethhdr->ethhdr.h_proto;
+	hsr_ethhdr->ethhdr.h_proto = htons(proto_version ?
+			ETH_P_HSR : ETH_P_PRP);
+}
+
+static struct sk_buff *create_tagged_skb(struct sk_buff *skb_o,
+					 struct hsr_prp_frame_info *frame,
+					 struct hsr_prp_port *port)
+{
+	int movelen;
+	unsigned char *dst, *src;
+	struct sk_buff *skb;
+
+	/* Create the new skb with enough headroom to fit the HSR tag */
+	skb = __pskb_copy(skb_o, skb_headroom(skb_o) + HSR_PRP_HLEN,
+			  GFP_ATOMIC);
+	if (!skb)
+		return NULL;
+	skb_reset_mac_header(skb);
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL)
+		skb->csum_start += HSR_PRP_HLEN;
+
+	movelen = ETH_HLEN;
+	if (frame->is_vlan)
+		movelen += VLAN_HLEN;
+
+	src = skb_mac_header(skb);
+	dst = skb_push(skb, HSR_PRP_HLEN);
+	memmove(dst, src, movelen);
+	skb_reset_mac_header(skb);
+
+	hsr_fill_tag(skb, frame, port, port->priv->prot_version);
+
+	return skb;
+}
+
+/* If the original frame was an HSR tagged frame, just clone it to be sent
+ * unchanged. Otherwise, create a private frame especially tagged for 'port'.
+ */
+static struct sk_buff *frame_get_tagged_skb(struct hsr_prp_frame_info *frame,
+					    struct hsr_prp_port *port)
+{
+	if (frame->skb_hsr)
+		return skb_clone(frame->skb_hsr, GFP_ATOMIC);
+
+	if ((port->type != HSR_PRP_PT_SLAVE_A) &&
+	    (port->type != HSR_PRP_PT_SLAVE_B)) {
+		WARN_ONCE(1,
+			  "Bug: creating a tagged frame for a non slave port");
+		return NULL;
+	}
+
+	return create_tagged_skb(frame->skb_std, frame, port);
+}
+
+static void hsr_prp_deliver_master(struct sk_buff *skb,
+				   struct hsr_prp_node *node_src,
+				   struct hsr_prp_port *port)
+{
+	struct net_device *dev = port->dev;
+	bool was_multicast_frame;
+	int res;
+
+	was_multicast_frame = (skb->pkt_type == PACKET_MULTICAST);
+	/* For LRE offloaded case, assume same MAC address is on both
+	 * interfaces of the remote node and hence no need to substitute
+	 * the source MAC address.
+	 */
+	if (!port->priv->rx_offloaded)
+		hsr_addr_subst_source(node_src, skb);
+
+	skb_pull(skb, ETH_HLEN);
+	res = netif_rx(skb);
+	if (res == NET_RX_DROP) {
+		dev->stats.rx_dropped++;
+	} else {
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += skb->len;
+		if (was_multicast_frame)
+			dev->stats.multicast++;
+	}
+}
+
+static int hsr_prp_xmit(struct sk_buff *skb, struct hsr_prp_port *port,
+			struct hsr_prp_frame_info *frame)
+{
+	if (!port->priv->rx_offloaded &&
+	    frame->port_rcv->type == HSR_PRP_PT_MASTER) {
+		hsr_addr_subst_dest(frame->node_src, skb, port);
+
+		/* Address substitution (IEC62439-3 pp 26, 50): replace mac
+		 * address of outgoing frame with that of the outgoing slave's.
+		 */
+		ether_addr_copy(eth_hdr(skb)->h_source, port->dev->dev_addr);
+	}
+	return dev_queue_xmit(skb);
+}
+
+/* Forward the frame through all devices except:
+ * - Back through the receiving device
+ * - If it's a HSR frame: through a device where it has passed before
+ * - To the local HSR master only if the frame is directly addressed to it, or
+ *   a non-supervision multicast or broadcast frame.
+ *
+ * HSR slave devices should insert a HSR tag into the frame, or forward the
+ * frame unchanged if it's already tagged. Interlink devices should strip HSR
+ * tags if they're of the non-HSR type (but only after duplicate discard). The
+ * master device always strips HSR tags.
+ */
+static void hsr_prp_forward_do(struct hsr_prp_frame_info *frame)
+{
+	struct hsr_prp_port *port;
+	struct sk_buff *skb;
+
+	hsr_prp_for_each_port(frame->port_rcv->priv, port) {
+		/* Don't send frame back the way it came */
+		if (port == frame->port_rcv)
+			continue;
+
+		/* Don't deliver locally unless we should */
+		if ((port->type == HSR_PRP_PT_MASTER) && !frame->is_local_dest)
+			continue;
+
+		/* Deliver frames directly addressed to us to master only */
+		if ((port->type != HSR_PRP_PT_MASTER) &&
+		    frame->is_local_exclusive)
+			continue;
+
+		/* Don't send frame over port where it has been sent before
+		 * if not rx offloaded
+		 */
+		if (!port->priv->rx_offloaded &&
+		    hsr_register_frame_out(port, frame->node_src,
+					   frame->sequence_nr))
+			continue;
+
+		/* In LRE offloaded case, don't expect supervision frames from
+		 * slave ports for host as they get processed at the h/w or
+		 * firmware
+		 */
+		if (frame->is_supervision &&
+		    (port->type == HSR_PRP_PT_MASTER) &&
+		    (!port->priv->rx_offloaded)) {
+			hsr_prp_handle_sup_frame(frame->skb_hsr,
+						 frame->node_src,
+						 frame->port_rcv);
+			continue;
+		}
+
+		/* if L2 forward is offloaded, don't forward frame
+		 * across slaves
+		 */
+		if (port->priv->l2_fwd_offloaded &&
+		    (((frame->port_rcv->type == HSR_PRP_PT_SLAVE_A) &&
+		    (port->type ==  HSR_PRP_PT_SLAVE_B)) ||
+		    ((frame->port_rcv->type == HSR_PRP_PT_SLAVE_B) &&
+		    (port->type ==  HSR_PRP_PT_SLAVE_A))))
+			continue;
+
+		if (port->type != HSR_PRP_PT_MASTER)
+			skb = frame_get_tagged_skb(frame, port);
+		else
+			skb = frame_get_stripped_skb(frame, port);
+
+		/* FIXME: Record the dropped frame? */
+		if (!skb)
+			continue;
+
+		skb->dev = port->dev;
+		if (port->type == HSR_PRP_PT_MASTER)
+			hsr_prp_deliver_master(skb, frame->node_src, port);
+		else
+			hsr_prp_xmit(skb, port, frame);
+	}
+}
+
+static void check_local_dest(struct hsr_prp_priv *priv, struct sk_buff *skb,
+			     struct hsr_prp_frame_info *frame)
+{
+	if (hsr_prp_addr_is_self(priv, eth_hdr(skb)->h_dest)) {
+		frame->is_local_exclusive = true;
+		skb->pkt_type = PACKET_HOST;
+	} else {
+		frame->is_local_exclusive = false;
+	}
+
+	if ((skb->pkt_type == PACKET_HOST) ||
+	    (skb->pkt_type == PACKET_MULTICAST) ||
+	    (skb->pkt_type == PACKET_BROADCAST)) {
+		frame->is_local_dest = true;
+	} else {
+		frame->is_local_dest = false;
+	}
+}
+
+static int hsr_prp_fill_frame_info(struct hsr_prp_frame_info *frame,
+				   struct sk_buff *skb,
+				   struct hsr_prp_port *port)
+{
+	struct ethhdr *ethhdr;
+	unsigned long irqflags;
+	struct hsr_prp_priv *priv = port->priv;
+
+	frame->is_supervision = is_supervision_frame(priv, skb);
+	if (frame->is_supervision && priv->rx_offloaded &&
+	    (port->type != HSR_PRP_PT_MASTER)) {
+		WARN_ONCE(1,
+			  "HSR: unexpected rx supervisor frame when offloaded");
+		return -1;
+	}
+
+	/* For Offloaded case, there is no need for node list since
+	 * firmware/hardware implements LRE function.
+	 */
+	if (!priv->rx_offloaded) {
+		frame->node_src = hsr_prp_get_node(&priv->node_db, skb,
+						   frame->is_supervision);
+		/* Unknown node and !is_supervision, or no mem */
+		if (!frame->node_src) {
+			WARN_ONCE(1, "Unknown frame received\n");
+			return -1;
+		}
+	}
+
+	ethhdr = (struct ethhdr *)skb_mac_header(skb);
+	frame->is_vlan = false;
+	if (ethhdr->h_proto == htons(ETH_P_8021Q)) {
+		frame->is_vlan = true;
+		/* FIXME: */
+		WARN_ONCE(1, "HSR: VLAN not yet supported");
+	}
+	if (ethhdr->h_proto == htons(ETH_P_PRP) ||
+	    ethhdr->h_proto == htons(ETH_P_HSR)) {
+		frame->skb_std = NULL;
+		frame->skb_hsr = skb;
+		frame->sequence_nr = hsr_get_skb_sequence_nr(skb);
+	} else {
+		frame->skb_std = skb;
+		frame->skb_hsr = NULL;
+		/* Sequence nr for the master node */
+		spin_lock_irqsave(&priv->seqnr_lock, irqflags);
+		frame->sequence_nr = priv->sequence_nr;
+		priv->sequence_nr++;
+		spin_unlock_irqrestore(&priv->seqnr_lock, irqflags);
+	}
+
+	frame->port_rcv = port;
+	check_local_dest(priv, skb, frame);
+
+	return 0;
+}
+
+/* Must be called holding rcu read lock (because of the port parameter) */
+void hsr_prp_forward_skb(struct sk_buff *skb, struct hsr_prp_port *port)
+{
+	struct hsr_prp_frame_info frame;
+
+	if (skb_mac_header(skb) != skb->data) {
+		WARN_ONCE(1, "%s:%d: Malformed frame (port_src %s)\n",
+			  __FILE__, __LINE__, port->dev->name);
+		goto out_drop;
+	}
+
+	if (hsr_prp_fill_frame_info(&frame, skb, port) < 0)
+		goto out_drop;
+	/* No need to register frame when rx offload is supported */
+	if (!port->priv->rx_offloaded)
+		hsr_register_frame_in(frame.node_src, port, frame.sequence_nr);
+
+	hsr_prp_forward_do(&frame);
+
+	if (frame.skb_hsr)
+		kfree_skb(frame.skb_hsr);
+	if (frame.skb_std)
+		kfree_skb(frame.skb_std);
+	return;
+
+out_drop:
+	port->dev->stats.tx_dropped++;
+	kfree_skb(skb);
+}
diff --git a/net/hsr-prp/hsr_prp_forward.h b/net/hsr-prp/hsr_prp_forward.h
new file mode 100644
index 0000000..f938d35
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_forward.h
@@ -0,0 +1,20 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#ifndef __HSR_PRP_FORWARD_H
+#define __HSR_PRP_FORWARD_H
+
+#include <linux/netdevice.h>
+#include "hsr_prp_main.h"
+
+void hsr_prp_forward_skb(struct sk_buff *skb, struct hsr_prp_port *port);
+
+#endif /* __HSR_PRP_FORWARD_H */
diff --git a/net/hsr-prp/hsr_prp_framereg.c b/net/hsr-prp/hsr_prp_framereg.c
new file mode 100644
index 0000000..381b21b
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_framereg.c
@@ -0,0 +1,481 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ *
+ * The HSR spec says never to forward the same frame twice on the same
+ * interface. A frame is identified by its source MAC address and its HSR
+ * sequence number. This code keeps track of senders and their sequence numbers
+ * to allow filtering of duplicate frames, and to detect HSR ring errors.
+ */
+
+#include <linux/if_ether.h>
+#include <linux/etherdevice.h>
+#include <linux/slab.h>
+#include <linux/rculist.h>
+#include "hsr_prp_main.h"
+#include "hsr_prp_framereg.h"
+#include "hsr_netlink.h"
+
+/*	TODO: use hash lists for mac addresses (linux/jhash.h)?    */
+
+/* seq_nr_after(a, b) - return true if a is after (higher in sequence than) b,
+ * false otherwise.
+ */
+static bool seq_nr_after(u16 a, u16 b)
+{
+	/* Remove inconsistency where
+	 * seq_nr_after(a, b) == seq_nr_before(a, b)
+	 */
+	if ((int)b - a == 32768)
+		return false;
+
+	return (((s16)(b - a)) < 0);
+}
+
+#define seq_nr_before(a, b)		seq_nr_after((b), (a))
+#define seq_nr_after_or_eq(a, b)	(!seq_nr_before((a), (b)))
+#define seq_nr_before_or_eq(a, b)	(!seq_nr_after((a), (b)))
+
+bool hsr_prp_addr_is_self(struct hsr_prp_priv *priv, unsigned char *addr)
+{
+	struct hsr_prp_node *node;
+
+	node = list_first_or_null_rcu(&priv->self_node_db, struct hsr_prp_node,
+				      mac_list);
+	if (!node) {
+		WARN_ONCE(1, "HSR: No self node\n");
+		return false;
+	}
+
+	if (ether_addr_equal(addr, node->mac_address_a))
+		return true;
+	if (ether_addr_equal(addr, node->mac_address_b))
+		return true;
+
+	return false;
+}
+
+/* Search for mac entry. Caller must hold rcu read lock.
+ */
+static struct hsr_prp_node *
+find_node_by_addr_a(struct list_head *node_db,
+		    const unsigned char addr[ETH_ALEN])
+{
+	struct hsr_prp_node *node;
+
+	list_for_each_entry_rcu(node, node_db, mac_list) {
+		if (ether_addr_equal(node->mac_address_a, addr))
+			return node;
+	}
+
+	return NULL;
+}
+
+/* Helper for device init; the self_node_db is used in hsr_rcv() to recognize
+ * frames from self that's been looped over the HSR ring.
+ */
+int hsr_prp_create_self_node(struct list_head *self_node_db,
+			     unsigned char addr_a[ETH_ALEN],
+			     unsigned char addr_b[ETH_ALEN])
+{
+	struct hsr_prp_node *node, *oldnode;
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	if (!node)
+		return -ENOMEM;
+
+	ether_addr_copy(node->mac_address_a, addr_a);
+	ether_addr_copy(node->mac_address_b, addr_b);
+
+	rcu_read_lock();
+	oldnode = list_first_or_null_rcu(self_node_db,
+					 struct hsr_prp_node, mac_list);
+	if (oldnode) {
+		list_replace_rcu(&oldnode->mac_list, &node->mac_list);
+		rcu_read_unlock();
+		synchronize_rcu();
+		kfree(oldnode);
+	} else {
+		rcu_read_unlock();
+		list_add_tail_rcu(&node->mac_list, self_node_db);
+	}
+
+	return 0;
+}
+
+/* Allocate an hsr_node and add it to node_db. 'addr' is the node's AddressA;
+ * seq_out is used to initialize filtering of outgoing duplicate frames
+ * originating from the newly added node.
+ */
+struct hsr_prp_node *hsr_prp_add_node(struct list_head *node_db,
+				      unsigned char addr[],
+				      u16 seq_out)
+{
+	struct hsr_prp_node *node;
+	unsigned long now;
+	int i;
+
+	node = kzalloc(sizeof(*node), GFP_ATOMIC);
+	if (!node)
+		return NULL;
+
+	ether_addr_copy(node->mac_address_a, addr);
+
+	/* We are only interested in time diffs here, so use current jiffies
+	 * as initialization. (0 could trigger an spurious ring error warning).
+	 */
+	now = jiffies;
+	for (i = 0; i < HSR_PRP_PT_PORTS; i++)
+		node->time_in[i] = now;
+	for (i = 0; i < HSR_PRP_PT_PORTS; i++)
+		node->seq_out[i] = seq_out;
+
+	list_add_tail_rcu(&node->mac_list, node_db);
+
+	return node;
+}
+
+/* Get the hsr_node from which 'skb' was sent.
+ */
+struct hsr_prp_node *hsr_prp_get_node(struct list_head *node_db,
+				      struct sk_buff *skb,
+				      bool is_sup)
+{
+	struct hsr_prp_node *node;
+	struct ethhdr *ethhdr;
+	u16 seq_out;
+
+	if (!skb_mac_header_was_set(skb))
+		return NULL;
+
+	ethhdr = (struct ethhdr *)skb_mac_header(skb);
+
+	list_for_each_entry_rcu(node, node_db, mac_list) {
+		if (ether_addr_equal(node->mac_address_a, ethhdr->h_source))
+			return node;
+		if (ether_addr_equal(node->mac_address_b, ethhdr->h_source))
+			return node;
+	}
+
+	/* Everyone may create a node entry, connected node to a HSR device. */
+	if (ethhdr->h_proto == htons(ETH_P_PRP) ||
+	    ethhdr->h_proto == htons(ETH_P_HSR))
+		/* Use the existing sequence_nr from the tag as starting point
+		 * for filtering duplicate frames.
+		 */
+		seq_out = hsr_get_skb_sequence_nr(skb) - 1;
+	else
+		seq_out = HSR_PRP_SEQNR_START;
+
+	return hsr_prp_add_node(node_db, ethhdr->h_source, seq_out);
+}
+
+/* Use the Supervision frame's info about an eventual mac_address_b for merging
+ * nodes that has previously had their mac_address_b registered as a separate
+ * node.
+ */
+void hsr_prp_handle_sup_frame(struct sk_buff *skb,
+			      struct hsr_prp_node *node_curr,
+			      struct hsr_prp_port *port_rcv)
+{
+	struct ethhdr *ethhdr;
+	struct hsr_prp_node *node_real;
+	struct hsr_prp_sup_payload *hsr_sp;
+	struct list_head *node_db;
+	int i;
+
+	ethhdr = (struct ethhdr *)skb_mac_header(skb);
+
+	/* Leave the ethernet header. */
+	skb_pull(skb, sizeof(struct ethhdr));
+
+	/* And leave the HSR tag. */
+	if (ethhdr->h_proto == htons(ETH_P_HSR))
+		skb_pull(skb, sizeof(struct hsr_tag));
+
+	/* And leave the HSR sup tag. */
+	skb_pull(skb, sizeof(struct hsr_prp_sup_tag));
+
+	hsr_sp = (struct hsr_prp_sup_payload *)skb->data;
+
+	/* Merge node_curr (registered on mac_address_b) into node_real */
+	node_db = &port_rcv->priv->node_db;
+	node_real = find_node_by_addr_a(node_db, hsr_sp->mac_address_a);
+	if (!node_real)
+		/* No frame received from AddrA of this node yet */
+		node_real = hsr_prp_add_node(node_db, hsr_sp->mac_address_a,
+					     HSR_PRP_SEQNR_START - 1);
+	if (!node_real)
+		goto done; /* No mem */
+	if (node_real == node_curr)
+		/* Node has already been merged */
+		goto done;
+
+	ether_addr_copy(node_real->mac_address_b, ethhdr->h_source);
+	for (i = 0; i < HSR_PRP_PT_PORTS; i++) {
+		if (!node_curr->time_in_stale[i] &&
+		    time_after(node_curr->time_in[i], node_real->time_in[i])) {
+			node_real->time_in[i] = node_curr->time_in[i];
+			node_real->time_in_stale[i] =
+				node_curr->time_in_stale[i];
+		}
+		if (seq_nr_after(node_curr->seq_out[i], node_real->seq_out[i]))
+			node_real->seq_out[i] = node_curr->seq_out[i];
+	}
+	node_real->addr_b_port = port_rcv->type;
+
+	list_del_rcu(&node_curr->mac_list);
+	kfree_rcu(node_curr, rcu_head);
+
+done:
+	skb_push(skb, sizeof(struct hsrv1_ethhdr_sp));
+}
+
+/* 'skb' is a frame meant for this host, that is to be passed to upper layers.
+ *
+ * If the frame was sent by a node's B interface, replace the source
+ * address with that node's "official" address (mac_address_a) so that upper
+ * layers recognize where it came from.
+ */
+void hsr_addr_subst_source(struct hsr_prp_node *node, struct sk_buff *skb)
+{
+	if (!skb_mac_header_was_set(skb)) {
+		WARN_ONCE(1, "%s: Mac header not set\n", __func__);
+		return;
+	}
+
+	memcpy(&eth_hdr(skb)->h_source, node->mac_address_a, ETH_ALEN);
+}
+
+/* 'skb' is a frame meant for another host.
+ * 'port' is the outgoing interface
+ *
+ * Substitute the target (dest) MAC address if necessary, so the it matches the
+ * recipient interface MAC address, regardless of whether that is the
+ * recipient's A or B interface.
+ * This is needed to keep the packets flowing through switches that learn on
+ * which "side" the different interfaces are.
+ */
+void hsr_addr_subst_dest(struct hsr_prp_node *node_src, struct sk_buff *skb,
+			 struct hsr_prp_port *port)
+{
+	struct hsr_prp_node *node_dst;
+
+	if (!skb_mac_header_was_set(skb)) {
+		WARN_ONCE(1, "%s: Mac header not set\n", __func__);
+		return;
+	}
+
+	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
+		return;
+
+	node_dst = find_node_by_addr_a(&port->priv->node_db,
+				       eth_hdr(skb)->h_dest);
+	if (!node_dst) {
+		WARN_ONCE(1, "%s: Unknown node\n", __func__);
+		return;
+	}
+	if (port->type != node_dst->addr_b_port)
+		return;
+
+	if (is_valid_ether_addr(node_dst->mac_address_b))
+		ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->mac_address_b);
+	else
+		WARN_ONCE(1, "%s: mac address B not valid\n", __func__);
+}
+
+void hsr_register_frame_in(struct hsr_prp_node *node,
+			   struct hsr_prp_port *port,
+			   u16 sequence_nr)
+{
+	/* Don't register incoming frames without a valid sequence number. This
+	 * ensures entries of restarted nodes gets pruned so that they can
+	 * re-register and resume communications.
+	 */
+	if (seq_nr_before(sequence_nr, node->seq_out[port->type]))
+		return;
+
+	node->time_in[port->type] = jiffies;
+	node->time_in_stale[port->type] = false;
+}
+
+/* 'skb' is a HSR Ethernet frame (with a HSR tag inserted), with a valid
+ * ethhdr->h_source address and skb->mac_header set.
+ *
+ * Return:
+ *	 1 if frame can be shown to have been sent recently on this interface,
+ *	 0 otherwise, or
+ *	 negative error code on error
+ */
+int hsr_register_frame_out(struct hsr_prp_port *port,
+			   struct hsr_prp_node *node,
+			   u16 sequence_nr)
+{
+	if (seq_nr_before_or_eq(sequence_nr, node->seq_out[port->type]))
+		return 1;
+
+	node->seq_out[port->type] = sequence_nr;
+	return 0;
+}
+
+static struct hsr_prp_port *get_late_port(struct hsr_prp_priv *priv,
+					  struct hsr_prp_node *node)
+{
+	if (node->time_in_stale[HSR_PRP_PT_SLAVE_A])
+		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	if (node->time_in_stale[HSR_PRP_PT_SLAVE_B])
+		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+
+	if (time_after(node->time_in[HSR_PRP_PT_SLAVE_B],
+		       node->time_in[HSR_PRP_PT_SLAVE_A] +
+				msecs_to_jiffies(HSR_PRP_MAX_SLAVE_DIFF)))
+		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	if (time_after(node->time_in[HSR_PRP_PT_SLAVE_A],
+		       node->time_in[HSR_PRP_PT_SLAVE_B] +
+				msecs_to_jiffies(HSR_PRP_MAX_SLAVE_DIFF)))
+		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+
+	return NULL;
+}
+
+/* Remove stale sequence_nr records. Called by timer every
+ * HSR_LIFE_CHECK_INTERVAL (two seconds or so).
+ */
+void hsr_prp_prune_nodes(unsigned long data)
+{
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_node *node;
+	struct hsr_prp_port *port;
+	unsigned long timestamp;
+	unsigned long time_a, time_b;
+
+	priv = (struct hsr_prp_priv *)data;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(node, &priv->node_db, mac_list) {
+		/* Shorthand */
+		time_a = node->time_in[HSR_PRP_PT_SLAVE_A];
+		time_b = node->time_in[HSR_PRP_PT_SLAVE_B];
+
+		/* Check for timestamps old enough to risk wrap-around */
+		if (time_after(jiffies, time_a + MAX_JIFFY_OFFSET / 2))
+			node->time_in_stale[HSR_PRP_PT_SLAVE_A] = true;
+		if (time_after(jiffies, time_b + MAX_JIFFY_OFFSET / 2))
+			node->time_in_stale[HSR_PRP_PT_SLAVE_B] = true;
+
+		/* Get age of newest frame from node.
+		 * At least one time_in is OK here; nodes get pruned long
+		 * before both time_ins can get stale
+		 */
+		timestamp = time_a;
+		if (node->time_in_stale[HSR_PRP_PT_SLAVE_A] ||
+		    (!node->time_in_stale[HSR_PRP_PT_SLAVE_B] &&
+		    time_after(time_b, time_a)))
+			timestamp = time_b;
+
+		/* Warn of ring error only as long as we get frames at all */
+		if (time_is_after_jiffies(timestamp +
+			msecs_to_jiffies(1.5 * HSR_PRP_MAX_SLAVE_DIFF))) {
+			rcu_read_lock();
+			port = get_late_port(priv, node);
+			if (port)
+				hsr_nl_ringerror(priv,
+						 node->mac_address_a, port);
+			rcu_read_unlock();
+		}
+
+		/* Prune old entries */
+		if (time_is_before_jiffies(timestamp +
+			msecs_to_jiffies(HSR_PRP_NODE_FORGET_TIME))) {
+			hsr_nl_nodedown(priv, node->mac_address_a);
+			list_del_rcu(&node->mac_list);
+			/* Note that we need to free this entry later: */
+			kfree_rcu(node, rcu_head);
+		}
+	}
+	rcu_read_unlock();
+}
+
+void *hsr_prp_get_next_node(struct hsr_prp_priv *priv, void *_pos,
+			    unsigned char addr[ETH_ALEN])
+{
+	struct hsr_prp_node *node;
+
+	if (!_pos) {
+		node = list_first_or_null_rcu(&priv->node_db,
+					      struct hsr_prp_node, mac_list);
+		if (node)
+			ether_addr_copy(addr, node->mac_address_a);
+		return node;
+	}
+
+	node = _pos;
+	list_for_each_entry_continue_rcu(node, &priv->node_db, mac_list) {
+		ether_addr_copy(addr, node->mac_address_a);
+		return node;
+	}
+
+	return NULL;
+}
+
+int hsr_prp_get_node_data(struct hsr_prp_priv *priv,
+			  const unsigned char *addr,
+			  unsigned char addr_b[ETH_ALEN],
+			  unsigned int *addr_b_ifindex,
+			  int *if1_age, u16 *if1_seq,
+			  int *if2_age, u16 *if2_seq)
+{
+	struct hsr_prp_node *node;
+	struct hsr_prp_port *port;
+	unsigned long tdiff;
+
+	rcu_read_lock();
+	node = find_node_by_addr_a(&priv->node_db, addr);
+	if (!node) {
+		rcu_read_unlock();
+		return -ENOENT;	/* No such entry */
+	}
+
+	ether_addr_copy(addr_b, node->mac_address_b);
+
+	tdiff = jiffies - node->time_in[HSR_PRP_PT_SLAVE_A];
+	if (node->time_in_stale[HSR_PRP_PT_SLAVE_A])
+		*if1_age = INT_MAX;
+#if HZ <= MSEC_PER_SEC
+	else if (tdiff > msecs_to_jiffies(INT_MAX))
+		*if1_age = INT_MAX;
+#endif
+	else
+		*if1_age = jiffies_to_msecs(tdiff);
+
+	tdiff = jiffies - node->time_in[HSR_PRP_PT_SLAVE_B];
+	if (node->time_in_stale[HSR_PRP_PT_SLAVE_B])
+		*if2_age = INT_MAX;
+#if HZ <= MSEC_PER_SEC
+	else if (tdiff > msecs_to_jiffies(INT_MAX))
+		*if2_age = INT_MAX;
+#endif
+	else
+		*if2_age = jiffies_to_msecs(tdiff);
+
+	/* Present sequence numbers as if they were incoming on interface */
+	*if1_seq = node->seq_out[HSR_PRP_PT_SLAVE_B];
+	*if2_seq = node->seq_out[HSR_PRP_PT_SLAVE_A];
+
+	if (node->addr_b_port != HSR_PRP_PT_NONE) {
+		port = hsr_prp_get_port(priv, node->addr_b_port);
+		*addr_b_ifindex = port->dev->ifindex;
+	} else {
+		*addr_b_ifindex = -1;
+	}
+
+	rcu_read_unlock();
+
+	return 0;
+}
diff --git a/net/hsr-prp/hsr_prp_framereg.h b/net/hsr-prp/hsr_prp_framereg.h
new file mode 100644
index 0000000..db9aa01
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_framereg.h
@@ -0,0 +1,66 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#ifndef __HSR_PRP_FRAMEREG_H
+#define __HSR_PRP_FRAMEREG_H
+
+#include "hsr_prp_main.h"
+
+struct hsr_prp_node;
+
+struct hsr_prp_node *hsr_prp_add_node(struct list_head *node_db,
+				      unsigned char addr[], u16 seq_out);
+struct hsr_prp_node *hsr_prp_get_node(struct list_head *node_db,
+				      struct sk_buff *skb, bool is_sup);
+void hsr_prp_handle_sup_frame(struct sk_buff *skb,
+			      struct hsr_prp_node *node_curr,
+			      struct hsr_prp_port *port);
+bool hsr_prp_addr_is_self(struct hsr_prp_priv *priv, unsigned char *addr);
+
+void hsr_addr_subst_source(struct hsr_prp_node *node, struct sk_buff *skb);
+void hsr_addr_subst_dest(struct hsr_prp_node *node_src, struct sk_buff *skb,
+			 struct hsr_prp_port *port);
+
+void hsr_register_frame_in(struct hsr_prp_node *node,
+			   struct hsr_prp_port *port, u16 sequence_nr);
+int hsr_register_frame_out(struct hsr_prp_port *port,
+			   struct hsr_prp_node *node,
+			   u16 sequence_nr);
+
+void hsr_prp_prune_nodes(unsigned long data);
+
+int hsr_prp_create_self_node(struct list_head *self_node_db,
+			     unsigned char addr_a[ETH_ALEN],
+			     unsigned char addr_b[ETH_ALEN]);
+
+void *hsr_prp_get_next_node(struct hsr_prp_priv *priv, void *_pos,
+			    unsigned char addr[ETH_ALEN]);
+
+int hsr_prp_get_node_data(struct hsr_prp_priv *priv,
+			  const unsigned char *addr,
+			  unsigned char addr_b[ETH_ALEN],
+			  unsigned int *addr_b_ifindex,
+			  int *if1_age, u16 *if1_seq,
+			  int *if2_age, u16 *if2_seq);
+
+struct hsr_prp_node {
+	struct list_head	mac_list;
+	unsigned char		mac_address_a[ETH_ALEN];
+	unsigned char		mac_address_b[ETH_ALEN];
+	/* Local slave through which AddrB frames are received from this node */
+	enum hsr_prp_port_type	addr_b_port;
+	unsigned long		time_in[HSR_PRP_PT_PORTS];
+	bool			time_in_stale[HSR_PRP_PT_PORTS];
+	u16			seq_out[HSR_PRP_PT_PORTS];
+	struct rcu_head		rcu_head;
+};
+
+#endif /* __HSR_PRP_FRAMEREG_H */
diff --git a/net/hsr-prp/hsr_prp_main.h b/net/hsr-prp/hsr_prp_main.h
new file mode 100644
index 0000000..387f464
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_main.h
@@ -0,0 +1,212 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#ifndef __HSR_PRP_PRIVATE_H
+#define __HSR_PRP_PRIVATE_H
+
+#include <linux/netdevice.h>
+#include <linux/list.h>
+
+/* Time constants as specified in the HSR specification (IEC-62439-3 2010)
+ * Table 8.
+ * All values in milliseconds.
+ */
+#define HSR_PRP_LIFE_CHECK_INTERVAL              2000 /* ms */
+#define HSR_PRP_NODE_FORGET_TIME                60000 /* ms */
+#define HSR_PRP_ANNOUNCE_INTERVAL                 100 /* ms */
+
+/* By how much may slave1 and slave2 timestamps of latest received frame from
+ * each node differ before we notify of communication problem?
+ */
+#define HSR_PRP_MAX_SLAVE_DIFF			 3000 /* ms */
+#define HSR_PRP_SEQNR_START			(USHRT_MAX - 1024)
+#define HSR_PRP_SUP_SEQNR_START		(HSR_PRP_SEQNR_START / 2)
+/* How often shall we check for broken ring and remove node entries older than
+ * HSR_NODE_FORGET_TIME?
+ */
+#define HSR_PRP_PRUNE_PERIOD			 3000 /* ms */
+
+#define HSR_TLV_ANNOUNCE		   22
+#define HSR_TLV_LIFE_CHECK		   23
+
+/* HSR Tag.
+ * As defined in IEC-62439-3:2010, the HSR tag is really { ethertype = 0x88FB,
+ * path, LSDU_size, sequence Nr }. But we let eth_header() create { h_dest,
+ * h_source, h_proto = 0x88FB }, and add { path, LSDU_size, sequence Nr,
+ * encapsulated protocol } instead.
+ *
+ * Field names as defined in the IEC:2010 standard for HSR.
+ */
+struct hsr_tag {
+	__be16		path_and_LSDU_size;
+	__be16		sequence_nr;
+	__be16		encap_proto;
+} __packed;
+
+#define HSR_PRP_HLEN	6
+
+#define HSR_V1_SUP_LSDUSIZE		52
+
+/* The helper functions below assumes that 'path' occupies the 4 most
+ * significant bits of the 16-bit field shared by 'path' and 'LSDU_size' (or
+ * equivalently, the 4 most significant bits of HSR tag byte 14).
+ *
+ * This is unclear in the IEC specification; its definition of MAC addresses
+ * indicates the spec is written with the least significant bit first (to the
+ * left). This, however, would mean that the LSDU field would be split in two
+ * with the path field in-between, which seems strange. I'm guessing the MAC
+ * address definition is in error.
+ */
+static inline u16 get_hsr_tag_path(struct hsr_tag *ht)
+{
+	return ntohs(ht->path_and_LSDU_size) >> 12;
+}
+
+static inline u16 get_hsr_tag_LSDU_size(struct hsr_tag *ht)
+{
+	return ntohs(ht->path_and_LSDU_size) & 0x0FFF;
+}
+
+static inline void set_hsr_tag_path(struct hsr_tag *ht, u16 path)
+{
+	ht->path_and_LSDU_size =
+		htons((ntohs(ht->path_and_LSDU_size) & 0x0FFF) | (path << 12));
+}
+
+static inline void set_hsr_tag_LSDU_size(struct hsr_tag *ht, u16 LSDU_size)
+{
+	ht->path_and_LSDU_size = htons(
+				      (ntohs(ht->path_and_LSDU_size) & 0xF000) |
+				      (LSDU_size & 0x0FFF));
+}
+
+struct hsr_ethhdr {
+	struct ethhdr	ethhdr;
+	struct hsr_tag	hsr_tag;
+} __packed;
+
+/* HSR/PRP Supervision Frame data types.
+ * Field names as defined in the IEC:2012 standard for HSR.
+ */
+struct hsr_prp_sup_tag {
+	__be16		path_and_HSR_Ver;
+	__be16		sequence_nr;
+	__u8		HSR_TLV_type;
+	__u8		HSR_TLV_length;
+} __packed;
+
+struct hsr_prp_sup_payload {
+	unsigned char	mac_address_a[ETH_ALEN];
+} __packed;
+
+static inline u16 get_hsr_stag_path(struct hsr_prp_sup_tag *hst)
+{
+	return get_hsr_tag_path((struct hsr_tag *)hst);
+}
+
+static inline u16 get_hsr_stag_HSR_ver(struct hsr_prp_sup_tag *hst)
+{
+	return get_hsr_tag_LSDU_size((struct hsr_tag *)hst);
+}
+
+static inline void set_hsr_stag_path(struct hsr_prp_sup_tag *hst, u16 path)
+{
+	set_hsr_tag_path((struct hsr_tag *)hst, path);
+}
+
+static inline void set_hsr_stag_HSR_ver(struct hsr_prp_sup_tag *hst,
+					u16 HSR_ver)
+{
+	set_hsr_tag_LSDU_size((struct hsr_tag *)hst, HSR_ver);
+}
+
+struct hsrv0_ethhdr_sp {
+	struct ethhdr		ethhdr;
+	struct hsr_prp_sup_tag	hsr_sup;
+} __packed;
+
+struct hsrv1_ethhdr_sp {
+	struct ethhdr		ethhdr;
+	struct hsr_tag		hsr;
+	struct hsr_prp_sup_tag	hsr_sup;
+} __packed;
+
+enum hsr_prp_port_type {
+	HSR_PRP_PT_NONE = 0,	/* Must be 0, used by framereg */
+	HSR_PRP_PT_SLAVE_A,
+	HSR_PRP_PT_SLAVE_B,
+	HSR_PRP_PT_INTERLINK,
+	HSR_PRP_PT_MASTER,
+	HSR_PRP_PT_PORTS,	/* This must be the last item in the enum */
+};
+
+struct hsr_prp_port {
+	struct list_head	port_list;
+	struct net_device	*dev;
+	struct hsr_prp_priv	*priv;
+	enum hsr_prp_port_type	type;
+};
+
+struct hsr_prp_priv {
+	struct rcu_head		rcu_head;
+	struct list_head	ports;
+	struct list_head	node_db;	/* Known HSR nodes */
+	struct list_head	self_node_db;	/* MACs of slaves */
+	struct timer_list	announce_timer;	/* Supervision frame dispatch */
+	struct timer_list	prune_timer;
+	bool			rx_offloaded;	/* lre handle in hw */
+	bool			l2_fwd_offloaded; /* L2 forward in hw */
+	int announce_count;
+	u16 sequence_nr;
+	u16 sup_sequence_nr;	/* For HSRv1 separate seq_nr for supervision */
+	u8 prot_version;	/* Indicate if HSRv0 or HSRv1 or PRPv1 */
+	spinlock_t seqnr_lock;	/* locking for sequence_nr */
+	unsigned char		sup_multicast_addr[ETH_ALEN];
+#ifdef	CONFIG_DEBUG_FS
+	struct dentry *node_tbl_root;
+	struct dentry *node_tbl_file;
+#endif
+};
+
+#define hsr_prp_for_each_port(hsr_prp, port) \
+	list_for_each_entry_rcu((port), &(hsr_prp)->ports, port_list)
+
+struct hsr_prp_port *hsr_prp_get_port(struct hsr_prp_priv *hsr_prp,
+				      enum hsr_prp_port_type pt);
+int hsr_prp_netdev_notify(struct notifier_block *nb, unsigned long event,
+			  void *ptr);
+
+/* Caller must ensure skb is a valid HSR frame */
+static inline u16 hsr_get_skb_sequence_nr(struct sk_buff *skb)
+{
+	struct hsr_ethhdr *hsr_ethhdr;
+
+	hsr_ethhdr = (struct hsr_ethhdr *)skb_mac_header(skb);
+
+	return ntohs(hsr_ethhdr->hsr_tag.sequence_nr);
+}
+
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+int hsr_prp_debugfs_init(struct hsr_prp_priv *priv,
+			 struct net_device *hsr_prp_dev);
+void hsr_prp_debugfs_term(struct hsr_prp_priv *priv);
+#else
+static inline int hsr_prp_debugfs_init(struct hsr_prp_priv *priv,
+				       struct net_device *hsr_prp_dev)
+{
+	return 0;
+}
+
+static inline void hsr_prp_debugfs_term(struct hsr_prp_priv *priv)
+{}
+#endif
+
+#endif /*  __HSR_PRP_PRIVATE_H */
diff --git a/net/hsr-prp/hsr_prp_slave.c b/net/hsr-prp/hsr_prp_slave.c
new file mode 100644
index 0000000..7c7d9fc
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_slave.c
@@ -0,0 +1,200 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#include "hsr_prp_slave.h"
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include "hsr_prp_main.h"
+#include "hsr_prp_device.h"
+#include "hsr_prp_forward.h"
+#include "hsr_prp_framereg.h"
+
+static rx_handler_result_t hsr_prp_handle_frame(struct sk_buff **pskb)
+{
+	struct sk_buff *skb = *pskb;
+	struct hsr_prp_port *port;
+	u16 protocol;
+
+	if (!skb_mac_header_was_set(skb)) {
+		WARN_ONCE(1, "%s: skb invalid", __func__);
+		return RX_HANDLER_PASS;
+	}
+
+	rcu_read_lock(); /* hsr->node_db, hsr->ports */
+	port = hsr_prp_port_get_rcu(skb->dev);
+
+	if (hsr_prp_addr_is_self(port->priv, eth_hdr(skb)->h_source)) {
+		/* Directly kill frames sent by ourselves */
+		kfree_skb(skb);
+		goto finish_consume;
+	}
+
+	protocol = eth_hdr(skb)->h_proto;
+	if (protocol != htons(ETH_P_PRP) && protocol != htons(ETH_P_HSR))
+		goto finish_pass;
+
+	skb_push(skb, ETH_HLEN);
+
+	hsr_prp_forward_skb(skb, port);
+
+finish_consume:
+	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
+	return RX_HANDLER_CONSUMED;
+
+finish_pass:
+	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
+	return RX_HANDLER_PASS;
+}
+
+bool hsr_prp_port_exists(const struct net_device *dev)
+{
+	return rcu_access_pointer(dev->rx_handler) == hsr_prp_handle_frame;
+}
+
+static int hsr_prp_check_dev_ok(struct net_device *dev)
+{
+	/* Don't allow HSR on non-ethernet like devices */
+	if ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||
+	    (dev->addr_len != ETH_ALEN)) {
+		netdev_info(dev, "Cannot use loopback or non-ethernet device as HSR slave.\n");
+		return -EINVAL;
+	}
+
+	/* Don't allow enslaving hsr devices */
+	if (is_hsr_prp_master(dev)) {
+		netdev_info(dev, "Cannot create trees of HSR devices.\n");
+		return -EINVAL;
+	}
+
+	if (hsr_prp_port_exists(dev)) {
+		netdev_info(dev, "This device is already a HSR slave.\n");
+		return -EINVAL;
+	}
+
+	if (dev->priv_flags & IFF_802_1Q_VLAN) {
+		netdev_info(dev, "HSR on top of VLAN is not yet supported in this driver.\n");
+		return -EINVAL;
+	}
+
+	if (dev->priv_flags & IFF_DONT_BRIDGE) {
+		netdev_info(dev, "This device does not support bridging.\n");
+		return -EOPNOTSUPP;
+	}
+
+	/* HSR over bonded devices has not been tested, but I'm not sure it
+	 * won't work...
+	 */
+
+	return 0;
+}
+
+/* Setup device to be added to the HSR bridge. */
+static int hsr_prp_portdev_setup(struct net_device *dev,
+				 struct hsr_prp_port *port)
+{
+	int res;
+
+	dev_hold(dev);
+	res = dev_set_promiscuity(dev, 1);
+	if (res)
+		goto fail_promiscuity;
+
+	/* FIXME:
+	 * What does net device "adjacency" mean? Should we do
+	 * res = netdev_master_upper_dev_link(port->dev, port->hsr->dev); ?
+	 */
+
+	res = netdev_rx_handler_register(dev, hsr_prp_handle_frame, port);
+	if (res)
+		goto fail_rx_handler;
+	dev_disable_lro(dev);
+
+	return 0;
+
+fail_rx_handler:
+	dev_set_promiscuity(dev, -1);
+fail_promiscuity:
+	dev_put(dev);
+
+	return res;
+}
+
+int hsr_prp_add_port(struct hsr_prp_priv *priv, struct net_device *dev,
+		     enum hsr_prp_port_type type)
+{
+	struct hsr_prp_port *port, *master;
+	int res;
+
+	if (type != HSR_PRP_PT_MASTER) {
+		res = hsr_prp_check_dev_ok(dev);
+		if (res)
+			return res;
+	}
+
+	port = hsr_prp_get_port(priv, type);
+	if (port)
+		return -EBUSY;	/* This port already exists */
+
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return -ENOMEM;
+
+	if (type != HSR_PRP_PT_MASTER) {
+		res = hsr_prp_portdev_setup(dev, port);
+		if (res)
+			goto fail_dev_setup;
+	}
+
+	port->priv = priv;
+	port->dev = dev;
+	port->type = type;
+
+	list_add_tail_rcu(&port->port_list, &priv->ports);
+	synchronize_rcu();
+
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+	netdev_update_features(master->dev);
+	dev_set_mtu(master->dev, hsr_prp_get_max_mtu(priv));
+
+	return 0;
+
+fail_dev_setup:
+	kfree(port);
+	return res;
+}
+
+void hsr_prp_del_port(struct hsr_prp_port *port)
+{
+	struct hsr_prp_priv *priv;
+	struct hsr_prp_port *master;
+
+	priv = port->priv;
+	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
+	list_del_rcu(&port->port_list);
+
+	if (port != master) {
+		if (master) {
+			netdev_update_features(master->dev);
+			dev_set_mtu(master->dev, hsr_prp_get_max_mtu(priv));
+		}
+		netdev_rx_handler_unregister(port->dev);
+		dev_set_promiscuity(port->dev, -1);
+	}
+
+	/* FIXME?
+	 * netdev_upper_dev_unlink(port->dev, port->priv->dev);
+	 */
+
+	synchronize_rcu();
+
+	if (port != master)
+		dev_put(port->dev);
+}
diff --git a/net/hsr-prp/hsr_prp_slave.h b/net/hsr-prp/hsr_prp_slave.h
new file mode 100644
index 0000000..4824805
--- /dev/null
+++ b/net/hsr-prp/hsr_prp_slave.h
@@ -0,0 +1,40 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#ifndef __HSR_PRP_SLAVE_H
+#define __HSR_PRP_SLAVE_H
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include "hsr_prp_main.h"
+
+int hsr_prp_add_port(struct hsr_prp_priv *priv, struct net_device *dev,
+		     enum hsr_prp_port_type pt);
+void hsr_prp_del_port(struct hsr_prp_port *port);
+bool hsr_prp_port_exists(const struct net_device *dev);
+
+static inline struct hsr_prp_port
+*hsr_prp_port_get_rtnl(const struct net_device *dev)
+{
+	ASSERT_RTNL();
+	return hsr_prp_port_exists(dev) ?
+				rtnl_dereference(dev->rx_handler_data) : NULL;
+}
+
+static inline struct hsr_prp_port
+*hsr_prp_port_get_rcu(const struct net_device *dev)
+{
+	return hsr_prp_port_exists(dev) ?
+				rcu_dereference(dev->rx_handler_data) : NULL;
+}
+
+#endif /* __HSR_PRP_SLAVE_H */
diff --git a/net/hsr/Kconfig b/net/hsr/Kconfig
deleted file mode 100644
index 3684735..0000000
--- a/net/hsr/Kconfig
+++ /dev/null
@@ -1,36 +0,0 @@
-#
-# IEC 62439-3 High-availability Seamless Redundancy (HSR) /
-# IEC 62439-4 Parallel Redundancy Protocol (PRP) support
-#
-config HSR_PRP
-	tristate "IEC 62439 HSR/PRP Support"
-	---help---
-	  This enables IEC 62439 defined High-availability Seamless
-	  Redundancy (HSR) and Parallel Redundancy Protocol (PRP) support.
-	  If you say Y here, then your Linux box will be able to act as a
-	  DANH ("Doubly attached node implementing HSR") or DANP ("Doubly
-	  attached node implementing PRP"). For this to work, your Linux
-	  box needs (at least) two physical Ethernet interfaces.
-
-	  For DANH, it must be connected as a node in a ring network together
-	  with other HSR capable nodes. All Ethernet frames sent over the hsr
-	  device will be sent in both directions on the ring (over both slave
-	  ports), giving a redundant, instant fail-over network. Each HSR node
-	  in the ring acts like a bridge for HSR frames, but filters frames
-	  that have been forwarded earlier.
-
-	  For DANP, it must be connected as a node connecting to two
-	  separate networks over the two slave interfaces. Like HSR, Ethernet
-	  frames sent over the prp device will be sent to both networks giving
-	  a redundant, instant fail-over network.
-
-	  This code is a "best effort" to comply with the HSR standard as
-	  described in IEC 62439-3:2010 (HSRv0) and IEC 62439-3:2012 (HSRv1),
-	  and PRP standard described in IEC 62439-4:2012 (PRP), but no
-	  compliancy tests have been made. Use iproute2 to select the protocol
-	  you would like to use.
-
-	  You need to perform any and all necessary tests yourself before
-	  relying on this code in a safety critical system!
-
-	  If unsure, say N.
diff --git a/net/hsr/Makefile b/net/hsr/Makefile
deleted file mode 100644
index 704b939..0000000
--- a/net/hsr/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# Makefile for HSR
-#
-
-obj-$(CONFIG_HSR_PRP)	+= hsr-prp.o
-
-hsr-prp-y		:= hsr_main.o hsr_framereg.o hsr_device.o \
-			   hsr_netlink.o hsr_slave.o hsr_forward.o
-hsr-prp-$(CONFIG_DEBUG_FS) += hsr_prp_debugfs.o
diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
deleted file mode 100644
index c64b41d..0000000
--- a/net/hsr/hsr_device.c
+++ /dev/null
@@ -1,544 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- *
- * This file contains device methods for creating, using and destroying
- * virtual HSR devices.
- */
-
-#include <linux/netdevice.h>
-#include <linux/skbuff.h>
-#include <linux/etherdevice.h>
-#include <linux/rtnetlink.h>
-#include <linux/pkt_sched.h>
-#include "hsr_device.h"
-#include "hsr_slave.h"
-#include "hsr_framereg.h"
-#include "hsr_main.h"
-#include "hsr_forward.h"
-
-static bool is_admin_up(struct net_device *dev)
-{
-	return dev && (dev->flags & IFF_UP);
-}
-
-static bool is_slave_up(struct net_device *dev)
-{
-	return dev && is_admin_up(dev) && netif_oper_up(dev);
-}
-
-static void __set_operstate(struct net_device *dev, int transition)
-{
-	write_lock_bh(&dev_base_lock);
-	if (dev->operstate != transition) {
-		dev->operstate = transition;
-		write_unlock_bh(&dev_base_lock);
-		netdev_state_change(dev);
-	} else {
-		write_unlock_bh(&dev_base_lock);
-	}
-}
-
-static void set_operstate(struct hsr_prp_port *master, bool has_carrier)
-{
-	if (!is_admin_up(master->dev)) {
-		__set_operstate(master->dev, IF_OPER_DOWN);
-		return;
-	}
-
-	if (has_carrier)
-		__set_operstate(master->dev, IF_OPER_UP);
-	else
-		__set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);
-}
-
-static bool hsr_prp_check_carrier(struct hsr_prp_port *master)
-{
-	struct hsr_prp_port *port;
-	bool has_carrier;
-
-	has_carrier = false;
-
-	rcu_read_lock();
-	hsr_prp_for_each_port(master->priv, port)
-		if ((port->type != HSR_PRP_PT_MASTER) &&
-		    is_slave_up(port->dev)) {
-			has_carrier = true;
-			break;
-		}
-	rcu_read_unlock();
-
-	if (has_carrier)
-		netif_carrier_on(master->dev);
-	else
-		netif_carrier_off(master->dev);
-
-	return has_carrier;
-}
-
-static void hsr_prp_check_announce(struct net_device *hsr_dev,
-				   unsigned char old_operstate)
-{
-	struct hsr_prp_priv *priv;
-
-	priv = netdev_priv(hsr_dev);
-
-	if ((hsr_dev->operstate == IF_OPER_UP) &&
-	    (old_operstate != IF_OPER_UP)) {
-		/* Went up */
-		priv->announce_count = 0;
-		priv->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_PRP_ANNOUNCE_INTERVAL);
-		add_timer(&priv->announce_timer);
-	}
-
-	if ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))
-		/* Went down */
-		del_timer(&priv->announce_timer);
-}
-
-void hsr_prp_check_carrier_and_operstate(struct hsr_prp_priv *priv)
-{
-	struct hsr_prp_port *master;
-	unsigned char old_operstate;
-	bool has_carrier;
-
-	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-	/* netif_stacked_transfer_operstate() cannot be used here since
-	 * it doesn't set IF_OPER_LOWERLAYERDOWN (?)
-	 */
-	old_operstate = master->dev->operstate;
-	has_carrier = hsr_prp_check_carrier(master);
-	set_operstate(master, has_carrier);
-	hsr_prp_check_announce(master->dev, old_operstate);
-}
-
-int hsr_prp_get_max_mtu(struct hsr_prp_priv *priv)
-{
-	unsigned int mtu_max;
-	struct hsr_prp_port *port;
-
-	mtu_max = ETH_DATA_LEN;
-	rcu_read_lock();
-	hsr_prp_for_each_port(priv, port)
-		if (port->type != HSR_PRP_PT_MASTER)
-			mtu_max = min(port->dev->mtu, mtu_max);
-	rcu_read_unlock();
-
-	if (mtu_max < HSR_PRP_HLEN)
-		return 0;
-	return mtu_max - HSR_PRP_HLEN;
-}
-
-static int hsr_prp_dev_change_mtu(struct net_device *dev, int new_mtu)
-{
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *master;
-	int max;
-
-	priv = netdev_priv(dev);
-	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-	max = hsr_prp_get_max_mtu(priv);
-	if (new_mtu > max) {
-		netdev_info(master->dev,
-			    "HSR/PRP: Invalid MTU, expected (<= %d), Got %d.\n",
-			    max, new_mtu);
-		return -EINVAL;
-	}
-
-	dev->mtu = new_mtu;
-
-	return 0;
-}
-
-static int hsr_prp_dev_open(struct net_device *dev)
-{
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *port;
-	char designation;
-
-	priv = netdev_priv(dev);
-	designation = '\0';
-
-	rcu_read_lock();
-	hsr_prp_for_each_port(priv, port) {
-		if (port->type == HSR_PRP_PT_MASTER)
-			continue;
-		switch (port->type) {
-		case HSR_PRP_PT_SLAVE_A:
-			designation = 'A';
-			break;
-		case HSR_PRP_PT_SLAVE_B:
-			designation = 'B';
-			break;
-		default:
-			designation = '?';
-		}
-		if (!is_slave_up(port->dev))
-			netdev_warn(dev,
-				    "HSR/PRP: Please bringup Slave %c (%s)\n",
-				    designation, port->dev->name);
-	}
-	rcu_read_unlock();
-
-	if (designation == '\0')
-		netdev_warn(dev, "No slave devices configured\n");
-
-	return 0;
-}
-
-static int hsr_prp_dev_close(struct net_device *dev)
-{
-	/* Nothing to do here. */
-	return 0;
-}
-
-static netdev_features_t hsr_prp_features_recompute(struct hsr_prp_priv *priv,
-						    netdev_features_t features)
-{
-	netdev_features_t mask;
-	struct hsr_prp_port *port;
-
-	mask = features;
-
-	/* Mask out all features that, if supported by one device, should be
-	 * enabled for all devices (see NETIF_F_ONE_FOR_ALL).
-	 *
-	 * Anything that's off in mask will not be enabled - so only things
-	 * that were in features originally, and also is in NETIF_F_ONE_FOR_ALL,
-	 * may become enabled.
-	 */
-	features &= ~NETIF_F_ONE_FOR_ALL;
-	hsr_prp_for_each_port(priv, port)
-		features = netdev_increment_features(features,
-						     port->dev->features,
-						     mask);
-
-	return features;
-}
-
-static netdev_features_t hsr_prp_fix_features(struct net_device *dev,
-					      netdev_features_t features)
-{
-	struct hsr_prp_priv *priv = netdev_priv(dev);
-
-	return hsr_prp_features_recompute(priv, features);
-}
-
-static int hsr_prp_dev_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct hsr_prp_priv *priv = netdev_priv(dev);
-	struct hsr_prp_port *master;
-
-	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-	skb->dev = master->dev;
-	hsr_prp_forward_skb(skb, master);
-	master->dev->stats.tx_packets++;
-	master->dev->stats.tx_bytes += skb->len;
-
-	return NETDEV_TX_OK;
-}
-
-static const struct header_ops hsr_prp_header_ops = {
-	.create	 = eth_header,
-	.parse	 = eth_header_parse,
-};
-
-static void send_supervision_frame(struct hsr_prp_port *master,
-				   u8 type, u8 prot_ver)
-{
-	struct sk_buff *skb;
-	int hlen, tlen;
-	struct hsr_tag *hsr_tag;
-	struct hsr_prp_sup_tag *hsr_stag;
-	struct hsr_prp_sup_payload *hsr_sp;
-	unsigned long irqflags;
-
-	hlen = LL_RESERVED_SPACE(master->dev);
-	tlen = master->dev->needed_tailroom;
-	skb = dev_alloc_skb(
-			sizeof(struct hsr_tag) +
-			sizeof(struct hsr_prp_sup_tag) +
-			sizeof(struct hsr_prp_sup_payload) + hlen + tlen);
-	if (!skb)
-		return;
-
-	skb_reserve(skb, hlen);
-
-	skb->dev = master->dev;
-	skb->protocol = htons(prot_ver ? ETH_P_HSR : ETH_P_PRP);
-	skb->priority = TC_PRIO_CONTROL;
-
-	if (dev_hard_header(skb, skb->dev, (prot_ver ? ETH_P_HSR : ETH_P_PRP),
-			    master->priv->sup_multicast_addr,
-			    skb->dev->dev_addr, skb->len) <= 0)
-		goto out;
-
-	skb_reset_mac_header(skb);
-	if (prot_ver > 0) {
-		hsr_tag = (typeof(hsr_tag))skb_put(skb,
-						   sizeof(struct hsr_tag));
-		hsr_tag->encap_proto = htons(ETH_P_PRP);
-		set_hsr_tag_LSDU_size(hsr_tag, HSR_V1_SUP_LSDUSIZE);
-	}
-
-	hsr_stag = (typeof(hsr_stag))skb_put(skb,
-					     sizeof(struct hsr_prp_sup_tag));
-	set_hsr_stag_path(hsr_stag, (prot_ver ? 0x0 : 0xf));
-	set_hsr_stag_HSR_ver(hsr_stag, prot_ver);
-
-	/* From HSRv1 on we have separate supervision sequence numbers. */
-	spin_lock_irqsave(&master->priv->seqnr_lock, irqflags);
-	if (prot_ver > 0) {
-		hsr_stag->sequence_nr = htons(master->priv->sup_sequence_nr);
-		hsr_tag->sequence_nr = htons(master->priv->sequence_nr);
-		master->priv->sup_sequence_nr++;
-		master->priv->sequence_nr++;
-	} else {
-		hsr_stag->sequence_nr = htons(master->priv->sequence_nr);
-		master->priv->sequence_nr++;
-	}
-	spin_unlock_irqrestore(&master->priv->seqnr_lock, irqflags);
-
-	hsr_stag->HSR_TLV_type = type;
-	/* TODO: Why 12 in HSRv0? */
-	hsr_stag->HSR_TLV_length =
-		prot_ver ? sizeof(struct hsr_prp_sup_payload) : 12;
-
-	/* Payload: mac_address_a */
-	hsr_sp = (typeof(hsr_sp))skb_put(skb,
-					 sizeof(struct hsr_prp_sup_payload));
-	ether_addr_copy(hsr_sp->mac_address_a, master->dev->dev_addr);
-	skb_put_padto(skb, ETH_ZLEN + HSR_PRP_HLEN);
-
-	hsr_prp_forward_skb(skb, master);
-	return;
-
-out:
-	WARN_ONCE(1, "HSR: Could not send supervision frame\n");
-	kfree_skb(skb);
-}
-
-/* Announce (supervision frame) timer function
- */
-static void hsr_prp_announce(unsigned long data)
-{
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *master;
-
-	priv = (struct hsr_prp_priv *)data;
-
-	rcu_read_lock();
-	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-
-	if (priv->announce_count < 3 && priv->prot_version == 0) {
-		send_supervision_frame(master, HSR_TLV_ANNOUNCE,
-				       priv->prot_version);
-		priv->announce_count++;
-
-		priv->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_PRP_ANNOUNCE_INTERVAL);
-	} else {
-		send_supervision_frame(master, HSR_TLV_LIFE_CHECK,
-				       priv->prot_version);
-
-		priv->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_PRP_LIFE_CHECK_INTERVAL);
-	}
-
-	if (is_admin_up(master->dev))
-		add_timer(&priv->announce_timer);
-
-	rcu_read_unlock();
-}
-
-
-/* According to comments in the declaration of struct net_device, this function
- * is "Called from unregister, can be used to call free_netdev". Ok then...
- */
-static void hsr_prp_dev_destroy(struct net_device *hsr_prp_dev)
-{
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *port;
-
-	priv = netdev_priv(hsr_prp_dev);
-
-	hsr_prp_debugfs_term(priv);
-
-	rtnl_lock();
-	hsr_prp_for_each_port(priv, port)
-		hsr_prp_del_port(port);
-	rtnl_unlock();
-
-	del_timer_sync(&priv->prune_timer);
-	del_timer_sync(&priv->announce_timer);
-
-	synchronize_rcu();
-	free_netdev(hsr_prp_dev);
-}
-
-static const struct net_device_ops hsr_prp_device_ops = {
-	.ndo_change_mtu = hsr_prp_dev_change_mtu,
-	.ndo_open = hsr_prp_dev_open,
-	.ndo_stop = hsr_prp_dev_close,
-	.ndo_start_xmit = hsr_prp_dev_xmit,
-	.ndo_fix_features = hsr_prp_fix_features,
-};
-
-static struct device_type hsr_type = {
-	.name = "hsr",
-};
-
-void hsr_prp_dev_setup(struct net_device *ndev)
-{
-	random_ether_addr(ndev->dev_addr);
-
-	ether_setup(ndev);
-	ndev->header_ops = &hsr_prp_header_ops;
-	ndev->netdev_ops = &hsr_prp_device_ops;
-	SET_NETDEV_DEVTYPE(ndev, &hsr_type);
-	ndev->priv_flags |= IFF_NO_QUEUE;
-
-	ndev->destructor = hsr_prp_dev_destroy;
-
-	ndev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
-			   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |
-			   NETIF_F_HW_VLAN_CTAG_TX;
-
-	ndev->features = ndev->hw_features;
-
-	/* Prevent recursive tx locking */
-	ndev->features |= NETIF_F_LLTX;
-	/* VLAN on top of HSR needs testing and probably some work on
-	 * hsr_header_create() etc.
-	 */
-	ndev->features |= NETIF_F_VLAN_CHALLENGED;
-	/* Not sure about this. Taken from bridge code. netdev_features.h says
-	 * it means "Does not change network namespaces".
-	 */
-	ndev->features |= NETIF_F_NETNS_LOCAL;
-}
-
-/* Return true if dev is a HSR master; return false otherwise.
- */
-inline bool is_hsr_prp_master(struct net_device *dev)
-{
-	return (dev->netdev_ops->ndo_start_xmit == hsr_prp_dev_xmit);
-}
-
-/* Default multicast address for HSR Supervision frames */
-static const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {
-	0x01, 0x15, 0x4e, 0x00, 0x01, 0x00
-};
-
-int hsr_prp_dev_finalize(struct net_device *hsr_prp_dev,
-			 struct net_device *slave[2],
-			 unsigned char multicast_spec, u8 protocol_version)
-{
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *port;
-	int res;
-
-	priv = netdev_priv(hsr_prp_dev);
-	INIT_LIST_HEAD(&priv->ports);
-	INIT_LIST_HEAD(&priv->node_db);
-	INIT_LIST_HEAD(&priv->self_node_db);
-
-	ether_addr_copy(hsr_prp_dev->dev_addr, slave[0]->dev_addr);
-
-	/* Make sure we recognize frames from ourselves in
-	 * hsr_rcv() or frame is addressed to me
-	 */
-	res = hsr_prp_create_self_node(&priv->self_node_db,
-				       hsr_prp_dev->dev_addr,
-				       slave[1]->dev_addr);
-	if (res < 0)
-		return res;
-
-	spin_lock_init(&priv->seqnr_lock);
-	/* Overflow soon to find bugs easier: */
-	priv->sequence_nr = HSR_PRP_SEQNR_START;
-	priv->sup_sequence_nr = HSR_PRP_SUP_SEQNR_START;
-
-	setup_timer(&priv->announce_timer, hsr_prp_announce,
-		    (unsigned long)priv);
-
-	if (!priv->rx_offloaded)
-		setup_timer(&priv->prune_timer, hsr_prp_prune_nodes,
-			    (unsigned long)priv);
-
-	ether_addr_copy(priv->sup_multicast_addr, def_multicast_addr);
-	priv->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
-
-	priv->prot_version = protocol_version;
-
-	/* FIXME: should I modify the value of these?
-	 *
-	 * - hsr_dev->flags - i.e.
-	 *			IFF_MASTER/SLAVE?
-	 * - hsr_dev->priv_flags - i.e.
-	 *			IFF_EBRIDGE?
-	 *			IFF_TX_SKB_SHARING?
-	 *			IFF_HSR_MASTER/SLAVE?
-	 */
-
-	/* Make sure the 1st call to netif_carrier_on() gets through */
-	netif_carrier_off(hsr_prp_dev);
-
-	res = hsr_prp_add_port(priv, hsr_prp_dev, HSR_PRP_PT_MASTER);
-	if (res)
-		return res;
-
-	/* HSR LRE Rx offload supported in lower device? */
-	if ((slave[0]->features & NETIF_F_HW_HSR_RX_OFFLOAD) &&
-	    (slave[1]->features & NETIF_F_HW_HSR_RX_OFFLOAD))
-		priv->rx_offloaded = true;
-
-	/* HSR LRE L2 forward offload supported in lower device? */
-	if ((slave[0]->features & NETIF_F_HW_L2FW_DOFFLOAD) &&
-	    (slave[1]->features & NETIF_F_HW_L2FW_DOFFLOAD))
-		priv->l2_fwd_offloaded = true;
-
-	res = register_netdevice(hsr_prp_dev);
-	if (res)
-		goto fail;
-
-	res = hsr_prp_add_port(priv, slave[0], HSR_PRP_PT_SLAVE_A);
-	if (res)
-		goto fail;
-	res = hsr_prp_add_port(priv, slave[1], HSR_PRP_PT_SLAVE_B);
-	if (res)
-		goto fail;
-
-	/* For LRE rx offload, pruning is expected to happen
-	 * at the hardware or firmware . So don't do this in software
-	 */
-	if (!priv->rx_offloaded)
-		mod_timer(&priv->prune_timer,
-			  jiffies + msecs_to_jiffies(HSR_PRP_PRUNE_PERIOD));
-	/* for offloaded case, expect both slaves have the
-	 * same MAC address configured. If not fail.
-	 */
-	if (priv->rx_offloaded &&
-	    !ether_addr_equal(slave[0]->dev_addr,
-			      slave[1]->dev_addr))
-		goto fail;
-
-	res = hsr_prp_debugfs_init(priv);
-	if (res)
-		goto fail;
-
-	return 0;
-
-fail:
-	hsr_prp_for_each_port(priv, port)
-		hsr_prp_del_port(port);
-
-	return res;
-}
diff --git a/net/hsr/hsr_device.h b/net/hsr/hsr_device.h
deleted file mode 100644
index d6a4b2e..0000000
--- a/net/hsr/hsr_device.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#ifndef __HSR_DEVICE_H
-#define __HSR_DEVICE_H
-
-#include <linux/netdevice.h>
-#include "hsr_main.h"
-
-void hsr_prp_dev_setup(struct net_device *dev);
-int hsr_prp_dev_finalize(struct net_device *dev, struct net_device *slave[2],
-			 unsigned char multicast_spec, u8 protocol_version);
-void hsr_prp_check_carrier_and_operstate(struct hsr_prp_priv *priv);
-bool is_hsr_prp_master(struct net_device *dev);
-int hsr_prp_get_max_mtu(struct hsr_prp_priv *priv);
-
-#endif /* __HSR_DEVICE_H */
diff --git a/net/hsr/hsr_forward.c b/net/hsr/hsr_forward.c
deleted file mode 100644
index ff0d3f9..0000000
--- a/net/hsr/hsr_forward.c
+++ /dev/null
@@ -1,433 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#include "hsr_forward.h"
-#include <linux/types.h>
-#include <linux/skbuff.h>
-#include <linux/etherdevice.h>
-#include <linux/if_vlan.h>
-#include "hsr_main.h"
-#include "hsr_framereg.h"
-
-struct hsr_prp_node;
-
-struct hsr_prp_frame_info {
-	struct sk_buff *skb_std;
-	struct sk_buff *skb_hsr;
-	struct hsr_prp_port *port_rcv;
-	struct hsr_prp_node *node_src;
-	u16 sequence_nr;
-	bool is_supervision;
-	bool is_vlan;
-	bool is_local_dest;
-	bool is_local_exclusive;
-};
-
-/* The uses I can see for these HSR supervision frames are:
- * 1) Use the frames that are sent after node initialization ("HSR_TLV.Type =
- *    22") to reset any sequence_nr counters belonging to that node. Useful if
- *    the other node's counter has been reset for some reason.
- *    --
- *    Or not - resetting the counter and bridging the frame would create a
- *    loop, unfortunately.
- *
- * 2) Use the LifeCheck frames to detect ring breaks. I.e. if no LifeCheck
- *    frame is received from a particular node, we know something is wrong.
- *    We just register these (as with normal frames) and throw them away.
- *
- * 3) Allow different MAC addresses for the two slave interfaces, using the
- *    MacAddressA field.
- */
-static bool is_supervision_frame(struct hsr_prp_priv *priv, struct sk_buff *skb)
-{
-	struct ethhdr *ethHdr;
-	struct hsr_prp_sup_tag *hsr_sup_tag;
-	struct hsrv1_ethhdr_sp *hsr_v1_hdr;
-
-	WARN_ON_ONCE(!skb_mac_header_was_set(skb));
-	ethHdr = (struct ethhdr *) skb_mac_header(skb);
-
-	/* Correct addr? */
-	if (!ether_addr_equal(ethHdr->h_dest,
-			      priv->sup_multicast_addr))
-		return false;
-
-	/* Correct ether type?. */
-	if (!(ethHdr->h_proto == htons(ETH_P_PRP)
-			|| ethHdr->h_proto == htons(ETH_P_HSR)))
-		return false;
-
-	/* Get the supervision header from correct location. */
-	if (ethHdr->h_proto == htons(ETH_P_HSR)) { /* Okay HSRv1. */
-		hsr_v1_hdr = (struct hsrv1_ethhdr_sp *)skb_mac_header(skb);
-		if (hsr_v1_hdr->hsr.encap_proto != htons(ETH_P_PRP))
-			return false;
-
-		hsr_sup_tag = &hsr_v1_hdr->hsr_sup;
-	} else {
-		hsr_sup_tag = &((struct hsrv0_ethhdr_sp *)
-				skb_mac_header(skb))->hsr_sup;
-	}
-
-	if ((hsr_sup_tag->HSR_TLV_type != HSR_TLV_ANNOUNCE) &&
-	    (hsr_sup_tag->HSR_TLV_type != HSR_TLV_LIFE_CHECK))
-		return false;
-
-	if ((hsr_sup_tag->HSR_TLV_length != 12) &&
-	    (hsr_sup_tag->HSR_TLV_length != sizeof(struct hsr_prp_sup_payload)))
-		return false;
-
-	return true;
-}
-
-static struct sk_buff *create_stripped_skb(struct sk_buff *skb_in,
-					   struct hsr_prp_frame_info *frame)
-{
-	struct sk_buff *skb;
-	int copylen;
-	unsigned char *dst, *src;
-
-	skb_pull(skb_in, HSR_PRP_HLEN);
-	skb = __pskb_copy(skb_in,
-			  skb_headroom(skb_in) - HSR_PRP_HLEN, GFP_ATOMIC);
-	skb_push(skb_in, HSR_PRP_HLEN);
-	if (!skb)
-		return NULL;
-
-	skb_reset_mac_header(skb);
-
-	if (skb->ip_summed == CHECKSUM_PARTIAL)
-		skb->csum_start -= HSR_PRP_HLEN;
-
-	copylen = 2*ETH_ALEN;
-	if (frame->is_vlan)
-		copylen += VLAN_HLEN;
-	src = skb_mac_header(skb_in);
-	dst = skb_mac_header(skb);
-	memcpy(dst, src, copylen);
-
-	skb->protocol = eth_hdr(skb)->h_proto;
-	return skb;
-}
-
-static struct sk_buff *frame_get_stripped_skb(struct hsr_prp_frame_info *frame,
-					      struct hsr_prp_port *port)
-{
-	if (!frame->skb_std)
-		frame->skb_std = create_stripped_skb(frame->skb_hsr, frame);
-	return skb_clone(frame->skb_std, GFP_ATOMIC);
-}
-
-
-static void hsr_fill_tag(struct sk_buff *skb, struct hsr_prp_frame_info *frame,
-			 struct hsr_prp_port *port, u8 proto_version)
-{
-	struct hsr_ethhdr *hsr_ethhdr;
-	int lane_id;
-	int lsdu_size;
-
-	if (port->type == HSR_PRP_PT_SLAVE_A)
-		lane_id = 0;
-	else
-		lane_id = 1;
-
-	lsdu_size = skb->len - 14;
-	if (frame->is_vlan)
-		lsdu_size -= 4;
-
-	hsr_ethhdr = (struct hsr_ethhdr *) skb_mac_header(skb);
-
-	set_hsr_tag_path(&hsr_ethhdr->hsr_tag, lane_id);
-	set_hsr_tag_LSDU_size(&hsr_ethhdr->hsr_tag, lsdu_size);
-	hsr_ethhdr->hsr_tag.sequence_nr = htons(frame->sequence_nr);
-	hsr_ethhdr->hsr_tag.encap_proto = hsr_ethhdr->ethhdr.h_proto;
-	hsr_ethhdr->ethhdr.h_proto = htons(proto_version ?
-			ETH_P_HSR : ETH_P_PRP);
-}
-
-static struct sk_buff *create_tagged_skb(struct sk_buff *skb_o,
-					 struct hsr_prp_frame_info *frame,
-					 struct hsr_prp_port *port)
-{
-	int movelen;
-	unsigned char *dst, *src;
-	struct sk_buff *skb;
-
-	/* Create the new skb with enough headroom to fit the HSR tag */
-	skb = __pskb_copy(skb_o, skb_headroom(skb_o) + HSR_PRP_HLEN,
-			  GFP_ATOMIC);
-	if (skb == NULL)
-		return NULL;
-	skb_reset_mac_header(skb);
-
-	if (skb->ip_summed == CHECKSUM_PARTIAL)
-		skb->csum_start += HSR_PRP_HLEN;
-
-	movelen = ETH_HLEN;
-	if (frame->is_vlan)
-		movelen += VLAN_HLEN;
-
-	src = skb_mac_header(skb);
-	dst = skb_push(skb, HSR_PRP_HLEN);
-	memmove(dst, src, movelen);
-	skb_reset_mac_header(skb);
-
-	hsr_fill_tag(skb, frame, port, port->priv->prot_version);
-
-	return skb;
-}
-
-/* If the original frame was an HSR tagged frame, just clone it to be sent
- * unchanged. Otherwise, create a private frame especially tagged for 'port'.
- */
-static struct sk_buff *frame_get_tagged_skb(struct hsr_prp_frame_info *frame,
-					    struct hsr_prp_port *port)
-{
-	if (frame->skb_hsr)
-		return skb_clone(frame->skb_hsr, GFP_ATOMIC);
-
-	if ((port->type != HSR_PRP_PT_SLAVE_A) &&
-	    (port->type != HSR_PRP_PT_SLAVE_B)) {
-		WARN_ONCE(1,
-			  "Bug: creating a tagged frame for a non slave port");
-		return NULL;
-	}
-
-	return create_tagged_skb(frame->skb_std, frame, port);
-}
-
-
-static void hsr_prp_deliver_master(struct sk_buff *skb,
-				   struct hsr_prp_node *node_src,
-				   struct hsr_prp_port *port)
-{
-	struct net_device *dev = port->dev;
-	bool was_multicast_frame;
-	int res;
-
-	was_multicast_frame = (skb->pkt_type == PACKET_MULTICAST);
-	/* For LRE offloaded case, assume same MAC address is on both
-	 * interfaces of the remote node and hence no need to substitute
-	 * the source MAC address.
-	 */
-	if (!port->priv->rx_offloaded)
-		hsr_addr_subst_source(node_src, skb);
-
-	skb_pull(skb, ETH_HLEN);
-	res = netif_rx(skb);
-	if (res == NET_RX_DROP) {
-		dev->stats.rx_dropped++;
-	} else {
-		dev->stats.rx_packets++;
-		dev->stats.rx_bytes += skb->len;
-		if (was_multicast_frame)
-			dev->stats.multicast++;
-	}
-}
-
-static int hsr_prp_xmit(struct sk_buff *skb, struct hsr_prp_port *port,
-			struct hsr_prp_frame_info *frame)
-{
-	if (!port->priv->rx_offloaded &&
-	    frame->port_rcv->type == HSR_PRP_PT_MASTER) {
-		hsr_addr_subst_dest(frame->node_src, skb, port);
-
-		/* Address substitution (IEC62439-3 pp 26, 50): replace mac
-		 * address of outgoing frame with that of the outgoing slave's.
-		 */
-		ether_addr_copy(eth_hdr(skb)->h_source, port->dev->dev_addr);
-	}
-	return dev_queue_xmit(skb);
-}
-
-/* Forward the frame through all devices except:
- * - Back through the receiving device
- * - If it's a HSR frame: through a device where it has passed before
- * - To the local HSR master only if the frame is directly addressed to it, or
- *   a non-supervision multicast or broadcast frame.
- *
- * HSR slave devices should insert a HSR tag into the frame, or forward the
- * frame unchanged if it's already tagged. Interlink devices should strip HSR
- * tags if they're of the non-HSR type (but only after duplicate discard). The
- * master device always strips HSR tags.
- */
-static void hsr_prp_forward_do(struct hsr_prp_frame_info *frame)
-{
-	struct hsr_prp_port *port;
-	struct sk_buff *skb;
-
-	hsr_prp_for_each_port(frame->port_rcv->priv, port) {
-		/* Don't send frame back the way it came */
-		if (port == frame->port_rcv)
-			continue;
-
-		/* Don't deliver locally unless we should */
-		if ((port->type == HSR_PRP_PT_MASTER) && !frame->is_local_dest)
-			continue;
-
-		/* Deliver frames directly addressed to us to master only */
-		if ((port->type != HSR_PRP_PT_MASTER) &&
-		    frame->is_local_exclusive)
-			continue;
-
-		/* Don't send frame over port where it has been sent before
-		 * if not rx offloaded
-		 */
-		if (!port->priv->rx_offloaded &&
-		    hsr_register_frame_out(port, frame->node_src,
-					   frame->sequence_nr))
-			continue;
-
-		/* In LRE offloaded case, don't expect supervision frames from
-		 * slave ports for host as they get processed at the h/w or
-		 * firmware
-		 */
-		if (frame->is_supervision &&
-		    (port->type == HSR_PRP_PT_MASTER) &&
-		    (!port->priv->rx_offloaded)) {
-			hsr_prp_handle_sup_frame(frame->skb_hsr,
-						 frame->node_src,
-						 frame->port_rcv);
-			continue;
-		}
-
-		/* if L2 forward is offloaded, don't forward frame
-		 * across slaves
-		 */
-		if (port->priv->l2_fwd_offloaded &&
-		    (((frame->port_rcv->type == HSR_PRP_PT_SLAVE_A) &&
-		    (port->type ==  HSR_PRP_PT_SLAVE_B)) ||
-		    ((frame->port_rcv->type == HSR_PRP_PT_SLAVE_B) &&
-		    (port->type ==  HSR_PRP_PT_SLAVE_A))))
-			continue;
-
-		if (port->type != HSR_PRP_PT_MASTER)
-			skb = frame_get_tagged_skb(frame, port);
-		else
-			skb = frame_get_stripped_skb(frame, port);
-
-		/* FIXME: Record the dropped frame? */
-		if (!skb)
-			continue;
-
-		skb->dev = port->dev;
-		if (port->type == HSR_PRP_PT_MASTER)
-			hsr_prp_deliver_master(skb, frame->node_src, port);
-		else
-			hsr_prp_xmit(skb, port, frame);
-	}
-}
-
-static void check_local_dest(struct hsr_prp_priv *priv, struct sk_buff *skb,
-			     struct hsr_prp_frame_info *frame)
-{
-	if (hsr_prp_addr_is_self(priv, eth_hdr(skb)->h_dest)) {
-		frame->is_local_exclusive = true;
-		skb->pkt_type = PACKET_HOST;
-	} else {
-		frame->is_local_exclusive = false;
-	}
-
-	if ((skb->pkt_type == PACKET_HOST) ||
-	    (skb->pkt_type == PACKET_MULTICAST) ||
-	    (skb->pkt_type == PACKET_BROADCAST)) {
-		frame->is_local_dest = true;
-	} else {
-		frame->is_local_dest = false;
-	}
-}
-
-static int hsr_prp_fill_frame_info(struct hsr_prp_frame_info *frame,
-				   struct sk_buff *skb,
-				   struct hsr_prp_port *port)
-{
-	struct ethhdr *ethhdr;
-	unsigned long irqflags;
-	struct hsr_prp_priv *priv = port->priv;
-
-	frame->is_supervision = is_supervision_frame(priv, skb);
-	if (frame->is_supervision && priv->rx_offloaded &&
-	    (port->type != HSR_PRP_PT_MASTER)) {
-		WARN_ONCE(1,
-			  "HSR: unexpected rx supervisor frame when offloaded");
-		return -1;
-	}
-
-	/* For Offloaded case, there is no need for node list since
-	 * firmware/hardware implements LRE function.
-	 */
-	if (!priv->rx_offloaded) {
-		frame->node_src = hsr_prp_get_node(&priv->node_db, skb,
-						   frame->is_supervision);
-		/* Unknown node and !is_supervision, or no mem */
-		if (!frame->node_src) {
-			WARN_ONCE(1, "Unknown frame received\n");
-			return -1;
-		}
-	}
-
-	ethhdr = (struct ethhdr *) skb_mac_header(skb);
-	frame->is_vlan = false;
-	if (ethhdr->h_proto == htons(ETH_P_8021Q)) {
-		frame->is_vlan = true;
-		/* FIXME: */
-		WARN_ONCE(1, "HSR: VLAN not yet supported");
-	}
-	if (ethhdr->h_proto == htons(ETH_P_PRP) ||
-	    ethhdr->h_proto == htons(ETH_P_HSR)) {
-		frame->skb_std = NULL;
-		frame->skb_hsr = skb;
-		frame->sequence_nr = hsr_get_skb_sequence_nr(skb);
-	} else {
-		frame->skb_std = skb;
-		frame->skb_hsr = NULL;
-		/* Sequence nr for the master node */
-		spin_lock_irqsave(&priv->seqnr_lock, irqflags);
-		frame->sequence_nr = priv->sequence_nr;
-		priv->sequence_nr++;
-		spin_unlock_irqrestore(&priv->seqnr_lock, irqflags);
-	}
-
-	frame->port_rcv = port;
-	check_local_dest(priv, skb, frame);
-
-	return 0;
-}
-
-/* Must be called holding rcu read lock (because of the port parameter) */
-void hsr_prp_forward_skb(struct sk_buff *skb, struct hsr_prp_port *port)
-{
-	struct hsr_prp_frame_info frame;
-
-	if (skb_mac_header(skb) != skb->data) {
-		WARN_ONCE(1, "%s:%d: Malformed frame (port_src %s)\n",
-			  __FILE__, __LINE__, port->dev->name);
-		goto out_drop;
-	}
-
-	if (hsr_prp_fill_frame_info(&frame, skb, port) < 0)
-		goto out_drop;
-	/* No need to register frame when rx offload is supported */
-	if (!port->priv->rx_offloaded)
-		hsr_register_frame_in(frame.node_src, port, frame.sequence_nr);
-
-	hsr_prp_forward_do(&frame);
-
-	if (frame.skb_hsr != NULL)
-		kfree_skb(frame.skb_hsr);
-	if (frame.skb_std != NULL)
-		kfree_skb(frame.skb_std);
-	return;
-
-out_drop:
-	port->dev->stats.tx_dropped++;
-	kfree_skb(skb);
-}
diff --git a/net/hsr/hsr_forward.h b/net/hsr/hsr_forward.h
deleted file mode 100644
index 2b14b5b..0000000
--- a/net/hsr/hsr_forward.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#ifndef __HSR_FORWARD_H
-#define __HSR_FORWARD_H
-
-#include <linux/netdevice.h>
-#include "hsr_main.h"
-
-void hsr_prp_forward_skb(struct sk_buff *skb, struct hsr_prp_port *port);
-
-#endif /* __HSR_FORWARD_H */
diff --git a/net/hsr/hsr_framereg.c b/net/hsr/hsr_framereg.c
deleted file mode 100644
index 1ef1924..0000000
--- a/net/hsr/hsr_framereg.c
+++ /dev/null
@@ -1,482 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- *
- * The HSR spec says never to forward the same frame twice on the same
- * interface. A frame is identified by its source MAC address and its HSR
- * sequence number. This code keeps track of senders and their sequence numbers
- * to allow filtering of duplicate frames, and to detect HSR ring errors.
- */
-
-#include <linux/if_ether.h>
-#include <linux/etherdevice.h>
-#include <linux/slab.h>
-#include <linux/rculist.h>
-#include "hsr_main.h"
-#include "hsr_framereg.h"
-#include "hsr_netlink.h"
-
-/*	TODO: use hash lists for mac addresses (linux/jhash.h)?    */
-
-
-/* seq_nr_after(a, b) - return true if a is after (higher in sequence than) b,
- * false otherwise.
- */
-static bool seq_nr_after(u16 a, u16 b)
-{
-	/* Remove inconsistency where
-	 * seq_nr_after(a, b) == seq_nr_before(a, b)
-	 */
-	if ((int) b - a == 32768)
-		return false;
-
-	return (((s16) (b - a)) < 0);
-}
-#define seq_nr_before(a, b)		seq_nr_after((b), (a))
-#define seq_nr_after_or_eq(a, b)	(!seq_nr_before((a), (b)))
-#define seq_nr_before_or_eq(a, b)	(!seq_nr_after((a), (b)))
-
-
-bool hsr_prp_addr_is_self(struct hsr_prp_priv *priv, unsigned char *addr)
-{
-	struct hsr_prp_node *node;
-
-	node = list_first_or_null_rcu(&priv->self_node_db, struct hsr_prp_node,
-				      mac_list);
-	if (!node) {
-		WARN_ONCE(1, "HSR: No self node\n");
-		return false;
-	}
-
-	if (ether_addr_equal(addr, node->mac_address_a))
-		return true;
-	if (ether_addr_equal(addr, node->mac_address_b))
-		return true;
-
-	return false;
-}
-
-/* Search for mac entry. Caller must hold rcu read lock.
- */
-static struct hsr_prp_node *
-find_node_by_addr_a(struct list_head *node_db,
-		    const unsigned char addr[ETH_ALEN])
-{
-	struct hsr_prp_node *node;
-
-	list_for_each_entry_rcu(node, node_db, mac_list) {
-		if (ether_addr_equal(node->mac_address_a, addr))
-			return node;
-	}
-
-	return NULL;
-}
-
-
-/* Helper for device init; the self_node_db is used in hsr_rcv() to recognize
- * frames from self that's been looped over the HSR ring.
- */
-int hsr_prp_create_self_node(struct list_head *self_node_db,
-			     unsigned char addr_a[ETH_ALEN],
-			     unsigned char addr_b[ETH_ALEN])
-{
-	struct hsr_prp_node *node, *oldnode;
-
-	node = kmalloc(sizeof(*node), GFP_KERNEL);
-	if (!node)
-		return -ENOMEM;
-
-	ether_addr_copy(node->mac_address_a, addr_a);
-	ether_addr_copy(node->mac_address_b, addr_b);
-
-	rcu_read_lock();
-	oldnode = list_first_or_null_rcu(self_node_db,
-					 struct hsr_prp_node, mac_list);
-	if (oldnode) {
-		list_replace_rcu(&oldnode->mac_list, &node->mac_list);
-		rcu_read_unlock();
-		synchronize_rcu();
-		kfree(oldnode);
-	} else {
-		rcu_read_unlock();
-		list_add_tail_rcu(&node->mac_list, self_node_db);
-	}
-
-	return 0;
-}
-
-/* Allocate an hsr_node and add it to node_db. 'addr' is the node's AddressA;
- * seq_out is used to initialize filtering of outgoing duplicate frames
- * originating from the newly added node.
- */
-struct hsr_prp_node *hsr_prp_add_node(struct list_head *node_db,
-				      unsigned char addr[],
-				      u16 seq_out)
-{
-	struct hsr_prp_node *node;
-	unsigned long now;
-	int i;
-
-	node = kzalloc(sizeof(*node), GFP_ATOMIC);
-	if (!node)
-		return NULL;
-
-	ether_addr_copy(node->mac_address_a, addr);
-
-	/* We are only interested in time diffs here, so use current jiffies
-	 * as initialization. (0 could trigger an spurious ring error warning).
-	 */
-	now = jiffies;
-	for (i = 0; i < HSR_PRP_PT_PORTS; i++)
-		node->time_in[i] = now;
-	for (i = 0; i < HSR_PRP_PT_PORTS; i++)
-		node->seq_out[i] = seq_out;
-
-	list_add_tail_rcu(&node->mac_list, node_db);
-
-	return node;
-}
-
-/* Get the hsr_node from which 'skb' was sent.
- */
-struct hsr_prp_node *hsr_prp_get_node(struct list_head *node_db,
-				      struct sk_buff *skb,
-				      bool is_sup)
-{
-	struct hsr_prp_node *node;
-	struct ethhdr *ethhdr;
-	u16 seq_out;
-
-	if (!skb_mac_header_was_set(skb))
-		return NULL;
-
-	ethhdr = (struct ethhdr *) skb_mac_header(skb);
-
-	list_for_each_entry_rcu(node, node_db, mac_list) {
-		if (ether_addr_equal(node->mac_address_a, ethhdr->h_source))
-			return node;
-		if (ether_addr_equal(node->mac_address_b, ethhdr->h_source))
-			return node;
-	}
-
-	/* Everyone may create a node entry, connected node to a HSR device. */
-	if (ethhdr->h_proto == htons(ETH_P_PRP) ||
-	    ethhdr->h_proto == htons(ETH_P_HSR))
-		/* Use the existing sequence_nr from the tag as starting point
-		 * for filtering duplicate frames.
-		 */
-		seq_out = hsr_get_skb_sequence_nr(skb) - 1;
-	else
-		seq_out = HSR_PRP_SEQNR_START;
-
-	return hsr_prp_add_node(node_db, ethhdr->h_source, seq_out);
-}
-
-/* Use the Supervision frame's info about an eventual mac_address_b for merging
- * nodes that has previously had their mac_address_b registered as a separate
- * node.
- */
-void hsr_prp_handle_sup_frame(struct sk_buff *skb,
-			      struct hsr_prp_node *node_curr,
-			      struct hsr_prp_port *port_rcv)
-{
-	struct ethhdr *ethhdr;
-	struct hsr_prp_node *node_real;
-	struct hsr_prp_sup_payload *hsr_sp;
-	struct list_head *node_db;
-	int i;
-
-	ethhdr = (struct ethhdr *) skb_mac_header(skb);
-
-	/* Leave the ethernet header. */
-	skb_pull(skb, sizeof(struct ethhdr));
-
-	/* And leave the HSR tag. */
-	if (ethhdr->h_proto == htons(ETH_P_HSR))
-		skb_pull(skb, sizeof(struct hsr_tag));
-
-	/* And leave the HSR sup tag. */
-	skb_pull(skb, sizeof(struct hsr_prp_sup_tag));
-
-	hsr_sp = (struct hsr_prp_sup_payload *)skb->data;
-
-	/* Merge node_curr (registered on mac_address_b) into node_real */
-	node_db = &port_rcv->priv->node_db;
-	node_real = find_node_by_addr_a(node_db, hsr_sp->mac_address_a);
-	if (!node_real)
-		/* No frame received from AddrA of this node yet */
-		node_real = hsr_prp_add_node(node_db, hsr_sp->mac_address_a,
-					     HSR_PRP_SEQNR_START - 1);
-	if (!node_real)
-		goto done; /* No mem */
-	if (node_real == node_curr)
-		/* Node has already been merged */
-		goto done;
-
-	ether_addr_copy(node_real->mac_address_b, ethhdr->h_source);
-	for (i = 0; i < HSR_PRP_PT_PORTS; i++) {
-		if (!node_curr->time_in_stale[i] &&
-		    time_after(node_curr->time_in[i], node_real->time_in[i])) {
-			node_real->time_in[i] = node_curr->time_in[i];
-			node_real->time_in_stale[i] = node_curr->time_in_stale[i];
-		}
-		if (seq_nr_after(node_curr->seq_out[i], node_real->seq_out[i]))
-			node_real->seq_out[i] = node_curr->seq_out[i];
-	}
-	node_real->addr_b_port = port_rcv->type;
-
-	list_del_rcu(&node_curr->mac_list);
-	kfree_rcu(node_curr, rcu_head);
-
-done:
-	skb_push(skb, sizeof(struct hsrv1_ethhdr_sp));
-}
-
-/* 'skb' is a frame meant for this host, that is to be passed to upper layers.
- *
- * If the frame was sent by a node's B interface, replace the source
- * address with that node's "official" address (mac_address_a) so that upper
- * layers recognize where it came from.
- */
-void hsr_addr_subst_source(struct hsr_prp_node *node, struct sk_buff *skb)
-{
-	if (!skb_mac_header_was_set(skb)) {
-		WARN_ONCE(1, "%s: Mac header not set\n", __func__);
-		return;
-	}
-
-	memcpy(&eth_hdr(skb)->h_source, node->mac_address_a, ETH_ALEN);
-}
-
-/* 'skb' is a frame meant for another host.
- * 'port' is the outgoing interface
- *
- * Substitute the target (dest) MAC address if necessary, so the it matches the
- * recipient interface MAC address, regardless of whether that is the
- * recipient's A or B interface.
- * This is needed to keep the packets flowing through switches that learn on
- * which "side" the different interfaces are.
- */
-void hsr_addr_subst_dest(struct hsr_prp_node *node_src, struct sk_buff *skb,
-			 struct hsr_prp_port *port)
-{
-	struct hsr_prp_node *node_dst;
-
-	if (!skb_mac_header_was_set(skb)) {
-		WARN_ONCE(1, "%s: Mac header not set\n", __func__);
-		return;
-	}
-
-	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
-		return;
-
-	node_dst = find_node_by_addr_a(&port->priv->node_db,
-				       eth_hdr(skb)->h_dest);
-	if (!node_dst) {
-		WARN_ONCE(1, "%s: Unknown node\n", __func__);
-		return;
-	}
-	if (port->type != node_dst->addr_b_port)
-		return;
-
-	if (is_valid_ether_addr(node_dst->mac_address_b))
-		ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->mac_address_b);
-	else
-		WARN_ONCE(1, "%s: mac address B not valid\n", __func__);
-}
-
-void hsr_register_frame_in(struct hsr_prp_node *node,
-			   struct hsr_prp_port *port,
-			   u16 sequence_nr)
-{
-	/* Don't register incoming frames without a valid sequence number. This
-	 * ensures entries of restarted nodes gets pruned so that they can
-	 * re-register and resume communications.
-	 */
-	if (seq_nr_before(sequence_nr, node->seq_out[port->type]))
-		return;
-
-	node->time_in[port->type] = jiffies;
-	node->time_in_stale[port->type] = false;
-}
-
-/* 'skb' is a HSR Ethernet frame (with a HSR tag inserted), with a valid
- * ethhdr->h_source address and skb->mac_header set.
- *
- * Return:
- *	 1 if frame can be shown to have been sent recently on this interface,
- *	 0 otherwise, or
- *	 negative error code on error
- */
-int hsr_register_frame_out(struct hsr_prp_port *port,
-			   struct hsr_prp_node *node,
-			   u16 sequence_nr)
-{
-	if (seq_nr_before_or_eq(sequence_nr, node->seq_out[port->type]))
-		return 1;
-
-	node->seq_out[port->type] = sequence_nr;
-	return 0;
-}
-
-static struct hsr_prp_port *get_late_port(struct hsr_prp_priv *priv,
-					  struct hsr_prp_node *node)
-{
-	if (node->time_in_stale[HSR_PRP_PT_SLAVE_A])
-		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
-	if (node->time_in_stale[HSR_PRP_PT_SLAVE_B])
-		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
-
-	if (time_after(node->time_in[HSR_PRP_PT_SLAVE_B],
-		       node->time_in[HSR_PRP_PT_SLAVE_A] +
-				msecs_to_jiffies(HSR_PRP_MAX_SLAVE_DIFF)))
-		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
-	if (time_after(node->time_in[HSR_PRP_PT_SLAVE_A],
-		       node->time_in[HSR_PRP_PT_SLAVE_B] +
-				msecs_to_jiffies(HSR_PRP_MAX_SLAVE_DIFF)))
-		return hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
-
-	return NULL;
-}
-
-/* Remove stale sequence_nr records. Called by timer every
- * HSR_LIFE_CHECK_INTERVAL (two seconds or so).
- */
-void hsr_prp_prune_nodes(unsigned long data)
-{
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_node *node;
-	struct hsr_prp_port *port;
-	unsigned long timestamp;
-	unsigned long time_a, time_b;
-
-	priv = (struct hsr_prp_priv *)data;
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(node, &priv->node_db, mac_list) {
-		/* Shorthand */
-		time_a = node->time_in[HSR_PRP_PT_SLAVE_A];
-		time_b = node->time_in[HSR_PRP_PT_SLAVE_B];
-
-		/* Check for timestamps old enough to risk wrap-around */
-		if (time_after(jiffies, time_a + MAX_JIFFY_OFFSET / 2))
-			node->time_in_stale[HSR_PRP_PT_SLAVE_A] = true;
-		if (time_after(jiffies, time_b + MAX_JIFFY_OFFSET / 2))
-			node->time_in_stale[HSR_PRP_PT_SLAVE_B] = true;
-
-		/* Get age of newest frame from node.
-		 * At least one time_in is OK here; nodes get pruned long
-		 * before both time_ins can get stale
-		 */
-		timestamp = time_a;
-		if (node->time_in_stale[HSR_PRP_PT_SLAVE_A] ||
-		    (!node->time_in_stale[HSR_PRP_PT_SLAVE_B] &&
-		    time_after(time_b, time_a)))
-			timestamp = time_b;
-
-		/* Warn of ring error only as long as we get frames at all */
-		if (time_is_after_jiffies(timestamp +
-			msecs_to_jiffies(1.5 * HSR_PRP_MAX_SLAVE_DIFF))) {
-			rcu_read_lock();
-			port = get_late_port(priv, node);
-			if (port)
-				hsr_nl_ringerror(priv,
-						 node->mac_address_a, port);
-			rcu_read_unlock();
-		}
-
-		/* Prune old entries */
-		if (time_is_before_jiffies(timestamp +
-			msecs_to_jiffies(HSR_PRP_NODE_FORGET_TIME))) {
-			hsr_nl_nodedown(priv, node->mac_address_a);
-			list_del_rcu(&node->mac_list);
-			/* Note that we need to free this entry later: */
-			kfree_rcu(node, rcu_head);
-		}
-	}
-	rcu_read_unlock();
-}
-
-void *hsr_prp_get_next_node(struct hsr_prp_priv *priv, void *_pos,
-			    unsigned char addr[ETH_ALEN])
-{
-	struct hsr_prp_node *node;
-
-	if (!_pos) {
-		node = list_first_or_null_rcu(&priv->node_db,
-					      struct hsr_prp_node, mac_list);
-		if (node)
-			ether_addr_copy(addr, node->mac_address_a);
-		return node;
-	}
-
-	node = _pos;
-	list_for_each_entry_continue_rcu(node, &priv->node_db, mac_list) {
-		ether_addr_copy(addr, node->mac_address_a);
-		return node;
-	}
-
-	return NULL;
-}
-
-int hsr_prp_get_node_data(struct hsr_prp_priv *priv,
-			  const unsigned char *addr,
-			  unsigned char addr_b[ETH_ALEN],
-			  unsigned int *addr_b_ifindex,
-			  int *if1_age, u16 *if1_seq,
-			  int *if2_age, u16 *if2_seq)
-{
-	struct hsr_prp_node *node;
-	struct hsr_prp_port *port;
-	unsigned long tdiff;
-
-	rcu_read_lock();
-	node = find_node_by_addr_a(&priv->node_db, addr);
-	if (!node) {
-		rcu_read_unlock();
-		return -ENOENT;	/* No such entry */
-	}
-
-	ether_addr_copy(addr_b, node->mac_address_b);
-
-	tdiff = jiffies - node->time_in[HSR_PRP_PT_SLAVE_A];
-	if (node->time_in_stale[HSR_PRP_PT_SLAVE_A])
-		*if1_age = INT_MAX;
-#if HZ <= MSEC_PER_SEC
-	else if (tdiff > msecs_to_jiffies(INT_MAX))
-		*if1_age = INT_MAX;
-#endif
-	else
-		*if1_age = jiffies_to_msecs(tdiff);
-
-	tdiff = jiffies - node->time_in[HSR_PRP_PT_SLAVE_B];
-	if (node->time_in_stale[HSR_PRP_PT_SLAVE_B])
-		*if2_age = INT_MAX;
-#if HZ <= MSEC_PER_SEC
-	else if (tdiff > msecs_to_jiffies(INT_MAX))
-		*if2_age = INT_MAX;
-#endif
-	else
-		*if2_age = jiffies_to_msecs(tdiff);
-
-	/* Present sequence numbers as if they were incoming on interface */
-	*if1_seq = node->seq_out[HSR_PRP_PT_SLAVE_B];
-	*if2_seq = node->seq_out[HSR_PRP_PT_SLAVE_A];
-
-	if (node->addr_b_port != HSR_PRP_PT_NONE) {
-		port = hsr_prp_get_port(priv, node->addr_b_port);
-		*addr_b_ifindex = port->dev->ifindex;
-	} else {
-		*addr_b_ifindex = -1;
-	}
-
-	rcu_read_unlock();
-
-	return 0;
-}
diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
deleted file mode 100644
index caa5792..0000000
--- a/net/hsr/hsr_framereg.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#ifndef __HSR_FRAMEREG_H
-#define __HSR_FRAMEREG_H
-
-#include "hsr_main.h"
-
-struct hsr_prp_node;
-
-struct hsr_prp_node *hsr_prp_add_node(struct list_head *node_db,
-				      unsigned char addr[], u16 seq_out);
-struct hsr_prp_node *hsr_prp_get_node(struct list_head *node_db,
-				      struct sk_buff *skb, bool is_sup);
-void hsr_prp_handle_sup_frame(struct sk_buff *skb,
-			      struct hsr_prp_node *node_curr,
-			      struct hsr_prp_port *port);
-bool hsr_prp_addr_is_self(struct hsr_prp_priv *priv, unsigned char *addr);
-
-void hsr_addr_subst_source(struct hsr_prp_node *node, struct sk_buff *skb);
-void hsr_addr_subst_dest(struct hsr_prp_node *node_src, struct sk_buff *skb,
-			 struct hsr_prp_port *port);
-
-void hsr_register_frame_in(struct hsr_prp_node *node,
-			   struct hsr_prp_port *port, u16 sequence_nr);
-int hsr_register_frame_out(struct hsr_prp_port *port,
-			   struct hsr_prp_node *node,
-			   u16 sequence_nr);
-
-void hsr_prp_prune_nodes(unsigned long data);
-
-int hsr_prp_create_self_node(struct list_head *self_node_db,
-			     unsigned char addr_a[ETH_ALEN],
-			     unsigned char addr_b[ETH_ALEN]);
-
-void *hsr_prp_get_next_node(struct hsr_prp_priv *priv, void *_pos,
-			    unsigned char addr[ETH_ALEN]);
-
-int hsr_prp_get_node_data(struct hsr_prp_priv *priv,
-			  const unsigned char *addr,
-			  unsigned char addr_b[ETH_ALEN],
-			  unsigned int *addr_b_ifindex,
-			  int *if1_age, u16 *if1_seq,
-			  int *if2_age, u16 *if2_seq);
-
-struct hsr_prp_node {
-	struct list_head	mac_list;
-	unsigned char		mac_address_a[ETH_ALEN];
-	unsigned char		mac_address_b[ETH_ALEN];
-	/* Local slave through which AddrB frames are received from this node */
-	enum hsr_prp_port_type	addr_b_port;
-	unsigned long		time_in[HSR_PRP_PT_PORTS];
-	bool			time_in_stale[HSR_PRP_PT_PORTS];
-	u16			seq_out[HSR_PRP_PT_PORTS];
-	struct rcu_head		rcu_head;
-};
-
-#endif /* __HSR_FRAMEREG_H */
diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
deleted file mode 100644
index 9100b25..0000000
--- a/net/hsr/hsr_main.c
+++ /dev/null
@@ -1,134 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#include <linux/netdevice.h>
-#include <linux/rculist.h>
-#include <linux/timer.h>
-#include <linux/etherdevice.h>
-#include "hsr_main.h"
-#include "hsr_device.h"
-#include "hsr_netlink.h"
-#include "hsr_framereg.h"
-#include "hsr_slave.h"
-
-int hsr_prp_netdev_notify(struct notifier_block *nb, unsigned long event,
-			  void *ptr)
-{
-	struct net_device *dev;
-	struct hsr_prp_port *port, *master;
-	struct hsr_prp_priv *priv;
-	int mtu_max;
-	int res;
-
-	dev = netdev_notifier_info_to_dev(ptr);
-	port = hsr_prp_port_get_rtnl(dev);
-	if (port == NULL) {
-		if (!is_hsr_prp_master(dev))
-			return NOTIFY_DONE;	/* Not an HSR device */
-		priv = netdev_priv(dev);
-		port = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-		if (port == NULL) {
-			/* Resend of notification concerning removed device? */
-			return NOTIFY_DONE;
-		}
-	} else {
-		priv = port->priv;
-	}
-
-	switch (event) {
-	case NETDEV_UP:		/* Administrative state DOWN */
-	case NETDEV_DOWN:	/* Administrative state UP */
-	case NETDEV_CHANGE:	/* Link (carrier) state changes */
-		hsr_prp_check_carrier_and_operstate(priv);
-		break;
-	case NETDEV_CHANGEADDR:
-		if (port->type == HSR_PRP_PT_MASTER) {
-			/* This should not happen since there's no
-			 * ndo_set_mac_address() for HSR devices - i.e. not
-			 * supported.
-			 */
-			break;
-		}
-
-		master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-
-		if (port->type == HSR_PRP_PT_SLAVE_A) {
-			ether_addr_copy(master->dev->dev_addr, dev->dev_addr);
-			call_netdevice_notifiers(NETDEV_CHANGEADDR, master->dev);
-		}
-
-		/* Make sure we recognize frames from ourselves in hsr_rcv() */
-		port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
-		res = hsr_prp_create_self_node(&priv->self_node_db,
-					       master->dev->dev_addr,
-					       port ?
-					       port->dev->dev_addr :
-					       master->dev->dev_addr);
-		if (res)
-			netdev_warn(master->dev,
-				    "Could not update HSR node address.\n");
-		break;
-	case NETDEV_CHANGEMTU:
-		if (port->type == HSR_PRP_PT_MASTER)
-			break; /* Handled in ndo_change_mtu() */
-		mtu_max = hsr_prp_get_max_mtu(port->priv);
-		master = hsr_prp_get_port(port->priv, HSR_PRP_PT_MASTER);
-		master->dev->mtu = mtu_max;
-		break;
-	case NETDEV_UNREGISTER:
-		hsr_prp_del_port(port);
-		break;
-	case NETDEV_PRE_TYPE_CHANGE:
-		/* HSR works only on Ethernet devices. Refuse slave to change
-		 * its type.
-		 */
-		return NOTIFY_BAD;
-	}
-
-	return NOTIFY_DONE;
-}
-
-struct hsr_prp_port *hsr_prp_get_port(struct hsr_prp_priv *priv,
-				      enum hsr_prp_port_type pt)
-{
-	struct hsr_prp_port *port;
-
-	hsr_prp_for_each_port(priv, port)
-		if (port->type == pt)
-			return port;
-	return NULL;
-}
-
-static struct notifier_block hsr_nb = {
-	.notifier_call = hsr_prp_netdev_notify,	/* Slave event notifications */
-};
-
-static int __init hsr_init(void)
-{
-	int res;
-
-	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_PRP_HLEN);
-
-	register_netdevice_notifier(&hsr_nb);
-	res = hsr_netlink_init();
-
-	return res;
-}
-
-static void __exit hsr_exit(void)
-{
-	unregister_netdevice_notifier(&hsr_nb);
-	hsr_netlink_exit();
-}
-
-module_init(hsr_init);
-module_exit(hsr_exit);
-MODULE_LICENSE("GPL");
diff --git a/net/hsr/hsr_main.h b/net/hsr/hsr_main.h
deleted file mode 100644
index b1669c4..0000000
--- a/net/hsr/hsr_main.h
+++ /dev/null
@@ -1,213 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#ifndef __HSR_PRIVATE_H
-#define __HSR_PRIVATE_H
-
-#include <linux/netdevice.h>
-#include <linux/list.h>
-
-
-/* Time constants as specified in the HSR specification (IEC-62439-3 2010)
- * Table 8.
- * All values in milliseconds.
- */
-#define HSR_PRP_LIFE_CHECK_INTERVAL              2000 /* ms */
-#define HSR_PRP_NODE_FORGET_TIME                60000 /* ms */
-#define HSR_PRP_ANNOUNCE_INTERVAL                 100 /* ms */
-
-/* By how much may slave1 and slave2 timestamps of latest received frame from
- * each node differ before we notify of communication problem?
- */
-#define HSR_PRP_MAX_SLAVE_DIFF			 3000 /* ms */
-#define HSR_PRP_SEQNR_START			(USHRT_MAX - 1024)
-#define HSR_PRP_SUP_SEQNR_START		(HSR_PRP_SEQNR_START / 2)
-/* How often shall we check for broken ring and remove node entries older than
- * HSR_NODE_FORGET_TIME?
- */
-#define HSR_PRP_PRUNE_PERIOD			 3000 /* ms */
-
-#define HSR_TLV_ANNOUNCE		   22
-#define HSR_TLV_LIFE_CHECK		   23
-
-/* HSR Tag.
- * As defined in IEC-62439-3:2010, the HSR tag is really { ethertype = 0x88FB,
- * path, LSDU_size, sequence Nr }. But we let eth_header() create { h_dest,
- * h_source, h_proto = 0x88FB }, and add { path, LSDU_size, sequence Nr,
- * encapsulated protocol } instead.
- *
- * Field names as defined in the IEC:2010 standard for HSR.
- */
-struct hsr_tag {
-	__be16		path_and_LSDU_size;
-	__be16		sequence_nr;
-	__be16		encap_proto;
-} __packed;
-
-#define HSR_PRP_HLEN	6
-
-#define HSR_V1_SUP_LSDUSIZE		52
-
-/* The helper functions below assumes that 'path' occupies the 4 most
- * significant bits of the 16-bit field shared by 'path' and 'LSDU_size' (or
- * equivalently, the 4 most significant bits of HSR tag byte 14).
- *
- * This is unclear in the IEC specification; its definition of MAC addresses
- * indicates the spec is written with the least significant bit first (to the
- * left). This, however, would mean that the LSDU field would be split in two
- * with the path field in-between, which seems strange. I'm guessing the MAC
- * address definition is in error.
- */
-static inline u16 get_hsr_tag_path(struct hsr_tag *ht)
-{
-	return ntohs(ht->path_and_LSDU_size) >> 12;
-}
-
-static inline u16 get_hsr_tag_LSDU_size(struct hsr_tag *ht)
-{
-	return ntohs(ht->path_and_LSDU_size) & 0x0FFF;
-}
-
-static inline void set_hsr_tag_path(struct hsr_tag *ht, u16 path)
-{
-	ht->path_and_LSDU_size = htons(
-			(ntohs(ht->path_and_LSDU_size) & 0x0FFF) | (path << 12));
-}
-
-static inline void set_hsr_tag_LSDU_size(struct hsr_tag *ht, u16 LSDU_size)
-{
-	ht->path_and_LSDU_size = htons(
-				      (ntohs(ht->path_and_LSDU_size) & 0xF000) |
-				      (LSDU_size & 0x0FFF));
-}
-
-struct hsr_ethhdr {
-	struct ethhdr	ethhdr;
-	struct hsr_tag	hsr_tag;
-} __packed;
-
-
-/* HSR/PRP Supervision Frame data types.
- * Field names as defined in the IEC:2012 standard for HSR.
- */
-struct hsr_prp_sup_tag {
-	__be16		path_and_HSR_Ver;
-	__be16		sequence_nr;
-	__u8		HSR_TLV_type;
-	__u8		HSR_TLV_length;
-} __packed;
-
-struct hsr_prp_sup_payload {
-	unsigned char	mac_address_a[ETH_ALEN];
-} __packed;
-
-static inline u16 get_hsr_stag_path(struct hsr_prp_sup_tag *hst)
-{
-	return get_hsr_tag_path((struct hsr_tag *)hst);
-}
-
-static inline u16 get_hsr_stag_HSR_ver(struct hsr_prp_sup_tag *hst)
-{
-	return get_hsr_tag_LSDU_size((struct hsr_tag *)hst);
-}
-
-static inline void set_hsr_stag_path(struct hsr_prp_sup_tag *hst, u16 path)
-{
-	set_hsr_tag_path((struct hsr_tag *)hst, path);
-}
-
-static inline void set_hsr_stag_HSR_ver(struct hsr_prp_sup_tag *hst,
-					u16 HSR_ver)
-{
-	set_hsr_tag_LSDU_size((struct hsr_tag *)hst, HSR_ver);
-}
-
-struct hsrv0_ethhdr_sp {
-	struct ethhdr		ethhdr;
-	struct hsr_prp_sup_tag	hsr_sup;
-} __packed;
-
-struct hsrv1_ethhdr_sp {
-	struct ethhdr		ethhdr;
-	struct hsr_tag		hsr;
-	struct hsr_prp_sup_tag	hsr_sup;
-} __packed;
-
-
-enum hsr_prp_port_type {
-	HSR_PRP_PT_NONE = 0,	/* Must be 0, used by framereg */
-	HSR_PRP_PT_SLAVE_A,
-	HSR_PRP_PT_SLAVE_B,
-	HSR_PRP_PT_INTERLINK,
-	HSR_PRP_PT_MASTER,
-	HSR_PRP_PT_PORTS,	/* This must be the last item in the enum */
-};
-
-struct hsr_prp_port {
-	struct list_head	port_list;
-	struct net_device	*dev;
-	struct hsr_prp_priv	*priv;
-	enum hsr_prp_port_type	type;
-};
-
-struct hsr_prp_priv {
-	struct rcu_head		rcu_head;
-	struct list_head	ports;
-	struct list_head	node_db;	/* Known HSR nodes */
-	struct list_head	self_node_db;	/* MACs of slaves */
-	struct timer_list	announce_timer;	/* Supervision frame dispatch */
-	struct timer_list	prune_timer;
-	bool			rx_offloaded;	/* lre handle in hw */
-	bool			l2_fwd_offloaded; /* L2 forward in hw */
-	int announce_count;
-	u16 sequence_nr;
-	u16 sup_sequence_nr;	/* For HSRv1 separate seq_nr for supervision */
-	u8 prot_version;	/* Indicate if HSRv0 or HSRv1 or PRPv1 */
-	spinlock_t seqnr_lock;	/* locking for sequence_nr */
-	unsigned char		sup_multicast_addr[ETH_ALEN];
-#ifdef	CONFIG_DEBUG_FS
-	struct dentry *node_tbl_root;
-	struct dentry *node_tbl_file;
-#endif
-};
-
-#define hsr_prp_for_each_port(hsr_prp, port) \
-	list_for_each_entry_rcu((port), &(hsr_prp)->ports, port_list)
-
-struct hsr_prp_port *hsr_prp_get_port(struct hsr_prp_priv *hsr_prp,
-				      enum hsr_prp_port_type pt);
-int hsr_prp_netdev_notify(struct notifier_block *nb, unsigned long event,
-			  void *ptr);
-
-/* Caller must ensure skb is a valid HSR frame */
-static inline u16 hsr_get_skb_sequence_nr(struct sk_buff *skb)
-{
-	struct hsr_ethhdr *hsr_ethhdr;
-
-	hsr_ethhdr = (struct hsr_ethhdr *)skb_mac_header(skb);
-
-	return ntohs(hsr_ethhdr->hsr_tag.sequence_nr);
-}
-
-#if IS_ENABLED(CONFIG_DEBUG_FS)
-int hsr_prp_debugfs_init(struct hsr_prp_priv *priv);
-void hsr_prp_debugfs_term(struct hsr_prp_priv *priv);
-#else
-static inline int hsr_prp_debugfs_init(struct hsr_prp_priv *priv)
-{
-	return 0;
-}
-
-static inline void hsr_prp_debugfs_term(struct hsr_prp_priv *priv)
-{}
-#endif
-
-#endif /*  __HSR_PRIVATE_H */
diff --git a/net/hsr/hsr_netlink.c b/net/hsr/hsr_netlink.c
deleted file mode 100644
index 2519107..0000000
--- a/net/hsr/hsr_netlink.c
+++ /dev/null
@@ -1,493 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- *
- * Routines for handling Netlink messages for HSR.
- */
-
-#include "hsr_netlink.h"
-#include <linux/kernel.h>
-#include <net/rtnetlink.h>
-#include <net/genetlink.h>
-#include "hsr_main.h"
-#include "hsr_device.h"
-#include "hsr_framereg.h"
-
-static const struct nla_policy hsr_policy[IFLA_HSR_MAX + 1] = {
-	[IFLA_HSR_SLAVE1]		= { .type = NLA_U32 },
-	[IFLA_HSR_SLAVE2]		= { .type = NLA_U32 },
-	[IFLA_HSR_MULTICAST_SPEC]	= { .type = NLA_U8 },
-	[IFLA_HSR_VERSION]	= { .type = NLA_U8 },
-	[IFLA_HSR_SUPERVISION_ADDR]	= { .len = ETH_ALEN },
-	[IFLA_HSR_SEQ_NR]		= { .type = NLA_U16 },
-};
-
-/* Here, it seems a netdevice has already been allocated for us, and the
- * hsr_dev_setup routine has been executed. Nice!
- */
-static int hsr_newlink(struct net *src_net, struct net_device *dev,
-		       struct nlattr *tb[], struct nlattr *data[])
-{
-	struct net_device *link[2];
-	unsigned char multicast_spec, hsr_version;
-
-	if (!data) {
-		netdev_info(dev, "HSR: No slave devices specified\n");
-		return -EINVAL;
-	}
-	if (!data[IFLA_HSR_SLAVE1]) {
-		netdev_info(dev, "HSR: Slave1 device not specified\n");
-		return -EINVAL;
-	}
-	link[0] = __dev_get_by_index(src_net, nla_get_u32(data[IFLA_HSR_SLAVE1]));
-	if (!data[IFLA_HSR_SLAVE2]) {
-		netdev_info(dev, "HSR: Slave2 device not specified\n");
-		return -EINVAL;
-	}
-	link[1] = __dev_get_by_index(src_net, nla_get_u32(data[IFLA_HSR_SLAVE2]));
-
-	if (!link[0] || !link[1])
-		return -ENODEV;
-	if (link[0] == link[1])
-		return -EINVAL;
-
-	if (!data[IFLA_HSR_MULTICAST_SPEC])
-		multicast_spec = 0;
-	else
-		multicast_spec = nla_get_u8(data[IFLA_HSR_MULTICAST_SPEC]);
-
-	if (!data[IFLA_HSR_VERSION])
-		hsr_version = 0;
-	else
-		hsr_version = nla_get_u8(data[IFLA_HSR_VERSION]);
-
-	return hsr_prp_dev_finalize(dev, link, multicast_spec, hsr_version);
-}
-
-static int hsr_fill_info(struct sk_buff *skb, const struct net_device *dev)
-{
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *port;
-	int res;
-
-	priv = netdev_priv(dev);
-
-	res = 0;
-
-	rcu_read_lock();
-	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
-	if (port)
-		res = nla_put_u32(skb, IFLA_HSR_SLAVE1, port->dev->ifindex);
-	rcu_read_unlock();
-	if (res)
-		goto nla_put_failure;
-
-	rcu_read_lock();
-	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
-	if (port)
-		res = nla_put_u32(skb, IFLA_HSR_SLAVE2, port->dev->ifindex);
-	rcu_read_unlock();
-	if (res)
-		goto nla_put_failure;
-
-	if (nla_put(skb, IFLA_HSR_SUPERVISION_ADDR, ETH_ALEN,
-		    priv->sup_multicast_addr) ||
-	    nla_put_u16(skb, IFLA_HSR_SEQ_NR, priv->sequence_nr))
-		goto nla_put_failure;
-
-	return 0;
-
-nla_put_failure:
-	return -EMSGSIZE;
-}
-
-static struct rtnl_link_ops hsr_link_ops __read_mostly = {
-	.kind		= "hsr",
-	.maxtype	= IFLA_HSR_MAX,
-	.policy		= hsr_policy,
-	.priv_size	= sizeof(struct hsr_prp_priv),
-	.setup		= hsr_prp_dev_setup,
-	.newlink	= hsr_newlink,
-	.fill_info	= hsr_fill_info,
-};
-
-/* attribute policy */
-static const struct nla_policy hsr_genl_policy[HSR_A_MAX + 1] = {
-	[HSR_A_NODE_ADDR] = { .len = ETH_ALEN },
-	[HSR_A_NODE_ADDR_B] = { .len = ETH_ALEN },
-	[HSR_A_IFINDEX] = { .type = NLA_U32 },
-	[HSR_A_IF1_AGE] = { .type = NLA_U32 },
-	[HSR_A_IF2_AGE] = { .type = NLA_U32 },
-	[HSR_A_IF1_SEQ] = { .type = NLA_U16 },
-	[HSR_A_IF2_SEQ] = { .type = NLA_U16 },
-};
-
-static struct genl_family hsr_genl_family = {
-	.id = GENL_ID_GENERATE,
-	.hdrsize = 0,
-	.name = "HSR",
-	.version = 1,
-	.maxattr = HSR_A_MAX,
-};
-
-static const struct genl_multicast_group hsr_mcgrps[] = {
-	{ .name = "hsr-network", },
-};
-
-/* This is called if for some node with MAC address addr, we only get frames
- * over one of the slave interfaces. This would indicate an open network ring
- * (i.e. a link has failed somewhere).
- */
-void hsr_nl_ringerror(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN],
-		      struct hsr_prp_port *port)
-{
-	struct sk_buff *skb;
-	void *msg_head;
-	struct hsr_prp_port *master;
-	int res;
-
-	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
-	if (!skb)
-		goto fail;
-
-	msg_head = genlmsg_put(skb, 0, 0, &hsr_genl_family, 0, HSR_C_RING_ERROR);
-	if (!msg_head)
-		goto nla_put_failure;
-
-	res = nla_put(skb, HSR_A_NODE_ADDR, ETH_ALEN, addr);
-	if (res < 0)
-		goto nla_put_failure;
-
-	res = nla_put_u32(skb, HSR_A_IFINDEX, port->dev->ifindex);
-	if (res < 0)
-		goto nla_put_failure;
-
-	genlmsg_end(skb, msg_head);
-	genlmsg_multicast(&hsr_genl_family, skb, 0, 0, GFP_ATOMIC);
-
-	return;
-
-nla_put_failure:
-	kfree_skb(skb);
-
-fail:
-	rcu_read_lock();
-	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-	netdev_warn(master->dev, "Could not send HSR ring error message\n");
-	rcu_read_unlock();
-}
-
-/* This is called when we haven't heard from the node with MAC address addr for
- * some time (just before the node is removed from the node table/list).
- */
-void hsr_nl_nodedown(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN])
-{
-	struct sk_buff *skb;
-	void *msg_head;
-	struct hsr_prp_port *master;
-	int res;
-
-	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
-	if (!skb)
-		goto fail;
-
-	msg_head = genlmsg_put(skb, 0, 0, &hsr_genl_family, 0, HSR_C_NODE_DOWN);
-	if (!msg_head)
-		goto nla_put_failure;
-
-
-	res = nla_put(skb, HSR_A_NODE_ADDR, ETH_ALEN, addr);
-	if (res < 0)
-		goto nla_put_failure;
-
-	genlmsg_end(skb, msg_head);
-	genlmsg_multicast(&hsr_genl_family, skb, 0, 0, GFP_ATOMIC);
-
-	return;
-
-nla_put_failure:
-	kfree_skb(skb);
-
-fail:
-	rcu_read_lock();
-	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-	netdev_warn(master->dev, "Could not send HSR node down\n");
-	rcu_read_unlock();
-}
-
-/* HSR_C_GET_NODE_STATUS lets userspace query the internal HSR node table
- * about the status of a specific node in the network, defined by its MAC
- * address.
- *
- * Input: hsr ifindex, node mac address
- * Output: hsr ifindex, node mac address (copied from request),
- *	   age of latest frame from node over slave 1, slave 2 [ms]
- */
-static int hsr_get_node_status(struct sk_buff *skb_in, struct genl_info *info)
-{
-	/* For receiving */
-	struct nlattr *na;
-	struct net_device *hsr_dev;
-
-	/* For sending */
-	struct sk_buff *skb_out;
-	void *msg_head;
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *port;
-	unsigned char hsr_node_addr_b[ETH_ALEN];
-	int hsr_node_if1_age;
-	u16 hsr_node_if1_seq;
-	int hsr_node_if2_age;
-	u16 hsr_node_if2_seq;
-	int addr_b_ifindex;
-	int res;
-
-	if (!info)
-		goto invalid;
-
-	na = info->attrs[HSR_A_IFINDEX];
-	if (!na)
-		goto invalid;
-	na = info->attrs[HSR_A_NODE_ADDR];
-	if (!na)
-		goto invalid;
-
-	hsr_dev = __dev_get_by_index(genl_info_net(info),
-					nla_get_u32(info->attrs[HSR_A_IFINDEX]));
-	if (!hsr_dev)
-		goto invalid;
-	if (!is_hsr_prp_master(hsr_dev))
-		goto invalid;
-
-
-	/* Send reply */
-
-	skb_out = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!skb_out) {
-		res = -ENOMEM;
-		goto fail;
-	}
-
-	msg_head = genlmsg_put(skb_out, NETLINK_CB(skb_in).portid,
-				info->snd_seq, &hsr_genl_family, 0,
-				HSR_C_SET_NODE_STATUS);
-	if (!msg_head) {
-		res = -ENOMEM;
-		goto nla_put_failure;
-	}
-
-	res = nla_put_u32(skb_out, HSR_A_IFINDEX, hsr_dev->ifindex);
-	if (res < 0)
-		goto nla_put_failure;
-
-	priv = netdev_priv(hsr_dev);
-	res =
-	hsr_prp_get_node_data(priv,
-			      (unsigned char *)
-			      nla_data(info->attrs[HSR_A_NODE_ADDR]),
-			      hsr_node_addr_b,
-			      &addr_b_ifindex,
-			      &hsr_node_if1_age,
-			      &hsr_node_if1_seq,
-			      &hsr_node_if2_age,
-			      &hsr_node_if2_seq);
-	if (res < 0)
-		goto nla_put_failure;
-
-	res = nla_put(skb_out, HSR_A_NODE_ADDR, ETH_ALEN,
-					nla_data(info->attrs[HSR_A_NODE_ADDR]));
-	if (res < 0)
-		goto nla_put_failure;
-
-	if (addr_b_ifindex > -1) {
-		res = nla_put(skb_out, HSR_A_NODE_ADDR_B, ETH_ALEN,
-								hsr_node_addr_b);
-		if (res < 0)
-			goto nla_put_failure;
-
-		res = nla_put_u32(skb_out, HSR_A_ADDR_B_IFINDEX, addr_b_ifindex);
-		if (res < 0)
-			goto nla_put_failure;
-	}
-
-	res = nla_put_u32(skb_out, HSR_A_IF1_AGE, hsr_node_if1_age);
-	if (res < 0)
-		goto nla_put_failure;
-	res = nla_put_u16(skb_out, HSR_A_IF1_SEQ, hsr_node_if1_seq);
-	if (res < 0)
-		goto nla_put_failure;
-	rcu_read_lock();
-	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
-	if (port)
-		res = nla_put_u32(skb_out, HSR_A_IF1_IFINDEX,
-				  port->dev->ifindex);
-	rcu_read_unlock();
-	if (res < 0)
-		goto nla_put_failure;
-
-	res = nla_put_u32(skb_out, HSR_A_IF2_AGE, hsr_node_if2_age);
-	if (res < 0)
-		goto nla_put_failure;
-	res = nla_put_u16(skb_out, HSR_A_IF2_SEQ, hsr_node_if2_seq);
-	if (res < 0)
-		goto nla_put_failure;
-	rcu_read_lock();
-	port = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
-	if (port)
-		res = nla_put_u32(skb_out, HSR_A_IF2_IFINDEX,
-				  port->dev->ifindex);
-	rcu_read_unlock();
-	if (res < 0)
-		goto nla_put_failure;
-
-	genlmsg_end(skb_out, msg_head);
-	genlmsg_unicast(genl_info_net(info), skb_out, info->snd_portid);
-
-	return 0;
-
-invalid:
-	netlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL);
-	return 0;
-
-nla_put_failure:
-	kfree_skb(skb_out);
-	/* Fall through */
-
-fail:
-	return res;
-}
-
-/* Get a list of MacAddressA of all nodes known to this node (including self).
- */
-static int hsr_get_node_list(struct sk_buff *skb_in, struct genl_info *info)
-{
-	/* For receiving */
-	struct nlattr *na;
-	struct net_device *hsr_dev;
-
-	/* For sending */
-	struct sk_buff *skb_out;
-	void *msg_head;
-	struct hsr_prp_priv *priv;
-	void *pos;
-	unsigned char addr[ETH_ALEN];
-	int res;
-
-	if (!info)
-		goto invalid;
-
-	na = info->attrs[HSR_A_IFINDEX];
-	if (!na)
-		goto invalid;
-
-	hsr_dev = __dev_get_by_index(genl_info_net(info),
-				     nla_get_u32(info->attrs[HSR_A_IFINDEX]));
-	if (!hsr_dev)
-		goto invalid;
-	if (!is_hsr_prp_master(hsr_dev))
-		goto invalid;
-
-
-	/* Send reply */
-
-	skb_out = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!skb_out) {
-		res = -ENOMEM;
-		goto fail;
-	}
-
-	msg_head = genlmsg_put(skb_out, NETLINK_CB(skb_in).portid,
-				info->snd_seq, &hsr_genl_family, 0,
-				HSR_C_SET_NODE_LIST);
-	if (!msg_head) {
-		res = -ENOMEM;
-		goto nla_put_failure;
-	}
-
-	res = nla_put_u32(skb_out, HSR_A_IFINDEX, hsr_dev->ifindex);
-	if (res < 0)
-		goto nla_put_failure;
-
-	priv = netdev_priv(hsr_dev);
-
-	rcu_read_lock();
-	pos = hsr_prp_get_next_node(priv, NULL, addr);
-	while (pos) {
-		res = nla_put(skb_out, HSR_A_NODE_ADDR, ETH_ALEN, addr);
-		if (res < 0) {
-			rcu_read_unlock();
-			goto nla_put_failure;
-		}
-		pos = hsr_prp_get_next_node(priv, pos, addr);
-	}
-	rcu_read_unlock();
-
-	genlmsg_end(skb_out, msg_head);
-	genlmsg_unicast(genl_info_net(info), skb_out, info->snd_portid);
-
-	return 0;
-
-invalid:
-	netlink_ack(skb_in, nlmsg_hdr(skb_in), -EINVAL);
-	return 0;
-
-nla_put_failure:
-	kfree_skb(skb_out);
-	/* Fall through */
-
-fail:
-	return res;
-}
-
-static const struct genl_ops hsr_ops[] = {
-	{
-		.cmd = HSR_C_GET_NODE_STATUS,
-		.flags = 0,
-		.policy = hsr_genl_policy,
-		.doit = hsr_get_node_status,
-		.dumpit = NULL,
-	},
-	{
-		.cmd = HSR_C_GET_NODE_LIST,
-		.flags = 0,
-		.policy = hsr_genl_policy,
-		.doit = hsr_get_node_list,
-		.dumpit = NULL,
-	},
-};
-
-int __init hsr_netlink_init(void)
-{
-	int rc;
-
-	rc = rtnl_link_register(&hsr_link_ops);
-	if (rc)
-		goto fail_rtnl_link_register;
-
-	rc = genl_register_family_with_ops_groups(&hsr_genl_family, hsr_ops,
-						  hsr_mcgrps);
-	if (rc)
-		goto fail_genl_register_family;
-
-	return 0;
-
-fail_genl_register_family:
-	rtnl_link_unregister(&hsr_link_ops);
-fail_rtnl_link_register:
-
-	return rc;
-}
-
-void __exit hsr_netlink_exit(void)
-{
-	genl_unregister_family(&hsr_genl_family);
-	rtnl_link_unregister(&hsr_link_ops);
-}
-
-MODULE_ALIAS_RTNL_LINK("hsr");
diff --git a/net/hsr/hsr_netlink.h b/net/hsr/hsr_netlink.h
deleted file mode 100644
index aed62be..0000000
--- a/net/hsr/hsr_netlink.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#ifndef __HSR_NETLINK_H
-#define __HSR_NETLINK_H
-
-#include <linux/if_ether.h>
-#include <linux/module.h>
-#include <uapi/linux/hsr_netlink.h>
-
-struct hsr_prp_priv;
-struct hsr_prp_port;
-
-int __init hsr_netlink_init(void);
-void __exit hsr_netlink_exit(void);
-
-void hsr_nl_ringerror(struct hsr_prp_priv *hsr, unsigned char addr[ETH_ALEN],
-		      struct hsr_prp_port *port);
-void hsr_nl_nodedown(struct hsr_prp_priv *priv, unsigned char addr[ETH_ALEN]);
-
-#endif /* __HSR_NETLINK_H */
diff --git a/net/hsr/hsr_prp_debugfs.c b/net/hsr/hsr_prp_debugfs.c
deleted file mode 100644
index bb86ea1..0000000
--- a/net/hsr/hsr_prp_debugfs.c
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * hsr_prp_debugfs code
- * Copyright (C) 2017 Texas Instruments Incorporated
- *
- * Author(s):
- *	Murali Karicheri <m-karicheri2@ti.com?
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#include <linux/module.h>
-#include <linux/errno.h>
-#include <linux/debugfs.h>
-#include "hsr_main.h"
-#include "hsr_framereg.h"
-
-static void print_mac_address(struct seq_file *sfp, unsigned char *mac)
-{
-	seq_printf(sfp, "%02x:%02x:%02x:%02x:%02x:%02x:",
-		   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
-}
-/*
- * hsr_prp_node_table_show - Formats and prints node_table entries
- */
-static int
-hsr_prp_node_table_show (struct seq_file *sfp, void *data)
-{
-	struct hsr_prp_priv *priv = (struct hsr_prp_priv *)sfp->private;
-	struct hsr_prp_node *node;
-
-	seq_printf(sfp, "Node Table entries\n");
-	seq_printf(sfp, "MAC-Address-A,   MAC-Address-B, time_in[A], ");
-	seq_printf(sfp, "time_in[B], Address-B port");
-	seq_printf(sfp, "\n");
-	rcu_read_lock();
-	list_for_each_entry_rcu(node, &priv->node_db, mac_list) {
-		/* skip self node */
-		if (hsr_prp_addr_is_self(priv, node->mac_address_a))
-			continue;
-		print_mac_address(sfp, &node->mac_address_a[0]);
-		seq_printf(sfp, " ");
-		print_mac_address(sfp, &node->mac_address_b[0]);
-		seq_printf(sfp, "0x%lx, ", node->time_in[HSR_PRP_PT_SLAVE_A]);
-		seq_printf(sfp, "0x%lx ", node->time_in[HSR_PRP_PT_SLAVE_B]);
-		seq_printf(sfp, "0x%x", node->addr_b_port);
-		seq_printf(sfp, "\n");
-	}
-	rcu_read_unlock();
-	return 0;
-}
-
-/*
- * hsr_prp_node_table_open - Open the node_table file
- *
- * Description:
- * This routine opens a debugfs file node_table of specific hsr device
- */
-static int
-hsr_prp_node_table_open(struct inode *inode, struct file *filp)
-{
-	return single_open(filp, hsr_prp_node_table_show, inode->i_private);
-}
-
-static const struct file_operations hsr_prp_fops = {
-	.owner	= THIS_MODULE,
-	.open	= hsr_prp_node_table_open,
-	.read	= seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-/*
- * hsr_prp_debugfs_init - create hsr-prp node_table file for dumping
- * the node table
- *
- * Description:
- * When debugfs is configured this routine sets up the node_table file per
- * hsr/prp device for dumping the node_table entries
- */
-int hsr_prp_debugfs_init(struct hsr_prp_priv *priv)
-{
-	int rc = -1;
-	struct dentry *de = NULL;
-
-	de = debugfs_create_dir("hsr", NULL);
-	if (!de) {
-		printk("Cannot create hsr-prp debugfs root\n");
-		return rc;
-	}
-
-	priv->node_tbl_root = de;
-
-	de = debugfs_create_file("node_table", S_IFREG|S_IRUGO,
-				priv->node_tbl_root, priv,
-				&hsr_prp_fops);
-	if (!de) {
-		printk("Cannot create hsr-prp node_table directory\n");
-		return rc;
-	}
-	priv->node_tbl_file = de;
-	rc = 0;
-
-	return rc;
-} /* end of hst_prp_debugfs_init */
-
-/*
- * hsr_prp_debugfs_term - Tear down debugfs intrastructure
- *
- * Description:
- * When Debufs is configured this routine removes debugfs file system
- * elements that are specific to hsr-prp
- */
-void
-hsr_prp_debugfs_term(struct hsr_prp_priv *priv)
-{
-	debugfs_remove(priv->node_tbl_file);
-	priv->node_tbl_file = NULL;
-	debugfs_remove(priv->node_tbl_root);
-	priv->node_tbl_root = NULL;
-}
diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
deleted file mode 100644
index 3c8b166..0000000
--- a/net/hsr/hsr_slave.c
+++ /dev/null
@@ -1,201 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#include "hsr_slave.h"
-#include <linux/etherdevice.h>
-#include <linux/if_arp.h>
-#include "hsr_main.h"
-#include "hsr_device.h"
-#include "hsr_forward.h"
-#include "hsr_framereg.h"
-
-static rx_handler_result_t hsr_prp_handle_frame(struct sk_buff **pskb)
-{
-	struct sk_buff *skb = *pskb;
-	struct hsr_prp_port *port;
-	u16 protocol;
-
-	if (!skb_mac_header_was_set(skb)) {
-		WARN_ONCE(1, "%s: skb invalid", __func__);
-		return RX_HANDLER_PASS;
-	}
-
-	rcu_read_lock(); /* hsr->node_db, hsr->ports */
-	port = hsr_prp_port_get_rcu(skb->dev);
-
-	if (hsr_prp_addr_is_self(port->priv, eth_hdr(skb)->h_source)) {
-		/* Directly kill frames sent by ourselves */
-		kfree_skb(skb);
-		goto finish_consume;
-	}
-
-	protocol = eth_hdr(skb)->h_proto;
-	if (protocol != htons(ETH_P_PRP) && protocol != htons(ETH_P_HSR))
-		goto finish_pass;
-
-	skb_push(skb, ETH_HLEN);
-
-	hsr_prp_forward_skb(skb, port);
-
-finish_consume:
-	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
-	return RX_HANDLER_CONSUMED;
-
-finish_pass:
-	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
-	return RX_HANDLER_PASS;
-}
-
-bool hsr_prp_port_exists(const struct net_device *dev)
-{
-	return rcu_access_pointer(dev->rx_handler) == hsr_prp_handle_frame;
-}
-
-static int hsr_prp_check_dev_ok(struct net_device *dev)
-{
-	/* Don't allow HSR on non-ethernet like devices */
-	if ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||
-	    (dev->addr_len != ETH_ALEN)) {
-		netdev_info(dev, "Cannot use loopback or non-ethernet device as HSR slave.\n");
-		return -EINVAL;
-	}
-
-	/* Don't allow enslaving hsr devices */
-	if (is_hsr_prp_master(dev)) {
-		netdev_info(dev, "Cannot create trees of HSR devices.\n");
-		return -EINVAL;
-	}
-
-	if (hsr_prp_port_exists(dev)) {
-		netdev_info(dev, "This device is already a HSR slave.\n");
-		return -EINVAL;
-	}
-
-	if (dev->priv_flags & IFF_802_1Q_VLAN) {
-		netdev_info(dev, "HSR on top of VLAN is not yet supported in this driver.\n");
-		return -EINVAL;
-	}
-
-	if (dev->priv_flags & IFF_DONT_BRIDGE) {
-		netdev_info(dev, "This device does not support bridging.\n");
-		return -EOPNOTSUPP;
-	}
-
-	/* HSR over bonded devices has not been tested, but I'm not sure it
-	 * won't work...
-	 */
-
-	return 0;
-}
-
-
-/* Setup device to be added to the HSR bridge. */
-static int hsr_prp_portdev_setup(struct net_device *dev,
-				 struct hsr_prp_port *port)
-{
-	int res;
-
-	dev_hold(dev);
-	res = dev_set_promiscuity(dev, 1);
-	if (res)
-		goto fail_promiscuity;
-
-	/* FIXME:
-	 * What does net device "adjacency" mean? Should we do
-	 * res = netdev_master_upper_dev_link(port->dev, port->hsr->dev); ?
-	 */
-
-	res = netdev_rx_handler_register(dev, hsr_prp_handle_frame, port);
-	if (res)
-		goto fail_rx_handler;
-	dev_disable_lro(dev);
-
-	return 0;
-
-fail_rx_handler:
-	dev_set_promiscuity(dev, -1);
-fail_promiscuity:
-	dev_put(dev);
-
-	return res;
-}
-
-int hsr_prp_add_port(struct hsr_prp_priv *priv, struct net_device *dev,
-		     enum hsr_prp_port_type type)
-{
-	struct hsr_prp_port *port, *master;
-	int res;
-
-	if (type != HSR_PRP_PT_MASTER) {
-		res = hsr_prp_check_dev_ok(dev);
-		if (res)
-			return res;
-	}
-
-	port = hsr_prp_get_port(priv, type);
-	if (port != NULL)
-		return -EBUSY;	/* This port already exists */
-
-	port = kzalloc(sizeof(*port), GFP_KERNEL);
-	if (port == NULL)
-		return -ENOMEM;
-
-	if (type != HSR_PRP_PT_MASTER) {
-		res = hsr_prp_portdev_setup(dev, port);
-		if (res)
-			goto fail_dev_setup;
-	}
-
-	port->priv = priv;
-	port->dev = dev;
-	port->type = type;
-
-	list_add_tail_rcu(&port->port_list, &priv->ports);
-	synchronize_rcu();
-
-	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-	netdev_update_features(master->dev);
-	dev_set_mtu(master->dev, hsr_prp_get_max_mtu(priv));
-
-	return 0;
-
-fail_dev_setup:
-	kfree(port);
-	return res;
-}
-
-void hsr_prp_del_port(struct hsr_prp_port *port)
-{
-	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *master;
-
-	priv = port->priv;
-	master = hsr_prp_get_port(priv, HSR_PRP_PT_MASTER);
-	list_del_rcu(&port->port_list);
-
-	if (port != master) {
-		if (master != NULL) {
-			netdev_update_features(master->dev);
-			dev_set_mtu(master->dev, hsr_prp_get_max_mtu(priv));
-		}
-		netdev_rx_handler_unregister(port->dev);
-		dev_set_promiscuity(port->dev, -1);
-	}
-
-	/* FIXME?
-	 * netdev_upper_dev_unlink(port->dev, port->priv->dev);
-	 */
-
-	synchronize_rcu();
-
-	if (port != master)
-		dev_put(port->dev);
-}
diff --git a/net/hsr/hsr_slave.h b/net/hsr/hsr_slave.h
deleted file mode 100644
index 09c3e09..0000000
--- a/net/hsr/hsr_slave.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * Author(s):
- *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- */
-
-#ifndef __HSR_SLAVE_H
-#define __HSR_SLAVE_H
-
-#include <linux/skbuff.h>
-#include <linux/netdevice.h>
-#include <linux/rtnetlink.h>
-#include "hsr_main.h"
-
-int hsr_prp_add_port(struct hsr_prp_priv *priv, struct net_device *dev,
-		     enum hsr_prp_port_type pt);
-void hsr_prp_del_port(struct hsr_prp_port *port);
-bool hsr_prp_port_exists(const struct net_device *dev);
-
-static inline struct hsr_prp_port
-*hsr_prp_port_get_rtnl(const struct net_device *dev)
-{
-	ASSERT_RTNL();
-	return hsr_prp_port_exists(dev) ?
-				rtnl_dereference(dev->rx_handler_data) : NULL;
-}
-
-static inline struct hsr_prp_port
-*hsr_prp_port_get_rcu(const struct net_device *dev)
-{
-	return hsr_prp_port_exists(dev) ?
-				rcu_dereference(dev->rx_handler_data) : NULL;
-}
-
-#endif /* __HSR_SLAVE_H */
-- 
1.9.1

