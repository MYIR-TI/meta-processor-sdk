From d46217a0b2a69713d72f9714231eca14685a3411 Mon Sep 17 00:00:00 2001
From: Eric Ruei <e-ruei1@ti.com>
Date: Thu, 29 Mar 2018 09:20:44 -0400
Subject: [PATCH 205/210] net: ethernet: ti: cpts: add pps gpio controls

The following two gpio pins are added for PPS signal output control
- pps_enable gpio: output enable control of the PPS hardware multiplexer
- ref_enable gpio: output control of the PPS reference signal

Those gpios are used to filter out 9 out of 10 pulses during 1PPS and/or
reference signal generation

This patch implements the gpio-based 1PPS output control.
- extract the pps_enable and ref_enable gpio from device tree
- acquire and initialize those gpios
- toggle pps_enable gpio and ref_enable gpio during the corresponding
  signal generation period

note: We still need to keep the corresponding pinctrl operations in this
      release to ensure that CPTS driver works on both platforms with and
      without the GPIO modifications.
      Another patch will be applied to remove the pinctrl operations when
      all platforms have been modified.

Signed-off-by: Eric Ruei <e-ruei1@ti.com>
---
 drivers/net/ethernet/ti/cpts.c | 51 ++++++++++++++++++++++++++++++++++++++----
 drivers/net/ethernet/ti/cpts.h |  5 +++++
 2 files changed, 52 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpts.c b/drivers/net/ethernet/ti/cpts.c
index 6936aa7..8078cda 100644
--- a/drivers/net/ethernet/ti/cpts.c
+++ b/drivers/net/ethernet/ti/cpts.c
@@ -444,6 +444,8 @@ static int cpts_pps_enable(struct cpts *cpts, int on)
 	if (!on)
 		return 0;
 
+	gpio_set_value(cpts->pps_enable_gpio, 1);
+
 	if (cpts->ref_enable == -1) {
 		cpts_pps_start(cpts);
 		cpts_tmr_poll(cpts, false);
@@ -518,6 +520,7 @@ static void cpts_pps_schedule(struct cpts *cpts)
 			cpts->pps_enable = -1;
 			pinctrl_select_state(cpts->pins,
 					     cpts->pin_state_pwm_off);
+			gpio_set_value(cpts->pps_enable_gpio, 0);
 		}
 
 		if (!cpts->ref_enable) {
@@ -891,6 +894,7 @@ static int cpts_of_1pps_parse(struct cpts *cpts, struct device_node *node)
 {
 	struct device_node *np = NULL;
 	struct device_node *np2 = NULL;
+	int gpio, ret;
 
 	np = of_parse_phandle(node, "timers", 0);
 	if (!np) {
@@ -979,6 +983,36 @@ static int cpts_of_1pps_parse(struct cpts *cpts, struct device_node *node)
 		return PTR_ERR(cpts->pin_state_latch_off);
 	}
 
+	gpio = of_get_named_gpio(node, "pps-enable-gpios", 0);
+	if (!gpio_is_valid(gpio)) {
+		dev_err(cpts->dev, "failed to parse pps-enable gpio\n");
+		return gpio;
+	}
+
+	ret = devm_gpio_request(cpts->dev, gpio, "pps-enable-ctrl");
+	if (ret) {
+		dev_err(cpts->dev, "failed to acquire pps-enable gpio\n");
+		return ret;
+	}
+	cpts->pps_enable_gpio = gpio;
+	gpio_direction_output(gpio, 0);
+
+	gpio = of_get_named_gpio(node, "ref-enable-gpios", 0);
+	if (!gpio_is_valid(gpio)) {
+		dev_err(cpts->dev, "failed to parse ref-enable gpio\n");
+		devm_gpio_free(cpts->dev, cpts->pps_enable_gpio);
+		return gpio;
+	}
+
+	ret = devm_gpio_request(cpts->dev, gpio, "ref-enable-ctrl");
+	if (ret) {
+		dev_err(cpts->dev, "failed to acquire ref-enable gpio\n");
+		devm_gpio_free(cpts->dev, cpts->pps_enable_gpio);
+		return ret;
+	}
+	cpts->ref_enable_gpio = gpio;
+	gpio_direction_output(gpio, 0);
+
 	return 0;
 }
 
@@ -1126,6 +1160,7 @@ void cpts_release(struct cpts *cpts)
 	}
 
 #endif
+
 	if (cpts->pps_kworker) {
 		kthread_cancel_delayed_work_sync(&cpts->pps_work);
 		kthread_destroy_worker(cpts->pps_kworker);
@@ -1260,23 +1295,31 @@ static void cpts_tmr_init(struct cpts *cpts)
 static void inline cpts_turn_on_off_1pps_output(struct cpts *cpts, u64 ts)
 {
 	if (ts > 905000000) {
-		if (cpts->pps_enable == 1)
+		if (cpts->pps_enable == 1) {
 			pinctrl_select_state(cpts->pins,
 					     cpts->pin_state_pwm_on);
+			gpio_set_value(cpts->pps_enable_gpio, 0);
+		}
 
-		if (cpts->ref_enable == 1)
+		if (cpts->ref_enable == 1) {
 			pinctrl_select_state(cpts->pins,
 					     cpts->pin_state_ref_on);
+			gpio_set_value(cpts->ref_enable_gpio, 1);
+		}
 
 		pr_debug("1pps on at %llu\n", ts);
 	} else if ((ts < 100000000) && (ts >= 5000000)) {
-		if (cpts->pps_enable == 1)
+		if (cpts->pps_enable == 1) {
 			pinctrl_select_state(cpts->pins,
 					     cpts->pin_state_pwm_off);
+			gpio_set_value(cpts->pps_enable_gpio, 1);
+		}
 
-		if (cpts->ref_enable == 1)
+		if (cpts->ref_enable == 1) {
 			pinctrl_select_state(cpts->pins,
 					     cpts->pin_state_ref_off);
+			gpio_set_value(cpts->ref_enable_gpio, 0);
+		}
 	}
 }
 
diff --git a/drivers/net/ethernet/ti/cpts.h b/drivers/net/ethernet/ti/cpts.h
index dca38c0..7e2c1fc 100644
--- a/drivers/net/ethernet/ti/cpts.h
+++ b/drivers/net/ethernet/ti/cpts.h
@@ -28,6 +28,8 @@
 #include <linux/device.h>
 #include <linux/list.h>
 #include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
 #include <linux/ptp_clock_kernel.h>
 #include <linux/skbuff.h>
 #include <linux/ptp_classify.h>
@@ -164,6 +166,9 @@ struct cpts {
 	struct pinctrl_state *pin_state_latch_off;
 	struct pinctrl_state *pin_state_latch_on;
 
+	int pps_enable_gpio;
+	int ref_enable_gpio;
+
 	int pps_tmr_irqn;
 	int pps_latch_irqn;
 	int bc_clkid;
-- 
1.9.1

