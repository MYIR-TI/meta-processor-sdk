From de5c587e5bbf90944db9b1ff85dd1f80b2b4ea6e Mon Sep 17 00:00:00 2001
From: Eric Ruei <e-ruei1@ti.com>
Date: Thu, 29 Mar 2018 12:03:34 -0400
Subject: [PATCH 208/210] net: ethernet: ti: ptp_bc: add pps output selection
 gpios

A gpio-controlled multiplexer is added to guarantee there will be only
one PPS signal output at any time. Two of the gpio control pins
pps_mux sel0 and pps_mux_sel1 will be maintained by this module.

This patch implements the gpio-based 1PPS output selection:
- extract the pps_mux_sel0 and pps_mux_sel1 gpio from device tree
- acquire and initialize those gpios
- define and use clock type to determine the desired gpio values
- update the ptp_bc_clock_register API to pass the clock type
- update the cpts clock driver to pass clock type while invoking
  ptp_bc_clock_register
- update the prueth (iep) clock driver to pass clock type while
  invoking ptp_bc_clock_register

Signed-off-by: Eric Ruei <e-ruei1@ti.com>
---
 drivers/net/ethernet/ti/cpts.c   |  2 +-
 drivers/net/ethernet/ti/iep.c    |  5 ++-
 drivers/net/ethernet/ti/iep.h    |  1 +
 drivers/net/ethernet/ti/ptp_bc.c | 87 +++++++++++++++++++++++++++++++++++++++-
 drivers/net/ethernet/ti/ptp_bc.h | 12 +++++-
 5 files changed, 101 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpts.c b/drivers/net/ethernet/ti/cpts.c
index 8078cda..4bc19b6 100644
--- a/drivers/net/ethernet/ti/cpts.c
+++ b/drivers/net/ethernet/ti/cpts.c
@@ -821,7 +821,7 @@ int cpts_register(struct cpts *cpts)
 		     HW4_TS_PUSH_EN, control);
 
 	if (cpts->use_1pps)
-		cpts->bc_clkid = ptp_bc_clock_register();
+		cpts->bc_clkid = ptp_bc_clock_register(PTP_BC_CLOCK_TYPE_GMAC);
 
 	pr_info("cpts ptp bc clkid %d\n", cpts->bc_clkid);
 	return 0;
diff --git a/drivers/net/ethernet/ti/iep.c b/drivers/net/ethernet/ti/iep.c
index 1576733..1e3d97c 100644
--- a/drivers/net/ethernet/ti/iep.c
+++ b/drivers/net/ethernet/ti/iep.c
@@ -897,7 +897,9 @@ int iep_register(struct iep *iep)
 	ptp_schedule_worker(iep->ptp_clock, iep->ov_check_period);
 
 	if (iep->bc_pps_sync)
-		iep->bc_clkid = ptp_bc_clock_register();
+		iep->bc_clkid = ptp_bc_clock_register(
+		(iep->pruss_id == 1) ? PTP_BC_CLOCK_TYPE_PRUICSS1 :
+				       PTP_BC_CLOCK_TYPE_PRUICSS2);
 
 	pr_info("iep ptp bc clkid %d\n", iep->bc_clkid);
 	return 0;
@@ -1020,6 +1022,7 @@ struct iep *iep_create(struct device *dev, void __iomem *sram,
 		iep->bc_pps_sync = false;
 
 	iep->bc_clkid = -1;
+	iep->pruss_id = pruss_id;
 
 	/* save cc.mult original value as it can be modified
 	 * by iep_adjfreq().
diff --git a/drivers/net/ethernet/ti/iep.h b/drivers/net/ethernet/ti/iep.h
index 4820e0d..abbb9db 100644
--- a/drivers/net/ethernet/ti/iep.h
+++ b/drivers/net/ethernet/ti/iep.h
@@ -130,6 +130,7 @@ struct iep {
 	u32 latch_enable;
 
 	int bc_clkid;
+	int pruss_id;
 	bool bc_pps_sync;
 	struct pinctrl *pins;
 	struct extts extts[MAX_EXTTS];
diff --git a/drivers/net/ethernet/ti/ptp_bc.c b/drivers/net/ethernet/ti/ptp_bc.c
index 989a1b7..bd93908 100644
--- a/drivers/net/ethernet/ti/ptp_bc.c
+++ b/drivers/net/ethernet/ti/ptp_bc.c
@@ -12,7 +12,11 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
+#include <linux/gpio.h>
 #include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 
 #include "ptp_bc.h"
@@ -24,6 +28,10 @@
 static u32 bc_clk_sync_enabled;
 static spinlock_t bc_sync_lock; /* protects bc var */
 static bool ptp_bc_initialized;
+static int clock_type[MAX_CLKS];
+static int bc_clk_pps_mux_sel0_gpio;
+static int bc_clk_pps_mux_sel1_gpio;
+
 
 static inline int bc_clock_is_registered(int clkid)
 {
@@ -50,6 +58,42 @@ static void ptp_bc_free_clk_id(int clkid)
 		bc_clocks_registered &= ~BIT(clkid);
 }
 
+static void ptp_bc_clock_pps_mux_reset(void)
+{
+	gpio_set_value(bc_clk_pps_mux_sel0_gpio, 0);
+	gpio_set_value(bc_clk_pps_mux_sel1_gpio, 0);
+}
+
+static void ptp_bc_clock_pps_mux_sel(int clkid)
+{
+	if (clkid < 0 || clkid >= MAX_CLKS) {
+		pr_err("ptp_bc_clock_pps_mux_sel: invalid clkid: %d\n", clkid);
+		return;
+	}
+
+	switch (clock_type[clkid]) {
+	case PTP_BC_CLOCK_TYPE_GMAC:
+		gpio_set_value(bc_clk_pps_mux_sel0_gpio, 0);
+		gpio_set_value(bc_clk_pps_mux_sel1_gpio, 0);
+		break;
+
+	case PTP_BC_CLOCK_TYPE_PRUICSS1:
+		gpio_set_value(bc_clk_pps_mux_sel0_gpio, 1);
+		gpio_set_value(bc_clk_pps_mux_sel1_gpio, 0);
+		break;
+
+	case PTP_BC_CLOCK_TYPE_PRUICSS2:
+		gpio_set_value(bc_clk_pps_mux_sel0_gpio, 0);
+		gpio_set_value(bc_clk_pps_mux_sel1_gpio, 1);
+		break;
+
+	default:
+		pr_err("ptp_bc_clock_pps_mux_sel(%d): invalid type: %d\n",
+		       clkid, clock_type[clkid]);
+		break;
+	}
+}
+
 bool ptp_bc_clock_sync_enable(int clkid, int enable)
 {
 	unsigned long flags;
@@ -74,6 +118,7 @@ bool ptp_bc_clock_sync_enable(int clkid, int enable)
 			allow = false;
 		} else {
 			/* request to enable and none is enabled */
+			ptp_bc_clock_pps_mux_sel(clkid);
 			bc_clk_sync_enabled |= BIT(clkid);
 			allow = true;
 		}
@@ -82,6 +127,9 @@ bool ptp_bc_clock_sync_enable(int clkid, int enable)
 		allow = true;
 	}
 
+	if (!bc_clk_sync_enabled)
+		ptp_bc_clock_pps_mux_reset();
+
 	spin_unlock_irqrestore(&bc_sync_lock, flags);
 
 	pr_info("ptp_bc_clk_sync_enable: Req clk=%d, %s, %s. ClkSyncEn(mask): 0x%08x\n",
@@ -94,13 +142,13 @@ bool ptp_bc_clock_sync_enable(int clkid, int enable)
 }
 EXPORT_SYMBOL_GPL(ptp_bc_clock_sync_enable);
 
-int ptp_bc_clock_register(void)
+int ptp_bc_clock_register(int clocktype)
 {
 	unsigned long flags;
 	int id = -1;
 
 	if (!ptp_bc_initialized) {
-		pr_info("ptp_bc error: NOT initialized.\n");
+		pr_err("ptp_bc error: NOT initialized.\n");
 		return -1;
 	}
 
@@ -112,6 +160,8 @@ int ptp_bc_clock_register(void)
 		pr_err("ptp_bc register error: max clocks allowed %d\n",
 		       MAX_CLKS);
 
+	clock_type[id] = clocktype;
+
 	return id;
 }
 EXPORT_SYMBOL_GPL(ptp_bc_clock_register);
@@ -131,9 +181,42 @@ void ptp_bc_clock_unregister(int clkid)
 
 static int ptp_bc_probe(struct platform_device *pdev)
 {
+	struct device_node *np = pdev->dev.of_node;
+	int ret, gpio;
+
 	spin_lock_init(&bc_sync_lock);
 	bc_clk_sync_enabled = 0;
 	bc_clocks_registered = 0;
+	gpio = of_get_named_gpio(np, "pps-sel0-gpios", 0);
+	if (!gpio_is_valid(bc_clk_pps_mux_sel0_gpio)) {
+		dev_err(&pdev->dev, "failed to parse pps-sel0 gpio\n");
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request(&pdev->dev, gpio, "pps-mux-sel0");
+	if (ret) {
+		dev_err(&pdev->dev, "failed to acquire pps-sel0 gpio\n");
+		return ret;
+	}
+	gpio_direction_output(gpio, 0);
+	bc_clk_pps_mux_sel0_gpio = gpio;
+
+	gpio = of_get_named_gpio(np, "pps-sel1-gpios", 0);
+	if (!gpio_is_valid(bc_clk_pps_mux_sel1_gpio)) {
+		dev_err(&pdev->dev, "failed to parse pps-sel1 gpio\n");
+		devm_gpio_free(&pdev->dev, bc_clk_pps_mux_sel0_gpio);
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request(&pdev->dev, gpio, "pps-mux-sel1");
+	if (ret) {
+		dev_err(&pdev->dev, "failed to acquire pps-sel1 gpio\n");
+		devm_gpio_free(&pdev->dev, bc_clk_pps_mux_sel0_gpio);
+		return ret;
+	}
+	gpio_direction_output(gpio, 0);
+	bc_clk_pps_mux_sel1_gpio = gpio;
+
 	ptp_bc_initialized  = true;
 	return 0;
 }
diff --git a/drivers/net/ethernet/ti/ptp_bc.h b/drivers/net/ethernet/ti/ptp_bc.h
index 8d790bc..ed3a0fa 100644
--- a/drivers/net/ethernet/ti/ptp_bc.h
+++ b/drivers/net/ethernet/ti/ptp_bc.h
@@ -15,12 +15,20 @@
 #ifndef _TI_PTP_BC_H_
 #define _TI_PTP_BC_H_
 
+/* PTP_BC_CLOCK_TYPE is used to identify the clock for multiplexer
+ * output selection.
+ * The PTP clock should pass its clock type during clock registration
+ */
+#define PTP_BC_CLOCK_TYPE_GMAC		0
+#define PTP_BC_CLOCK_TYPE_PRUICSS1	1
+#define PTP_BC_CLOCK_TYPE_PRUICSS2	2
+
 #if IS_ENABLED(CONFIG_TI_PTP_BC)
-int ptp_bc_clock_register(void);
+int ptp_bc_clock_register(int clktype);
 void ptp_bc_clock_unregister(int clkid);
 bool ptp_bc_clock_sync_enable(int clkid, int enable);
 #else
-static int ptp_bc_clock_register(void)
+static int ptp_bc_clock_register(int clktype)
 {
 	return -1;
 }
-- 
1.9.1

