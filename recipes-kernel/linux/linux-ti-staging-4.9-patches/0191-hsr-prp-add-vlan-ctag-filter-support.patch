From 8a7b90bd81f32d9a8cdf5ca13723249875f8759f Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Mon, 26 Feb 2018 16:55:41 -0500
Subject: [PATCH 191/195] hsr/prp: add vlan ctag filter support

This patch adds support for vlan ctag based filtering. The underlying
slave Ethenet device may be capable of filtering Ethernet packets based
on VLAN ID. This requires that when the VLAN interface is created over
an hsr/prp interface, it passes the vid information to the associated
slave Ethernet devices so that it updates the hardware filters to
filter Ethernet frames based on VID.

While adding this support, re-structure the code to re-use existing
function, hsr_prp_get_port(), to get slave port for mc and vlan filter
handling instead of iterate over the various ports to find slave
port in the handling code as is done currently.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
---
 net/hsr-prp/hsr_prp_device.c | 120 ++++++++++++++++++++++++++++---------------
 1 file changed, 79 insertions(+), 41 deletions(-)

diff --git a/net/hsr-prp/hsr_prp_device.c b/net/hsr-prp/hsr_prp_device.c
index 7e6d6f6..f4f13f6a 100644
--- a/net/hsr-prp/hsr_prp_device.c
+++ b/net/hsr-prp/hsr_prp_device.c
@@ -196,21 +196,18 @@ static int hsr_prp_dev_open(struct net_device *dev)
 static int hsr_prp_dev_close(struct net_device *dev)
 {
 	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *port;
+	struct hsr_prp_port *port_a, *port_b;
 
 	priv = netdev_priv(dev);
-	hsr_prp_for_each_port(priv, port) {
-		if (port->type == HSR_PRP_PT_MASTER)
-			continue;
-		switch (port->type) {
-		case HSR_PRP_PT_SLAVE_A:
-		case HSR_PRP_PT_SLAVE_B:
-			dev_uc_unsync(port->dev, dev);
-			dev_mc_unsync(port->dev, dev);
-			break;
-		default:
-			break;
-		}
+
+	port_a = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	port_b = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+
+	if (port_a && port_b) {
+		dev_mc_unsync(port_a->dev, dev);
+		dev_uc_unsync(port_a->dev, dev);
+		dev_mc_unsync(port_b->dev, dev);
+		dev_uc_unsync(port_b->dev, dev);
 	}
 
 	return 0;
@@ -432,48 +429,85 @@ static void hsr_prp_dev_destroy(struct net_device *hsr_prp_dev)
 
 static void hsr_prp_ndo_set_rx_mode(struct net_device *dev)
 {
+	struct hsr_prp_port *port_a, *port_b;
 	struct hsr_prp_priv *priv;
-	struct hsr_prp_port *port;
 
 	priv = netdev_priv(dev);
-	hsr_prp_for_each_port(priv, port) {
-		if (port->type == HSR_PRP_PT_MASTER)
-			continue;
-		switch (port->type) {
-		case HSR_PRP_PT_SLAVE_A:
-		case HSR_PRP_PT_SLAVE_B:
-			dev_mc_sync_multiple(port->dev, dev);
-			dev_uc_sync_multiple(port->dev, dev);
-			break;
-		default:
-			break;
-		}
+	port_a = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	port_b = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+
+	if (port_a && port_b) {
+		dev_mc_sync_multiple(port_a->dev, dev);
+		dev_uc_sync_multiple(port_a->dev, dev);
+		dev_mc_sync_multiple(port_b->dev, dev);
+		dev_uc_sync_multiple(port_b->dev, dev);
 	}
 }
 
 static void hsr_prp_change_rx_flags(struct net_device *dev, int change)
 {
-	struct hsr_prp_port *port;
+	struct hsr_prp_port *port_a, *port_b;
 	struct hsr_prp_priv *priv;
 
 	priv = netdev_priv(dev);
-	hsr_prp_for_each_port(priv, port) {
-		if (port->type == HSR_PRP_PT_MASTER)
-			continue;
-		switch (port->type) {
-		case HSR_PRP_PT_SLAVE_A:
-		case HSR_PRP_PT_SLAVE_B:
-			if (change & IFF_ALLMULTI)
-				dev_set_allmulti(port->dev,
-						 dev->flags &
-						 IFF_ALLMULTI ? 1 : -1);
-			break;
-		default:
-			break;
+
+	port_a = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	port_b = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+
+	if (port_a && port_b) {
+		if (change & IFF_ALLMULTI) {
+			dev_set_allmulti(port_a->dev,
+					 dev->flags &
+					 IFF_ALLMULTI ? 1 : -1);
+			dev_set_allmulti(port_b->dev,
+					 dev->flags &
+					 IFF_ALLMULTI ? 1 : -1);
 		}
 	}
 }
 
+static int hsr_prp_add_del_vid(struct hsr_prp_priv *priv, bool add,
+			       __be16 proto, u16 vid)
+{
+	struct hsr_prp_port *port_a, *port_b;
+	int ret = 0;
+
+	port_a = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_A);
+	port_b = hsr_prp_get_port(priv, HSR_PRP_PT_SLAVE_B);
+
+	if (!port_a || !port_b)
+		return -ENODEV;
+
+	if (add) {
+		ret = vlan_vid_add(port_a->dev, proto, vid);
+		if (!ret)
+			ret = vlan_vid_add(port_b->dev, proto, vid);
+	} else {
+		vlan_vid_del(port_a->dev, proto, vid);
+		vlan_vid_del(port_b->dev, proto, vid);
+	}
+
+	return ret;
+}
+
+static int hsr_prp_ndo_vlan_rx_add_vid(struct net_device *dev,
+				       __be16 proto, u16 vid)
+{
+	struct hsr_prp_priv *priv;
+
+	priv = netdev_priv(dev);
+	return hsr_prp_add_del_vid(priv, true, proto, vid);
+}
+
+static int hsr_prp_ndo_vlan_rx_kill_vid(struct net_device *dev,
+					__be16 proto, u16 vid)
+{
+	struct hsr_prp_priv *priv;
+
+	priv = netdev_priv(dev);
+	return hsr_prp_add_del_vid(priv, false, proto, vid);
+}
+
 static const struct net_device_ops hsr_prp_device_ops = {
 	.ndo_change_mtu = hsr_prp_dev_change_mtu,
 	.ndo_open = hsr_prp_dev_open,
@@ -482,6 +516,8 @@ static void hsr_prp_change_rx_flags(struct net_device *dev, int change)
 	.ndo_change_rx_flags = hsr_prp_change_rx_flags,
 	.ndo_fix_features = hsr_prp_fix_features,
 	.ndo_set_rx_mode = hsr_prp_ndo_set_rx_mode,
+	.ndo_vlan_rx_add_vid = hsr_prp_ndo_vlan_rx_add_vid,
+	.ndo_vlan_rx_kill_vid = hsr_prp_ndo_vlan_rx_kill_vid,
 };
 
 static void hsr_prp_dev_setup(struct net_device *ndev, struct device_type *type)
@@ -498,7 +534,8 @@ static void hsr_prp_dev_setup(struct net_device *ndev, struct device_type *type)
 
 	ndev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
 			   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |
-			   NETIF_F_HW_VLAN_CTAG_TX;
+			   NETIF_F_HW_VLAN_CTAG_TX |
+			   NETIF_F_HW_VLAN_CTAG_FILTER;
 
 	ndev->features = ndev->hw_features;
 
@@ -644,6 +681,7 @@ int hsr_prp_dev_finalize(struct net_device *hsr_prp_dev,
 	     (slave[1]->features & NETIF_F_HW_L2FW_DOFFLOAD)))
 		priv->l2_fwd_offloaded = true;
 
+	hsr_prp_dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 	res = register_netdevice(hsr_prp_dev);
 	if (res)
 		goto fail;
-- 
1.9.1

