From 07614d91468695907e17d8f27c7085475abc6296 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Tue, 20 Mar 2018 14:02:57 -0400
Subject: [PATCH 201/203] prueth: hsr/prp: remove the extra 6 bytes in the
 payload

Firmware indicates start_offset flag when tag is removed for HSR or
when RCT is present for PRP, however keeps the length in the buffer
descriptor pkt_info the same. So remove the extra 6 bytes in the
payload by subtracting 6 from the pkt_info.length and passing the
same in skb->len when start_offset flag is set in pkt_info for HSR
and PRP.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
---
 drivers/net/ethernet/ti/prueth.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/ti/prueth.c b/drivers/net/ethernet/ti/prueth.c
index e802774..fa57356 100644
--- a/drivers/net/ethernet/ti/prueth.c
+++ b/drivers/net/ethernet/ti/prueth.c
@@ -1439,7 +1439,15 @@ static int prueth_tx_enqueue(struct prueth_emac *emac, struct sk_buff *skb,
 static void parse_packet_info(struct prueth *prueth, u32 buffer_descriptor,
 			      struct prueth_packet_info *pkt_info)
 {
-	if (PRUETH_HAS_HSR(prueth))
+	/* For HSR, start_offset indicates Tag is stripped and actual
+	 * data starts at an offset of 6 bytes from start of the buffer.
+	 * For PRP, it just mean RCT is present in the data. i.e in
+	 * this case, depending upon LRE_TRANSPARENT_RECEPTION state
+	 * RCT is to be stripped or not before passing data to upper
+	 * layer. Software adjust the skb->len accordingly. TODO Support for
+	 * LRE_TRANSPARENT_RECEPTION set to passRCT is TBD.
+	 */
+	if (PRUETH_HAS_RED(prueth))
 		pkt_info->start_offset = !!(buffer_descriptor &
 					    PRUETH_BD_START_FLAG_MASK);
 	else
@@ -1479,8 +1487,10 @@ static int emac_rx_packet(struct prueth_emac *emac, u16 *bd_rd_ptr,
 	/* OCMC RAM is not cached and read order is not important */
 	void *ocmc_ram = (__force void *)emac->prueth->mem[PRUETH_MEM_OCMC].va;
 	unsigned int actual_pkt_len;
+	u16 start_offset = 0;
 
-	u16 start_offset = (pkt_info.start_offset ? HSR_TAG_SIZE : 0);
+	if (PRUETH_HAS_HSR(prueth))
+		start_offset = (pkt_info.start_offset ? HSR_TAG_SIZE : 0);
 
 	/* the PRU firmware deals mostly in pointers already
 	 * offset into ram, we would like to deal in indexes
@@ -1579,6 +1589,9 @@ static int emac_rx_packet(struct prueth_emac *emac, u16 *bd_rd_ptr,
 		}
 	}
 
+	if (PRUETH_HAS_RED(prueth) && pkt_info.start_offset)
+		pkt_info.length -= HSR_TAG_SIZE;
+
 	if (!pkt_info.sv_frame) {
 		skb_put(skb, pkt_info.length);
 
-- 
1.9.1

