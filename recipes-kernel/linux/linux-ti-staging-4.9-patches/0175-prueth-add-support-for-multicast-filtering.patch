From 245288598dfc9bbed1f3631a07b7cf743fe6850f Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Wed, 14 Feb 2018 13:50:45 -0500
Subject: [PATCH 175/176] prueth: add support for multicast filtering

This patch adds support for multicast filtering in prueth driver for
HSR and PRP Ethernet types. Driver gets mc list from upper layer
through ndo_set_rx_mode() API which walk through the mc list using
netdev_for_each_mc_addr(). For each multicast MAC address, Driver
calculates a hash as follows:-
 - Each MAC address byte is bitwise AND with a user specified mask byte
 - Do an XOR of resulting bytes to get hash value
 - Write 1 to shared memory table corresponding to the hash index to
   enable and 0 to disable

The hash table can have 256 entries. As there can be collision, this is
an imperfect match. Driver also supports allmulti which allows user to
disable MC filtering so that all multicast frames are received. Driver
implements this by disabling the MC filter feature in the PRU. i.e all
multicast frames are passed to the Host.

User enables/disable allmulti as

To enable
ifconfig <iface> allmulti
To disable
ifconfig <iface> -allmulti

There is a bootargs parameter, prussx_mc_mask, added to allow configure
the multicast mask bytes at boot time where x is the pruss id.  This
allows user to specify which bits are to be used for hash calculation.
Additionally the patch adds a debugfs file as below to display the
mc filter table entries.

/sys/kernel/debug/prueth-prp/mc_filter

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
---
 drivers/net/ethernet/ti/hsr_prp_firmware.h | 13 ++++
 drivers/net/ethernet/ti/prueth.c           | 99 ++++++++++++++++++++++++++++++
 drivers/net/ethernet/ti/prueth.h           |  3 +
 drivers/net/ethernet/ti/prueth_dbgfs.c     | 69 +++++++++++++++++++++
 4 files changed, 184 insertions(+)

diff --git a/drivers/net/ethernet/ti/hsr_prp_firmware.h b/drivers/net/ethernet/ti/hsr_prp_firmware.h
index 35fccc1..9860d88 100644
--- a/drivers/net/ethernet/ti/hsr_prp_firmware.h
+++ b/drivers/net/ethernet/ti/hsr_prp_firmware.h
@@ -228,6 +228,19 @@
 #define IEC62439_CONST_TRANSPARENT_RECEPTION_REMOVE_RCT 0x01
 #define IEC62439_CONST_TRANSPARENT_RECEPTION_PASS_RCT   0x02
 
+#define M_MULTICAST_TABLE_SEARCH_OP_CONTROL_BIT         0x2E0
+/* one byte field :
+ * 0 -> multicast filtering disabled
+ * 1 -> multicast filtering enabled
+ */
+#define MULTICAST_FILTER_DISABLED                       0x00
+#define MULTICAST_FILTER_ENABLED                        0x01
+#define MULTICAST_FILTER_MASK                           0x2E4
+#define MULTICAST_FILTER_TABLE                          0x300
+#define MULTICAST_TABLE_SIZE                            256
+#define MULTICAST_FILTER_HOST_RCV_ALLOWED               0x01
+#define MULTICAST_FILTER_HOST_RCV_NOT_ALLOWED           0x00
+
 /* Index array : contiguous 1 byte size entries
  * (max 128 entries + 2 guard values at 0x1E0 (first byte)
  * and 0x262 (last byte)
diff --git a/drivers/net/ethernet/ti/prueth.c b/drivers/net/ethernet/ti/prueth.c
index 312cd84..9c3de12 100644
--- a/drivers/net/ethernet/ti/prueth.c
+++ b/drivers/net/ethernet/ti/prueth.c
@@ -79,6 +79,19 @@
 module_param(pruss2_hsr_mode, int, 0444);
 MODULE_PARM_DESC(pruss2_hsr_mode, "Choose PRUSS2 HSR mode");
 
+#define PRUETH_DEFAULT_MC_MASK "FF:FF:FF:FF:FF:FF"
+static char *pruss0_mc_mask = PRUETH_DEFAULT_MC_MASK;
+module_param(pruss0_mc_mask, charp, 0444);
+MODULE_PARM_DESC(pruss0_mc_mask, "Choose pruss0 MC mask");
+
+static char *pruss1_mc_mask = PRUETH_DEFAULT_MC_MASK;
+module_param(pruss1_mc_mask, charp, 0444);
+MODULE_PARM_DESC(pruss1_mc_mask, "Choose pruss1 MC mask");
+
+static char *pruss2_mc_mask = PRUETH_DEFAULT_MC_MASK;
+module_param(pruss2_mc_mask, charp, 0444);
+MODULE_PARM_DESC(pruss2_mc_mask, "Choose pruss2 MC mask");
+
 static inline u32 prueth_read_reg(struct prueth *prueth,
 				  enum prueth_mem region,
 				  unsigned int reg)
@@ -2943,6 +2956,52 @@ static int emac_ndo_set_features(struct net_device *ndev,
 	return 0;
 }
 
+static u8 get_hash_with_mask(u8 *mac, u8 *mask)
+{
+	int j;
+	u8 hash;
+
+	for (j = 0, hash = 0; j < ETHER_ADDR_LEN; j++)
+		hash ^= (mac[j] & mask[j]);
+
+	return hash;
+}
+
+static void prueth_sw_set_rx_mode(struct prueth_emac *emac)
+{
+	struct prueth *prueth = emac->prueth;
+	struct net_device *ndev = emac->ndev;
+	void __iomem *sram = prueth->mem[PRUETH_MEM_SHARED_RAM].va;
+	struct netdev_hw_addr *ha;
+	u8 hash;
+	int i;
+
+	for (i = 0; i < 6; i++)
+		writeb(prueth->sw_mc_mac_mask[i],
+		       sram + MULTICAST_FILTER_MASK + i);
+
+	if (ndev->flags & IFF_ALLMULTI) {
+		writeb(MULTICAST_FILTER_DISABLED,
+		       sram + M_MULTICAST_TABLE_SEARCH_OP_CONTROL_BIT);
+		return;
+	}
+
+	/* disable all multicast hash table entries */
+	memset_io(sram + MULTICAST_FILTER_TABLE, 0, MULTICAST_TABLE_SIZE);
+
+	writeb(MULTICAST_FILTER_ENABLED,
+	       sram + M_MULTICAST_TABLE_SEARCH_OP_CONTROL_BIT);
+
+	if (netdev_mc_empty(ndev))
+		return;
+
+	netdev_for_each_mc_addr(ha, ndev) {
+		hash = get_hash_with_mask(ha->addr, prueth->sw_mc_mac_mask);
+		writeb(MULTICAST_FILTER_HOST_RCV_ALLOWED,
+		       sram + MULTICAST_FILTER_TABLE + hash);
+	}
+}
+
 /**
  * emac_ndo_set_rx_mode - EMAC set receive mode function
  * @ndev: The EMAC network adapter
@@ -2958,6 +3017,9 @@ static void emac_ndo_set_rx_mode(struct net_device *ndev)
 	void __iomem *sram = prueth->mem[PRUETH_MEM_SHARED_RAM].va;
 	u32 reg, mask;
 
+	if (PRUETH_HAS_RED(prueth))
+		return prueth_sw_set_rx_mode(emac);
+
 	if (PRUETH_HAS_SWITCH(prueth)) {
 		netdev_dbg(ndev,
 			   "%s: promisc mode not supported for switch\n",
@@ -3533,6 +3595,26 @@ static void prueth_netdev_exit(struct prueth *prueth,
 
 static const struct of_device_id prueth_dt_match[];
 
+static void prueth_get_mc_mac_mask(struct prueth *prueth, char *mc_mask)
+{
+	int result = sscanf(mc_mask, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+			    &prueth->sw_mc_mac_mask[0],
+			    &prueth->sw_mc_mac_mask[1],
+			    &prueth->sw_mc_mac_mask[2],
+			    &prueth->sw_mc_mac_mask[3],
+			    &prueth->sw_mc_mac_mask[4],
+			    &prueth->sw_mc_mac_mask[5]);
+
+	if (result == 6)
+		return;
+
+	dev_err(prueth->dev,
+		"Error in prueth mc mask in bootargs %s\n",
+		mc_mask);
+	/* assign default mask */
+	memset(&prueth->sw_mc_mac_mask[0], 0xff, ETH_ALEN);
+}
+
 static int prueth_probe(struct platform_device *pdev)
 {
 	struct prueth *prueth;
@@ -3542,6 +3624,7 @@ static int prueth_probe(struct platform_device *pdev)
 	const struct of_device_id *match;
 	struct pruss *pruss;
 	int pruss_id1, pruss_id2, ethtype1, ethtype2, hsr_mode1, hsr_mode2;
+	char *mc_mask1, *mc_mask2;
 	int i, ret;
 
 	if (!np)
@@ -3614,6 +3697,8 @@ static int prueth_probe(struct platform_device *pdev)
 		ethtype2 = pruss2_ethtype;
 		hsr_mode1 = pruss1_hsr_mode;
 		hsr_mode2 = pruss2_hsr_mode;
+		mc_mask1 = pruss1_mc_mask;
+		mc_mask2 = pruss2_mc_mask;
 	} else {
 		pruss_id1 = PRUSS0;
 		pruss_id2 = PRUSS1;
@@ -3621,18 +3706,32 @@ static int prueth_probe(struct platform_device *pdev)
 		ethtype2 = pruss1_ethtype;
 		hsr_mode1 = pruss0_hsr_mode;
 		hsr_mode2 = pruss1_hsr_mode;
+		mc_mask1 = pruss0_mc_mask;
+		mc_mask2 = pruss1_mc_mask;
 	}
 
 	if (prueth->pruss_id == pruss_id1) {
 		prueth->eth_type = ethtype1;
 		if (PRUETH_HAS_HSR(prueth))
 			prueth->hsr_mode = hsr_mode1;
+		if (PRUETH_HAS_RED(prueth))
+			prueth_get_mc_mac_mask(prueth, mc_mask1);
 	} else {
 		prueth->eth_type = ethtype2;
 		if (PRUETH_HAS_HSR(prueth))
 			prueth->hsr_mode = hsr_mode2;
+		if (PRUETH_HAS_RED(prueth))
+			prueth_get_mc_mac_mask(prueth, mc_mask2);
 	}
 
+	dev_info(dev, "pruss MC Mask %x:%x:%x:%x:%x:%x\n",
+		 prueth->sw_mc_mac_mask[0],
+		 prueth->sw_mc_mac_mask[1],
+		 prueth->sw_mc_mac_mask[2],
+		 prueth->sw_mc_mac_mask[3],
+		 prueth->sw_mc_mac_mask[4],
+		 prueth->sw_mc_mac_mask[5]);
+
 	if (PRUETH_HAS_SWITCH(prueth))
 		prueth->ocmc_ram_size = OCMC_RAM_SIZE_SWITCH;
 	else
diff --git a/drivers/net/ethernet/ti/prueth.h b/drivers/net/ethernet/ti/prueth.h
index 5114aa8..b2de455 100644
--- a/drivers/net/ethernet/ti/prueth.h
+++ b/drivers/net/ethernet/ti/prueth.h
@@ -19,6 +19,7 @@
 #include <linux/hrtimer.h>
 #include <linux/kthread.h>
 #include <linux/pruss.h>
+#include <linux/if_ether.h>
 #include "icss_switch.h"
 #include "icss_time_sync.h"
 
@@ -553,6 +554,7 @@ struct prueth {
 	int pruss_id;
 	size_t ocmc_ram_size;
 	unsigned int eth_type;
+	unsigned char sw_mc_mac_mask[ETH_ALEN];
 	unsigned int hsr_mode;
 	unsigned int emac_configured;
 	unsigned int tbl_check_period;
@@ -572,6 +574,7 @@ struct prueth {
 #ifdef	CONFIG_DEBUG_FS
 	struct dentry *root_dir;
 	struct dentry *node_tbl_file;
+	struct dentry *mc_filter_file;
 	struct dentry *nt_clear_file;
 	struct dentry *hsr_mode_file;
 	struct dentry *dlrmt_file;
diff --git a/drivers/net/ethernet/ti/prueth_dbgfs.c b/drivers/net/ethernet/ti/prueth_dbgfs.c
index bc2a1e0..e976865 100644
--- a/drivers/net/ethernet/ti/prueth_dbgfs.c
+++ b/drivers/net/ethernet/ti/prueth_dbgfs.c
@@ -306,6 +306,65 @@ static void prueth_hsr_prp_node_show(struct seq_file *sfp,
 	.release = single_release,
 };
 
+/* prueth_hsr_prp_mc_filter_show - Formats and prints mc_filter entries
+ */
+static int
+prueth_hsr_prp_mc_filter_show(struct seq_file *sfp, void *data)
+{
+	struct prueth *prueth = (struct prueth *)sfp->private;
+	void __iomem *sram = prueth->mem[PRUETH_MEM_SHARED_RAM].va;
+	u8 val;
+	int i;
+
+	val = readb(sram + M_MULTICAST_TABLE_SEARCH_OP_CONTROL_BIT);
+
+	seq_printf(sfp, "MC Filter : %s", val ? "enabled\n" : "disabled\n");
+	seq_puts(sfp, "MC Mask : ");
+	for (i = 0; i < 6; i++) {
+		val = readb(sram + MULTICAST_FILTER_MASK + i);
+		if (i == 5)
+			seq_printf(sfp, "%x", val);
+		else
+			seq_printf(sfp, "%x:", val);
+	}
+	seq_puts(sfp, "\n");
+
+	val = readb(sram + M_MULTICAST_TABLE_SEARCH_OP_CONTROL_BIT);
+	seq_puts(sfp, "MC Filter table below 1 - Allowed, 0 - Dropped\n");
+
+	if (val) {
+		for (i = 0; i < MULTICAST_TABLE_SIZE; i++) {
+			val = readb(sram + MULTICAST_FILTER_TABLE + i);
+			if (!(i % 16))
+				seq_printf(sfp, "\n%3x: ", i);
+			seq_printf(sfp, "%d ", val);
+		}
+	}
+	seq_puts(sfp, "\n");
+
+	return 0;
+}
+
+/* prueth_hsr_prp_mc_filter_open - Open the mc_filter file
+ *
+ * Description:
+ * This routine opens a debugfs file mc_filter of specific hsr
+ * or prp device
+ */
+static int
+prueth_hsr_prp_mc_filter_open(struct inode *inode, struct file *filp)
+{
+	return single_open(filp, prueth_hsr_prp_mc_filter_show,
+			   inode->i_private);
+}
+
+static const struct file_operations prueth_hsr_prp_mc_filter_fops = {
+	.owner	= THIS_MODULE,
+	.open	= prueth_hsr_prp_mc_filter_open,
+	.read	= seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
 /* prueth_hsr_prp_nt_clear_write - write the user provided value to
  * node_table_clear debugfs file
  */
@@ -705,6 +764,15 @@ int prueth_hsr_prp_debugfs_init(struct prueth *prueth)
 	}
 	prueth->node_tbl_file = de;
 
+	de = debugfs_create_file("mc_filter", S_IFREG | 0444,
+				 prueth->root_dir, prueth,
+				 &prueth_hsr_prp_mc_filter_fops);
+	if (!de) {
+		dev_err(dev, "Cannot create hsr-prp mc_filter file\n");
+		return rc;
+	}
+	prueth->mc_filter_file = de;
+
 	de = debugfs_create_file("node_table_clear", 0644,
 				 prueth->root_dir, prueth,
 				 &prueth_hsr_prp_nt_clear_fops);
@@ -818,6 +886,7 @@ int prueth_hsr_prp_debugfs_init(struct prueth *prueth)
 	debugfs_remove_recursive(prueth->root_dir);
 	prueth->node_tbl_file = NULL;
 	prueth->nt_clear_file = NULL;
+	prueth->mc_filter_file = NULL;
 	prueth->hsr_mode_file = NULL;
 	prueth->dlrmt_file = NULL;
 	prueth->dd_file = NULL;
-- 
1.9.1

