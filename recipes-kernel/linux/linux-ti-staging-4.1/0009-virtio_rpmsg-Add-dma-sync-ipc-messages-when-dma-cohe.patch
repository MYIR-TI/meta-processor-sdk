From 27a13de0b07e65715b01030ee10ac4d14ac7e011 Mon Sep 17 00:00:00 2001
From: Sam Nelson <sam.nelson@ti.com>
Date: Fri, 18 Sep 2015 14:13:36 -0400
Subject: [PATCH 09/12] virtio_rpmsg: Add dma sync ipc messages when dma
 coherency is enabled

- In Keystone 2 devices, if dma coherency is enabled, the
  coherent_alloc buffers will be cached. In this case
  ARM need to write back tx message buffers and
  invalidate rx buffers for doing IPC with remote
  devices.
- Added code to sync the buffers before adding to virtqueue
  and before use by cpu

Signed-off-by: Sam Nelson <sam.nelson@ti.com>
---
 drivers/rpmsg/virtio_rpmsg_bus.c | 44 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/drivers/rpmsg/virtio_rpmsg_bus.c b/drivers/rpmsg/virtio_rpmsg_bus.c
index 5e416a5..fbd34d3 100644
--- a/drivers/rpmsg/virtio_rpmsg_bus.c
+++ b/drivers/rpmsg/virtio_rpmsg_bus.c
@@ -164,6 +164,34 @@ static struct device_attribute rpmsg_dev_attrs[] = {
 	__ATTR_NULL
 };
 
+#ifdef CONFIG_KEYSTONE2_DMA_COHERENT
+static inline void
+rpmsg_sync_for_cpu(struct device *dev, void *msg)
+{
+	/* Sync buffer for cpu access */
+	dma_sync_single_for_cpu(dev, virt_to_dma(dev, msg),
+				RPMSG_BUF_SIZE, DMA_TO_DEVICE);
+}
+
+static inline void
+rpmsg_sync_for_device(struct device *dev, void *msg)
+{
+	/* Sync buffer to give access to remote device */
+	dma_sync_single_for_device(dev, virt_to_dma(dev, msg),
+				   RPMSG_BUF_SIZE, DMA_TO_DEVICE);
+}
+#else
+static inline void
+rpmsg_sync_for_cpu(struct device *dev, struct rpmsg_hdr *msg)
+{
+}
+
+static inline void
+rpmsg_sync_for_device(struct device *dev, struct rpmsg_hdr *msg)
+{
+}
+#endif
+
 /* rpmsg devices and drivers are matched using the service name only */
 static inline int rpmsg_id_match(const struct rpmsg_channel *rpdev,
 				  const struct rpmsg_device_id *id)
@@ -821,6 +849,9 @@ int rpmsg_send_offchannel_raw(struct rpmsg_channel *rpdev, u32 src, u32 dst,
 		}
 	}
 
+	/* Sync buffer for cpu access */
+	rpmsg_sync_for_cpu(dev, (void *)(msg));
+
 	msg->len = len;
 	msg->flags = 0;
 	msg->src = src;
@@ -828,6 +859,9 @@ int rpmsg_send_offchannel_raw(struct rpmsg_channel *rpdev, u32 src, u32 dst,
 	msg->reserved = 0;
 	memcpy(msg->data, data, len);
 
+	/* Sync buffer to give access to remote device */
+	rpmsg_sync_for_device(dev, (void *)(msg));
+
 	dev_dbg(dev, "TX From 0x%x, To 0x%x, Len %d, Flags %d, Reserved %d\n",
 					msg->src, msg->dst, msg->len,
 					msg->flags, msg->reserved);
@@ -883,6 +917,9 @@ static int rpmsg_recv_single(struct virtproc_info *vrp, struct device *dev,
 	struct scatterlist sg;
 	int err;
 
+	/* Sync buffer to receive message */
+	rpmsg_sync_for_cpu(dev, (void *)(msg));
+
 	dev_dbg(dev, "From: 0x%x, To: 0x%x, Len: %d, Flags: %d, Reserved: %d\n",
 					msg->src, msg->dst, msg->len,
 					msg->flags, msg->reserved);
@@ -930,6 +967,9 @@ static int rpmsg_recv_single(struct virtproc_info *vrp, struct device *dev,
 	/* publish the real size of the buffer */
 	rpmsg_sg_init_one(vrp, &sg, msg, RPMSG_BUF_SIZE);
 
+	/* Sync buffer for remote device to use */
+	rpmsg_sync_for_device(dev, (void *)(msg));
+
 	/* add the buffer back to the remote processor's virtqueue */
 	err = virtqueue_add_inbuf_rpmsg(vrp->rvq, &sg, 1, msg, GFP_KERNEL);
 	if (err < 0) {
@@ -1112,8 +1152,12 @@ static int rpmsg_probe(struct virtio_device *vdev)
 
 		rpmsg_sg_init_one(vrp, &sg, cpu_addr, RPMSG_BUF_SIZE);
 
+		/* Sync buffer for remove device to use */
+		rpmsg_sync_for_device(&vdev->dev, (void *)(&sg));
+
 		err = virtqueue_add_inbuf_rpmsg(vrp->rvq, &sg, 1, cpu_addr,
 						GFP_KERNEL);
+
 		WARN_ON(err); /* sanity check; this can't really happen */
 	}
 
-- 
1.9.1

