From dc9912e19f0bc5be9ebdb305314101ae6d2b60a7 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Thu, 31 Dec 2015 15:17:56 -0500
Subject: [PATCH] soc: ti: add helper functions for use across knav netcp
 drivers

The helper functions that formats the descriptors and access the common
qmss queue related tasks are usable across all of knav netcp drivers.
Some of these such as crypto, srio etc are outside network driver. So
move these into knav_helpers under include/linux/soc/ti so that it can
be included in all of the knav netcp drivers.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
---
 drivers/net/ethernet/ti/netcp_core.c | 127 +++++++----------------------------
 include/linux/soc/ti/knav_helpers.h  | 106 +++++++++++++++++++++++++++++
 2 files changed, 130 insertions(+), 103 deletions(-)
 create mode 100644 include/linux/soc/ti/knav_helpers.h

diff --git a/drivers/net/ethernet/ti/netcp_core.c b/drivers/net/ethernet/ti/netcp_core.c
index 035e233..4ec6839 100644
--- a/drivers/net/ethernet/ti/netcp_core.c
+++ b/drivers/net/ethernet/ti/netcp_core.c
@@ -28,6 +28,7 @@
 #include <linux/platform_device.h>
 #include <linux/soc/ti/knav_qmss.h>
 #include <linux/soc/ti/knav_dma.h>
+#include <linux/soc/ti/knav_helpers.h>
 
 #include "netcp.h"
 
@@ -53,20 +54,6 @@
 
 #define NETCP_EFUSE_ADDR_SWAP	2
 
-#define knav_queue_get_id(q)	knav_queue_device_control(q, \
-				KNAV_QUEUE_GET_ID, (unsigned long)NULL)
-
-#define knav_queue_enable_notify(q) knav_queue_device_control(q,	\
-					KNAV_QUEUE_ENABLE_NOTIFY,	\
-					(unsigned long)NULL)
-
-#define knav_queue_disable_notify(q) knav_queue_device_control(q,	\
-					KNAV_QUEUE_DISABLE_NOTIFY,	\
-					(unsigned long)NULL)
-
-#define knav_queue_get_count(q)	knav_queue_device_control(q, \
-				KNAV_QUEUE_GET_COUNT, (unsigned long)NULL)
-
 #define for_each_netcp_module(module)			\
 	list_for_each_entry(module, &netcp_modules, module_list)
 
@@ -107,72 +94,6 @@ static int netcp_debug_level = -1;
 module_param(netcp_debug_level, int, 0);
 MODULE_PARM_DESC(netcp_debug_level, "Netcp debug level (NETIF_MSG bits) (0=none,...,16=all)");
 
-/* Helper functions - Get/Set */
-static void get_pkt_info(u32 *buff, u32 *buff_len, u32 *ndesc,
-			 struct knav_dma_desc *desc)
-{
-	*buff_len = desc->buff_len;
-	*buff = desc->buff;
-	*ndesc = desc->next_desc;
-}
-
-static void get_pad_info(u32 *pad0, u32 *pad1, struct knav_dma_desc *desc)
-{
-	*pad0 = desc->pad[0];
-	*pad1 = desc->pad[1];
-}
-
-static void get_org_pkt_info(u32 *buff, u32 *buff_len,
-			     struct knav_dma_desc *desc)
-{
-	*buff = desc->orig_buff;
-	*buff_len = desc->orig_len;
-}
-
-static void get_words(u32 *words, int num_words, u32 *desc)
-{
-	int i;
-
-	for (i = 0; i < num_words; i++)
-		words[i] = desc[i];
-}
-
-static void set_pkt_info(u32 buff, u32 buff_len, u32 ndesc,
-			 struct knav_dma_desc *desc)
-{
-	desc->buff_len = buff_len;
-	desc->buff = buff;
-	desc->next_desc = ndesc;
-}
-
-static void set_desc_info(u32 desc_info, u32 pkt_info,
-			  struct knav_dma_desc *desc)
-{
-	desc->desc_info = desc_info;
-	desc->packet_info = pkt_info;
-}
-
-static void set_pad_info(u32 pad0, u32 pad1, struct knav_dma_desc *desc)
-{
-	desc->pad[0] = pad0;
-	desc->pad[1] = pad1;
-}
-
-static void set_org_pkt_info(u32 buff, u32 buff_len,
-			     struct knav_dma_desc *desc)
-{
-	desc->orig_buff = buff;
-	desc->orig_len = buff_len;
-}
-
-static void set_words(u32 *words, int num_words, u32 *desc)
-{
-	int i;
-
-	for (i = 0; i < num_words; i++)
-		desc[i] = words[i];
-}
-
 /* Read the e-fuse value as 32 bit values to be endian independent */
 static int emac_arch_get_mac_addr(char *x, void __iomem *efuse_mac, u32 swap)
 {
@@ -571,7 +492,7 @@ static void netcp_free_rx_desc_chain(struct netcp_intf *netcp,
 	void *buf_ptr;
 	u32 tmp;
 
-	get_words(&dma_desc, 1, &desc->next_desc);
+	knav_dma_get_words(&dma_desc, 1, &desc->next_desc);
 
 	while (dma_desc) {
 		ndesc = knav_pool_desc_unmap(netcp->rx_pool, dma_desc, dma_sz);
@@ -579,14 +500,14 @@ static void netcp_free_rx_desc_chain(struct netcp_intf *netcp,
 			dev_err(netcp->ndev_dev, "failed to unmap Rx desc\n");
 			break;
 		}
-		get_pkt_info(&dma_buf, &tmp, &dma_desc, ndesc);
-		get_pad_info((u32 *)&buf_ptr, &tmp, ndesc);
+		knav_dma_get_pkt_info(&dma_buf, &tmp, &dma_desc, ndesc);
+		knav_dma_get_pad_info((u32 *)&buf_ptr, &tmp, ndesc);
 		dma_unmap_page(netcp->dev, dma_buf, PAGE_SIZE, DMA_FROM_DEVICE);
 		__free_page(buf_ptr);
 		knav_pool_desc_put(netcp->rx_pool, desc);
 	}
 
-	get_pad_info((u32 *)&buf_ptr, &buf_len, desc);
+	knav_dma_get_pad_info((u32 *)&buf_ptr, &buf_len, desc);
 	if (buf_ptr)
 		netcp_frag_free(buf_len <= PAGE_SIZE, buf_ptr);
 	knav_pool_desc_put(netcp->rx_pool, desc);
@@ -637,8 +558,8 @@ static int netcp_process_one_rx_packet(struct netcp_intf *netcp)
 		return 0;
 	}
 
-	get_pkt_info(&dma_buff, &buf_len, &dma_desc, desc);
-	get_pad_info((u32 *)&org_buf_ptr, &org_buf_len, desc);
+	knav_dma_get_pkt_info(&dma_buff, &buf_len, &dma_desc, desc);
+	knav_dma_get_pad_info((u32 *)&org_buf_ptr, &org_buf_len, desc);
 
 	if (unlikely(!org_buf_ptr)) {
 		dev_err(netcp->ndev_dev, "NULL bufptr in desc\n");
@@ -670,8 +591,8 @@ static int netcp_process_one_rx_packet(struct netcp_intf *netcp)
 			goto free_desc;
 		}
 
-		get_pkt_info(&dma_buff, &buf_len, &dma_desc, ndesc);
-		get_pad_info((u32 *)&page, &tmp, ndesc);
+		knav_dma_get_pkt_info(&dma_buff, &buf_len, &dma_desc, ndesc);
+		knav_dma_get_pad_info((u32 *)&page, &tmp, ndesc);
 
 		if (likely(dma_buff && buf_len && page)) {
 			dma_unmap_page(netcp->dev, dma_buff, PAGE_SIZE,
@@ -760,8 +681,8 @@ static void netcp_free_rx_buf(struct netcp_intf *netcp, int fdq)
 			continue;
 		}
 
-		get_org_pkt_info(&dma, &buf_len, desc);
-		get_pad_info((u32 *)&buf_ptr, &tmp, desc);
+		knav_get_org_pkt_info(&dma, &buf_len, desc);
+		knav_dma_get_pad_info((u32 *)&buf_ptr, &tmp, desc);
 
 		if (unlikely(!dma)) {
 			dev_err(netcp->ndev_dev, "NULL orig_buff in desc\n");
@@ -865,9 +786,9 @@ static int netcp_allocate_rx_buf(struct netcp_intf *netcp, int fdq)
 	pkt_info |= KNAV_DMA_NUM_PS_WORDS << KNAV_DMA_DESC_PSLEN_SHIFT;
 	pkt_info |= (netcp->rx_queue_id & KNAV_DMA_DESC_RETQ_MASK) <<
 		    KNAV_DMA_DESC_RETQ_SHIFT;
-	set_org_pkt_info(dma, buf_len, hwdesc);
-	set_pad_info(pad[0], pad[1], hwdesc);
-	set_desc_info(desc_info, pkt_info, hwdesc);
+	knav_dma_set_org_pkt_info(dma, buf_len, hwdesc);
+	knav_dma_set_pad_info(pad[0], pad[1], hwdesc);
+	knav_dma_set_desc_info(desc_info, pkt_info, hwdesc);
 
 	/* Push to FDQs */
 	knav_pool_desc_map(netcp->rx_pool, hwdesc, sizeof(*hwdesc), &dma,
@@ -931,7 +852,7 @@ static void netcp_free_tx_desc_chain(struct netcp_intf *netcp,
 	unsigned int buf_len;
 
 	while (ndesc) {
-		get_pkt_info(&dma_buf, &buf_len, &dma_desc, ndesc);
+		knav_dma_get_pkt_info(&dma_buf, &buf_len, &dma_desc, ndesc);
 
 		if (dma_buf && buf_len)
 			dma_unmap_single(netcp->dev, dma_buf, buf_len,
@@ -972,7 +893,7 @@ static int netcp_process_tx_compl_packets(struct netcp_intf *netcp,
 			continue;
 		}
 
-		get_pad_info((u32 *)&skb, &tmp, desc);
+		knav_dma_get_pad_info((u32 *)&skb, &tmp, desc);
 		netcp_free_tx_desc_chain(netcp, desc, dma_sz);
 		if (!skb) {
 			dev_err(netcp->ndev_dev, "No skb in Tx desc\n");
@@ -1044,7 +965,7 @@ netcp_tx_map_skb(struct sk_buff *skb, struct netcp_intf *netcp)
 		return NULL;
 	}
 
-	set_pkt_info(dma_addr, pkt_len, 0, desc);
+	knav_dma_set_pkt_info(dma_addr, pkt_len, 0, desc);
 	if (skb_is_nonlinear(skb)) {
 		prefetchw(skb_shinfo(skb));
 	} else {
@@ -1082,8 +1003,8 @@ netcp_tx_map_skb(struct sk_buff *skb, struct netcp_intf *netcp)
 		pkt_info =
 			(netcp->tx_compl_qid & KNAV_DMA_DESC_RETQ_MASK) <<
 				KNAV_DMA_DESC_RETQ_SHIFT;
-		set_pkt_info(dma_addr, buf_len, 0, ndesc);
-		set_words(&desc_dma, 1, &pdesc->next_desc);
+		knav_dma_set_pkt_info(dma_addr, buf_len, 0, ndesc);
+		knav_dma_set_words(&desc_dma, 1, &pdesc->next_desc);
 		pkt_len += buf_len;
 		if (pdesc != desc)
 			knav_pool_desc_map(netcp->tx_pool, pdesc,
@@ -1104,7 +1025,7 @@ upd_pkt_len:
 	WARN_ON(pkt_len != skb->len);
 
 	pkt_len &= KNAV_DMA_DESC_PKT_LEN_MASK;
-	set_words(&pkt_len, 1, &desc->desc_info);
+	knav_dma_set_words(&pkt_len, 1, &desc->desc_info);
 	return desc;
 
 free_descs:
@@ -1160,7 +1081,7 @@ static int netcp_tx_submit_skb(struct netcp_intf *netcp,
 
 		memmove(p_info.psdata, p_info.psdata + p_info.psdata_len,
 			p_info.psdata_len);
-		set_words(psdata, p_info.psdata_len, psdata);
+		knav_dma_set_words(psdata, p_info.psdata_len, psdata);
 		tmp |= (p_info.psdata_len & KNAV_DMA_DESC_PSLEN_MASK) <<
 			KNAV_DMA_DESC_PSLEN_SHIFT;
 	}
@@ -1174,12 +1095,12 @@ static int netcp_tx_submit_skb(struct netcp_intf *netcp,
 			KNAV_DMA_DESC_PSFLAG_SHIFT);
 	}
 
-	set_words(&tmp, 1, &desc->packet_info);
-	set_words((u32 *)&skb, 1, &desc->pad[0]);
+	knav_dma_set_words(&tmp, 1, &desc->packet_info);
+	knav_dma_set_words((u32 *)&skb, 1, &desc->pad[0]);
 
 	if (tx_pipe->flags & SWITCH_TO_PORT_IN_TAGINFO) {
 		tmp = tx_pipe->switch_to_port;
-		set_words((u32 *)&tmp, 1, &desc->tag_info);
+		knav_dma_set_words((u32 *)&tmp, 1, &desc->tag_info);
 	}
 
 	/* submit packet descriptor */
diff --git a/include/linux/soc/ti/knav_helpers.h b/include/linux/soc/ti/knav_helpers.h
new file mode 100644
index 0000000..c9ce441
--- /dev/null
+++ b/include/linux/soc/ti/knav_helpers.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2015 Texas Instruments Incorporated
+ * Authors:	Murali Karicheri
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SOC_TI_KEYSTONE_NAVIGATOR_HELPERS_H__
+#define __SOC_TI_KEYSTONE_NAVIGATOR_HELPERS_H__
+
+/* Helper functions - Get/Set */
+static inline void knav_dma_get_pkt_info(u32 *buff, u32 *buff_len, u32 *ndesc,
+					 struct knav_dma_desc *desc)
+{
+	*buff_len = desc->buff_len;
+	*buff = desc->buff;
+	*ndesc = desc->next_desc;
+}
+
+static inline void knav_dma_get_desc_info(u32 *desc_info, u32 *pkt_info,
+					  struct knav_dma_desc *desc)
+{
+	*desc_info = desc->desc_info;
+	*pkt_info = desc->packet_info;
+}
+
+static inline void knav_dma_get_pad_info(u32 *pad0, u32 *pad1,
+					 struct knav_dma_desc *desc)
+{
+	*pad0 = desc->pad[0];
+	*pad1 = desc->pad[1];
+}
+
+static inline void knav_get_org_pkt_info(u32 *buff, u32 *buff_len,
+					 struct knav_dma_desc *desc)
+{
+	*buff = desc->orig_buff;
+	*buff_len = desc->orig_len;
+}
+
+static inline void knav_dma_get_words(u32 *words, int num_words, u32 *desc)
+{
+	int i;
+
+	for (i = 0; i < num_words; i++)
+		words[i] = desc[i];
+}
+
+static inline void knav_dma_set_pkt_info(u32 buff, u32 buff_len, u32 ndesc,
+					 struct knav_dma_desc *desc)
+{
+	desc->buff_len = buff_len;
+	desc->buff = buff;
+	desc->next_desc = ndesc;
+}
+
+static inline void knav_dma_set_desc_info(u32 desc_info, u32 pkt_info,
+					  struct knav_dma_desc *desc)
+{
+	desc->desc_info = desc_info;
+	desc->packet_info = pkt_info;
+}
+
+static inline void knav_dma_set_pad_info(u32 pad0, u32 pad1,
+					 struct knav_dma_desc *desc)
+{
+	desc->pad[0] = pad0;
+	desc->pad[1] = pad1;
+}
+
+static inline void knav_dma_set_org_pkt_info(u32 buff, u32 buff_len,
+					     struct knav_dma_desc *desc)
+{
+	desc->orig_buff = buff;
+	desc->orig_len = buff_len;
+}
+
+static inline void knav_dma_set_words(u32 *words, int num_words, u32 *desc)
+{
+	int i;
+
+	for (i = 0; i < num_words; i++)
+		desc[i] = words[i];
+}
+#define knav_queue_get_id(q)	knav_queue_device_control(q, \
+				KNAV_QUEUE_GET_ID, (unsigned long)NULL)
+
+#define knav_queue_enable_notify(q) knav_queue_device_control(q,	\
+					KNAV_QUEUE_ENABLE_NOTIFY,	\
+					(unsigned long)NULL)
+
+#define knav_queue_disable_notify(q) knav_queue_device_control(q,	\
+					KNAV_QUEUE_DISABLE_NOTIFY,	\
+					(unsigned long)NULL)
+
+#define knav_queue_get_count(q)	knav_queue_device_control(q, \
+				KNAV_QUEUE_GET_COUNT, (unsigned long)NULL)
+
+#endif /* __SOC_TI_KEYSTONE_NAVIGATOR_HELPERS_H__ */
-- 
1.9.1

