From c1c063ef533071c4788e4aafba63b303757699a3 Mon Sep 17 00:00:00 2001
From: Sam Nelson <sam.nelson@ti.com>
Date: Mon, 14 Sep 2015 15:58:41 -0400
Subject: [PATCH 06/12] uio-ti-pdrv: Add uio based driver for TI peripheral
 modules

- Provide generic uio driver for TI peripheral modules
- Provides access to peripheral registers and memory sections
- Also ties-in interrupt and clock operations.

Signed-off-by: Sam Nelson <sam.nelson@ti.com>
---
 drivers/uio/Kconfig              |   7 +
 drivers/uio/Makefile             |   1 +
 drivers/uio/uio_ti_pdrv.c        | 506 +++++++++++++++++++++++++++++++++++++++
 include/uapi/linux/Kbuild        |   1 +
 include/uapi/linux/uio_ti_pdrv.h |  19 ++
 5 files changed, 534 insertions(+)
 create mode 100644 drivers/uio/uio_ti_pdrv.c
 create mode 100644 include/uapi/linux/uio_ti_pdrv.h

diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
index 8a15c32..3e5263e 100644
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -155,4 +155,11 @@ config UIO_MF624
 
 	  If you compile this as a module, it will be called uio_mf624.
 
+config UIO_TI_PDRV
+	tristate "uio driver for ti peripheral modules"
+	help
+	  Userspace I/O interface for the generic TI peripherals. Provides
+	  access to peripheral registers and memory areas from user space.
+	  Also ties-inn interrupt and clock features
+
 endif
diff --git a/drivers/uio/Makefile b/drivers/uio/Makefile
index 8560dad..f788ba1 100644
--- a/drivers/uio/Makefile
+++ b/drivers/uio/Makefile
@@ -9,3 +9,4 @@ obj-$(CONFIG_UIO_NETX)	+= uio_netx.o
 obj-$(CONFIG_UIO_PRUSS)         += uio_pruss.o
 obj-$(CONFIG_UIO_MF624)         += uio_mf624.o
 obj-$(CONFIG_UIO_FSL_ELBC_GPCM)	+= uio_fsl_elbc_gpcm.o
+obj-$(CONFIG_UIO_TI_PDRV)	+= uio_ti_pdrv.o
diff --git a/drivers/uio/uio_ti_pdrv.c b/drivers/uio/uio_ti_pdrv.c
new file mode 100644
index 0000000..c59e532
--- /dev/null
+++ b/drivers/uio/uio_ti_pdrv.c
@@ -0,0 +1,506 @@
+/*
+ * User-space  module driver
+ *
+ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ *    Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the
+ *    distribution.
+ *
+ *    Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/virtio.h>
+#include <linux/uio_driver.h>
+#include <linux/uaccess.h>
+#include <linux/spinlock.h>
+#include <uapi/linux/uio_ti_pdrv.h>
+
+#define DRIVER_NAME		"uio_ti_pdrv"
+#define DRIVER_VERSION		"1.0"
+
+/**
+ * struct uio_ti_pdrv_info - local information for uio module driver
+ * @lock: Lock to protect shared resources with interrupt handler
+ * @dev: device pointer
+ * @misc: Misc device pointer
+ * @clk: Clock pointer
+ * @flags: flags to keep track of interrupt occurrence
+ * @lock: Lock to protect shared resources with interrupt handler
+ * @interrupt_mode: No disable on interrupt(0) or One shot mode(1)
+ * @workqueue: Workqueue for interrupt triggered tasks
+ * @mem: uio memory regions pointer
+ * @num_maps: Number of uio memory regions
+ */
+struct uio_ti_pdrv_info {
+	struct uio_info		uio;
+	struct device		*dev;
+	struct miscdevice	misc;
+	struct clk		*clk;
+	unsigned long		flags;
+	spinlock_t		lock;
+	int			interrupt_mode;
+	struct work_struct	workqueue;
+	struct uio_mem *mem;
+	int num_maps;
+};
+
+/**
+ * uio_ti_pdrv_open - uio module driver open routine
+ */
+static int uio_ti_pdrv_open(struct uio_info *uio, struct inode *inode)
+{
+	struct uio_ti_pdrv_info *uio_ti_pdrv = uio->priv;
+
+	if (uio_ti_pdrv->clk)
+		return clk_prepare_enable(uio_ti_pdrv->clk);
+	else
+		return 0;
+}
+
+/**
+ * uio_ti_pdrv_release - uio module driver release routine
+ */
+static int uio_ti_pdrv_release(struct uio_info *uio, struct inode *inode)
+{
+	struct uio_ti_pdrv_info *uio_ti_pdrv = uio->priv;
+
+	if (uio_ti_pdrv->clk)
+		clk_disable_unprepare(uio_ti_pdrv->clk);
+	return 0;
+}
+
+/**
+ * uio_ti_pdrv_handler - uio module driver interrupt handler
+ */
+static irqreturn_t uio_ti_pdrv_handler(int irq, struct uio_info *uio)
+{
+	struct uio_ti_pdrv_info *uio_ti_pdrv = uio->priv;
+
+	if (uio_ti_pdrv->interrupt_mode == 1) {
+		spin_lock(&uio_ti_pdrv->lock);
+		if (!__test_and_set_bit(0, &uio_ti_pdrv->flags))
+			disable_irq_nosync(irq);
+		spin_unlock(&uio_ti_pdrv->lock);
+	}
+	return IRQ_HANDLED;
+}
+
+/**
+ * uio_ti_pdrv_irqcontrol - uio module driver interrupt control
+ */
+static int uio_ti_pdrv_irqcontrol(struct uio_info *uio, s32 irq_on)
+{
+	struct uio_ti_pdrv_info *uio_ti_pdrv = uio->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&uio_ti_pdrv->lock, flags);
+	if (irq_on) {
+		if (__test_and_clear_bit(0, &uio_ti_pdrv->flags))
+			enable_irq(uio->irq);
+	} else {
+		if (!__test_and_set_bit(0, &uio_ti_pdrv->flags))
+			disable_irq_nosync(uio->irq);
+	}
+	spin_unlock_irqrestore(&uio_ti_pdrv->lock, flags);
+
+	return 0;
+}
+
+/**
+ * uio_ti_pdrv_dev_fop_open() : open for the uio module driver
+ */
+static int uio_ti_pdrv_dev_fop_open(struct inode *inode, struct file *file)
+{
+	/* Need an empty open so that file->private_data gets populated */
+	return 0;
+}
+
+/**
+ * uio_ti_pdrv_dev_fop_mmap() - provided mmap support for
+ * device memory. This checks if user request is in valid range before providing
+ * mmap access. The valid range can be configured using device tree or platform
+ * data.
+ */
+static int uio_ti_pdrv_dev_fop_mmap(
+	struct file *file,
+	struct vm_area_struct *vma
+)
+{
+	size_t size = vma->vm_end - vma->vm_start;
+	struct miscdevice *misc = file->private_data;
+	struct uio_ti_pdrv_info *uio_ti_pdrv =
+		container_of(misc, struct uio_ti_pdrv_info, misc);
+
+	int index;
+	size_t req_offset;
+
+	index = vma->vm_pgoff & UIO_TI_PDRV_MAP_INDEX_MASK;
+	/* Check if index is valid */
+	if (index >= uio_ti_pdrv->num_maps) {
+		dev_err(uio_ti_pdrv->dev,
+			"mmap index %d is outside the allowed range\n",
+			index);
+		return -EINVAL;
+	}
+
+	req_offset = (vma->vm_pgoff - index)  << PAGE_SHIFT;
+
+	/* Check size requested with offset */
+	if ((req_offset + size) > uio_ti_pdrv->mem[index].size) {
+		dev_err(uio_ti_pdrv->dev,
+			"mmap index %d: mmap offset(0x%zx) and size (0x%zx) is outside the allowed range\n",
+			index, req_offset, size);
+		return -EINVAL;
+	}
+
+	vma->vm_page_prot = phys_mem_access_prot(
+		file, (uio_ti_pdrv->mem[index].addr >> PAGE_SHIFT)
+		+ (vma->vm_pgoff - index),
+		size, vma->vm_page_prot
+	);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    (uio_ti_pdrv->mem[index].addr >> PAGE_SHIFT)
+			     + (vma->vm_pgoff - index),
+			    size, vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+/**
+ * uio_ti_pdrv_transfer() - provides ability to write to memory areas
+ */
+
+static ssize_t  uio_ti_pdrv_transfer(struct file *file, char __user *buf,
+				     size_t count, loff_t *ppos, int flag)
+{
+	struct miscdevice *misc = file->private_data;
+	struct uio_ti_pdrv_info *uio_ti_pdrv =
+		container_of(misc, struct uio_ti_pdrv_info, misc);
+	uint32_t phys_addr;
+	void __iomem *virt_addr_p = NULL;
+	int index;
+	size_t req_offset;
+
+	index = *ppos & UIO_TI_PDRV_MAP_INDEX_MASK;
+	/* Check if index is valid */
+	if (index >= uio_ti_pdrv->num_maps) {
+		dev_err(uio_ti_pdrv->dev,
+			"mmap index %d is outside the allowed range\n",
+			index);
+		return -EINVAL;
+	}
+
+	req_offset = (*ppos - index)  << PAGE_SHIFT;
+
+	/* Check size requested with offset */
+	if ((req_offset + count) > uio_ti_pdrv->mem[index].size) {
+		dev_err(uio_ti_pdrv->dev,
+			"mmap index %d: mmap offset(0x%zx) and size (0x%zx) is outside the allowed range\n",
+			index, req_offset, count);
+		return -EINVAL;
+	}
+
+	phys_addr = uio_ti_pdrv->mem[index].addr + req_offset;
+
+	virt_addr_p = ioremap_nocache(phys_addr, count);
+	if (!virt_addr_p) {
+		dev_err(uio_ti_pdrv->dev, "Mapping of virtual memory failed\n");
+		return(-ENOMEM);
+	}
+	if (flag == 1) {
+		if (copy_from_user((__force void*) virt_addr_p, buf, count)) {
+			dev_err(uio_ti_pdrv->dev, "copy_from_user failed\n");
+			return -EFAULT;
+		}
+	} else {
+		if (copy_to_user(buf, (__force void*)virt_addr_p, count)) {
+			dev_err(uio_ti_pdrv->dev, "copy_to_user failed\n");
+			return -EFAULT;
+		}
+	}
+	iounmap(virt_addr_p);
+	return count;
+}
+
+/**
+ * uio_ti_pdrv_dev_fop_write() - provides ability to write to memory areas
+ */
+
+static ssize_t  uio_ti_pdrv_dev_fop_write(struct file *file,
+					  const char __user *buf, size_t count,
+					  loff_t *ppos)
+{
+	return
+		uio_ti_pdrv_transfer(
+			file, (char __user *)buf,
+			count, ppos, 1
+		);
+}
+
+/**
+ * uio_ti_pdrv_dev_fop_read() - provides ability to read from memory areas
+ */
+
+static ssize_t  uio_ti_pdrv_dev_fop_read(struct file *file, char __user *buf,
+					 size_t count, loff_t *ppos)
+{
+	return uio_ti_pdrv_transfer(file, buf, count, ppos, 0);
+}
+
+static const struct file_operations uio_ti_pdrv_dev_fops = {
+	.owner		= THIS_MODULE,
+	.open		= uio_ti_pdrv_dev_fop_open,
+	.mmap		= uio_ti_pdrv_dev_fop_mmap,
+	.read		= uio_ti_pdrv_dev_fop_read,
+	.write		= uio_ti_pdrv_dev_fop_write,
+	.llseek		= generic_file_llseek,
+};
+
+/**
+ * uio_ti_pdrv_populate_segments() - scan the configuration for "mem" and
+ * populate in uio_ti_pdrv local structure. This information will be used to
+ * process user mmap requests.
+ */
+static inline int 
+uio_ti_pdrv_populate_segments(struct device_node *np,
+			      struct uio_ti_pdrv_info *uio_ti_pdrv)
+{
+	int len, i;
+	u32 dt_value;
+	int num_maps = 0;
+
+	if (of_get_property(np, "mem", &len)) {
+		/*
+		 * check if length even multiple of sizeof(u32), i.e.,
+		 *   the dt bindings need to be of the form <addr length>
+		 */
+		len = len / sizeof(u32);
+		if ((len % 2) != 0) {
+			dev_err(uio_ti_pdrv->dev, "invalid address map in dt binding\n");
+			return -EINVAL;
+		}
+		num_maps = len / 2;
+
+		uio_ti_pdrv->mem = devm_kzalloc(uio_ti_pdrv->dev,
+				sizeof(struct uio_mem) * num_maps,
+				GFP_KERNEL);
+		if (!uio_ti_pdrv->mem) {
+			dev_err(uio_ti_pdrv->dev, "devm_kzalloc mapping failed\n");
+			return -ENOMEM;
+		}
+
+		/* populate the uio_ti_pdrv structure for policing */
+		for (i = 0; i < num_maps; i++) {
+			uio_ti_pdrv->mem[i].memtype = UIO_MEM_PHYS;
+			if (of_property_read_u32_index(np, "mem", 2 * i,
+						       &dt_value)) {
+				dev_err(uio_ti_pdrv->dev,
+					"Error reading dt bindings: addr\n");
+				return -ENODEV;
+			}
+			uio_ti_pdrv->mem[i].addr = dt_value;
+			if (of_property_read_u32_index(np, "mem", (2 * i) + 1,
+						       &dt_value)) {
+				dev_err(uio_ti_pdrv->dev,
+					"Error reading dt bindings: size\n");
+				return -ENODEV;
+			}
+			uio_ti_pdrv->mem[i].size = dt_value;
+		}
+		uio_ti_pdrv->num_maps = num_maps;
+	}
+	return 0;
+}
+
+/**
+ * uio_ti_pdrv_driver_probe() probe routine for the uio module driver
+ */
+static int uio_ti_pdrv_driver_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct uio_ti_pdrv_info *uio_ti_pdrv;
+	struct miscdevice *misc;
+	struct uio_info *uio;
+	struct resource *r;
+	int error = 0;
+	int i;
+	int irq;
+	char *name;
+
+	if (!np) {
+		dev_err(dev, "Non dt case not supported\n");
+		return -EINVAL;
+	}
+
+	uio_ti_pdrv = kzalloc(sizeof(struct  uio_ti_pdrv_info), GFP_KERNEL);
+
+	if (!uio_ti_pdrv) {
+		error = -ENOMEM;
+		goto fail;
+	}
+
+	uio_ti_pdrv->dev = dev;
+	spin_lock_init(&uio_ti_pdrv->lock);
+	uio_ti_pdrv->flags = 0; /* interrupt is enabled to begin with */
+
+	uio		= &uio_ti_pdrv->uio;
+	name = strchr(dev_name(dev), '.');
+	if (name) {
+		uio->name	= name + 1;
+	} else {
+		name = strchr(dev_name(dev), ':');
+		if (name)
+			uio->name	= name + 1;
+		else
+			uio->name = dev_name(dev);
+	}
+
+	uio->version	= DRIVER_VERSION;
+	uio->priv	= uio_ti_pdrv;
+	uio->handler	= uio_ti_pdrv_handler;
+	uio->irqcontrol	= uio_ti_pdrv_irqcontrol;
+	uio->open	= uio_ti_pdrv_open;
+	uio->release	= uio_ti_pdrv_release;
+
+	irq = platform_get_irq(pdev, 0);
+	if (!(irq < 0))
+		/* pass up control irq to user-space */
+		uio->irq	= irq;
+
+	if (
+		of_property_read_u32(
+			np, "interrupt-mode",
+			&uio_ti_pdrv->interrupt_mode
+		) < 0
+	)
+		uio_ti_pdrv->interrupt_mode = 0;
+
+	for (i = 0; i < MAX_UIO_MAPS; ++i) {
+		r = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!r)
+			break;
+		uio->mem[i].memtype = UIO_MEM_PHYS;
+		uio->mem[i].addr    = r->start & PAGE_MASK;
+		uio->mem[i].size    = PAGE_ALIGN(resource_size(r));
+		uio->mem[i].name    = r->name;
+	}
+
+	uio_ti_pdrv->clk = clk_get(dev, NULL);
+	if (IS_ERR(uio_ti_pdrv->clk))
+		uio_ti_pdrv->clk = NULL;
+
+	error = uio_ti_pdrv_populate_segments(np, uio_ti_pdrv);
+	if (error) {
+		dev_err(dev, "failed populating memory segments\n");
+		goto fail_uio;
+	}
+
+	if (uio->irq || uio->mem[0].memtype != UIO_MEM_NONE) {
+		error = uio_register_device(dev, uio);
+		if (error) {
+			dev_err(dev, "failed to register uio device\n");
+			goto fail_uio;
+		}
+	}
+	platform_set_drvdata(pdev, uio_ti_pdrv);
+
+	if (uio_ti_pdrv->num_maps) {
+		misc = &uio_ti_pdrv->misc;
+		misc->minor	= MISC_DYNAMIC_MINOR;
+		misc->name	= uio->name;
+		misc->fops	= &uio_ti_pdrv_dev_fops;
+		misc->parent	= dev;
+
+		if (misc_register(misc)) {
+			dev_err(dev, "could not register misc device\n");
+			goto fail_uio_module;
+		}
+		dev_info(dev, "registered misc device %s\n", misc->name);
+	}
+
+	return 0;
+
+fail_uio_module:
+	uio_unregister_device(uio);
+fail_uio:
+	if (uio_ti_pdrv->clk)
+		clk_put(uio_ti_pdrv->clk);
+	devm_kfree(dev, uio_ti_pdrv);
+fail:
+	return error;
+}
+
+/**
+ * uio_ti_pdrv_driver_remove() remove routine for the uio module driver
+ */
+
+static int uio_ti_pdrv_driver_remove(struct platform_device *pdev)
+{
+	struct uio_ti_pdrv_info *uio_ti_pdrv = platform_get_drvdata(pdev);
+	struct uio_info *uio = &uio_ti_pdrv->uio;
+
+	if (uio_ti_pdrv) {
+		if (uio->irq || uio->mem[0].memtype != UIO_MEM_NONE)
+			uio_unregister_device(&uio_ti_pdrv->uio);
+		if (uio_ti_pdrv->clk)
+			clk_put(uio_ti_pdrv->clk);
+		if (uio_ti_pdrv->num_maps)
+			misc_deregister(&uio_ti_pdrv->misc);
+	}
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static const struct of_device_id uio_ti_pdrv_of_match[] = {
+	{ .compatible = "ti,uio-ti-pdrv", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, uio_ti_pdrv_of_match);
+
+static struct platform_driver uio_ti_pdrv_driver = {
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.of_match_table = uio_ti_pdrv_of_match,
+	},
+	.probe	= uio_ti_pdrv_driver_probe,
+	.remove	= uio_ti_pdrv_driver_remove,
+};
+
+module_platform_driver(uio_ti_pdrv_driver);
+MODULE_AUTHOR("Sam Nelson Siluvaimani");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("User-space driver for ti platform devices ");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index 190d971..52dd04a 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -410,6 +410,7 @@ header-y += udp.h
 header-y += uhid.h
 header-y += uinput.h
 header-y += uio.h
+header-y += uio_ti_pdrv.h
 header-y += ultrasound.h
 header-y += un.h
 header-y += unistd.h
diff --git a/include/uapi/linux/uio_ti_pdrv.h b/include/uapi/linux/uio_ti_pdrv.h
new file mode 100644
index 0000000..092c3bb
--- /dev/null
+++ b/include/uapi/linux/uio_ti_pdrv.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2015 Texas Instruments Incorporated
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _UAPI__UIO_TI_PDRV_H
+#define _UAPI__UIO_TI_PDRV_H
+
+#define UIO_TI_PDRV_MAP_INDEX_MASK 0x7
+#define UIO_TI_PDRV_MAP_OFFSET_SHIFT 3
+
+#endif /* _UAPI__UIO_TI_PDRV_H */
-- 
1.9.1

