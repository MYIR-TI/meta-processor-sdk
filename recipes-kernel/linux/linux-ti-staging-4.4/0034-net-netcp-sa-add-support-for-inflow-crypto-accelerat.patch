From 5ef1dcf0644a73976d93281fe801d44e647f51c2 Mon Sep 17 00:00:00 2001
From: Vitaly Andrianov <vitalya@ti.com>
Date: Mon, 15 Aug 2016 12:08:02 -0400
Subject: [PATCH 34/37] net: netcp: sa: add support for inflow crypto
 acceleration

This commit is a port of the driver from v3.10.72 kernel.
The inflow mode requires custom ipsecmgr_mod module.
This module also ported to v4.4 kernel, but not supports fragmentation yet.

Signed-off-by: Vitaly Andrianov <vitalya@ti.com>
Signed-off-by: Jacob Stiffler <j-stiffler@ti.com>
---
 drivers/net/ethernet/ti/Kconfig              |   9 +
 drivers/net/ethernet/ti/Makefile             |   2 +
 drivers/net/ethernet/ti/keystone_pasahost.h  | 395 +++++++++++++++++++++
 drivers/net/ethernet/ti/keystone_pasahost2.h | 507 +++++++++++++++++++++++++++
 drivers/net/ethernet/ti/netcp_pasa2_host.h   | 507 +++++++++++++++++++++++++++
 drivers/net/ethernet/ti/netcp_pasa_host.h    | 395 +++++++++++++++++++++
 drivers/net/ethernet/ti/netcp_sa.c           | 471 +++++++++++++++++++++++++
 7 files changed, 2286 insertions(+)
 create mode 100644 drivers/net/ethernet/ti/keystone_pasahost.h
 create mode 100644 drivers/net/ethernet/ti/keystone_pasahost2.h
 create mode 100644 drivers/net/ethernet/ti/netcp_pasa2_host.h
 create mode 100644 drivers/net/ethernet/ti/netcp_pasa_host.h
 create mode 100644 drivers/net/ethernet/ti/netcp_sa.c

diff --git a/drivers/net/ethernet/ti/Kconfig b/drivers/net/ethernet/ti/Kconfig
index ecd537f..1c8180f 100644
--- a/drivers/net/ethernet/ti/Kconfig
+++ b/drivers/net/ethernet/ti/Kconfig
@@ -157,6 +157,15 @@ config TI_KEYSTONE_NETCP_QOS
 	  To compile this driver as a module, choose M here: the module
 	  will be called netcp_qos.
 
+config TI_KEYSTONE_NETCP_SA
+	tristate "TI Keystone inflow Security Accelerator mode Support"
+	depends on TI_KEYSTONE_NETCP
+	default TI_KEYSTONE_NETCP
+	---help---
+
+	  This driver supports TI Keystone inflow Security Accelerator
+          mode.
+
 config TLAN
 	tristate "TI ThunderLAN support"
 	depends on (PCI || EISA)
diff --git a/drivers/net/ethernet/ti/Makefile b/drivers/net/ethernet/ti/Makefile
index 130899d..47e89cb 100644
--- a/drivers/net/ethernet/ti/Makefile
+++ b/drivers/net/ethernet/ti/Makefile
@@ -28,5 +28,7 @@ obj-$(CONFIG_TI_KEYSTONE_NETCP_PA2) += keystone_netcp_pa2.o
 keystone_netcp_pa2-y := netcp_pa2.o
 obj-$(CONFIG_TI_KEYSTONE_NETCP_QOS) += keystone_netcp_qos.o
 keystone_netcp_qos-y := netcp_qos.o
+obj-$(CONFIG_TI_KEYSTONE_NETCP_SA) += keystone_netcp_sa.o
+keystone_netcp_sa-y := netcp_sa.o
 
 obj-$(CONFIG_TI_PRUETH) += prueth.o
diff --git a/drivers/net/ethernet/ti/keystone_pasahost.h b/drivers/net/ethernet/ti/keystone_pasahost.h
new file mode 100644
index 0000000..bfc2899
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_pasahost.h
@@ -0,0 +1,395 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Author: Sandeep Paulraj <s-paulraj@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef KEYSTONE_PASAHOST_H
+#define KEYSTONE_PASAHOST_H
+
+#ifdef __KERNEL__
+
+#define PASAHO_SA_SHORT_INFO		1
+
+#if 0
+#define	PASAHO_CONFIGURE		4
+#define PASAHO_PARX_PARSECMD		0
+#define PASAHO_PARX_MULTI_ROUTE		5
+#define PASAHO_PAMOD_CMPT_CHKSUM	0
+#define PASAHO_PAMOD_CMPT_CRC		1
+#define PASAHO_PAMOD_PATCH		2
+#define PASAHO_PAMOD_NROUTE		3
+#define PASAHO_PAMOD_MULTI_ROUTE	5
+#define PASAHO_PAMOD_REPORT_TIMESTAMP	6
+#define PASAHO_PAMOD_GROUP_7		7
+#define PASAHO_PAMOD_DUMMY		PASAHO_PAMOD_GROUP_7
+#define PASAHO_PAMOD_IP_FRAGMENT	PASAHO_PAMOD_GROUP_7
+#define PASAHO_SA_LONG_INFO		0
+#define PASAHO_SA_AIR_INFO		2
+
+#define PASAHO_READ_BITFIELD(a,b,c)	(((a)>>(b)) & ((1UL<<(c))-1))
+
+#define PASAHO_SET_BITFIELD(a,x,b,c)	(a) &= ~(((1UL<<(c))-1)<<(b)), \
+					(a) |= (((x) & ((1UL<<(c))-1))<<(b))
+
+#define PASAHO_SET_CMDID(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 29,3)
+
+#define PASAHO_PACFG_CMD	(((u32)PASAHO_CONFIGURE << 5) << 24)
+
+enum pasaho_header_type {
+	PASAHO_HDR_MAC        = 0,        /* MAC */
+	PASAHO_HDR_VLAN,                  /* VLAN */
+	PASAHO_HDR_MPLS,                  /* MPLS */
+	PASAHO_HDR_IPv4,                  /* IPv4 */
+	PASAHO_HDR_IPv6,                  /* IPv6 */
+	PASAHO_HDR_IPv6_EXT_HOP,          /* IPv6 hop by hop extenstion header */
+	PASAHO_HDR_IPv6_EXT_ROUTE,        /* IPv6 routing extenstion header */
+	PASAHO_HDR_IPv6_EXT_FRAG,         /* IPv6 fragmentation extention header */
+	PASAHO_HDR_IPv6_EXT_DEST,         /* IPv6 destination options header */
+	PASAHO_HDR_GRE,                   /* Generic Routing Encapsulation header */
+	PASAHO_HDR_ESP,                   /* Encapsulating Security Payload header */
+	PASAHO_HDR_ESP_DECODED,           /* Decoded Encapsulating Security Payload header */
+	PASAHO_HDR_AUTH,                  /* Authentication header */
+	PASAHO_HDR_CUSTOM_C1,             /* Custom classify 1 header */
+	PASAHO_HDR_FORCE_LOOKUP,          /* A contrived header type used with custom SRIO to force
+                                        a parse after looking at only the SRIO L0-L2 */
+	PASAHO_HDR_UNKNOWN,               /* Next header type is unknown */
+	PASAHO_HDR_UDP,                   /* User Datagram Protocol header */
+	PASAHO_HDR_UDP_LITE,              /* Lightweight User Datagram Protocol header */
+	PASAHO_HDR_TCP,                   /* Transmission Control Protocol header */
+	PASAHO_HDR_CUSTOM_C2              /* Custom classify 2 header */
+};
+
+/**
+ *  @defgroup pasahoSubCmdCode PASS Sub-Command Code
+ *  @ingroup pasaho_if_constants
+ *  @{
+ *
+ *  @name PASS Sub-Command Code
+ *  Definition of the 5-bit sub-command codes which is used to specify the group 7 commands.
+ */
+
+enum pasaho_sub_cmd_code {
+	PASAHO_SUB_CMD_DUMMY	= 0,	/* Dummy */
+	PASAHO_SUB_CMD_IP_FRAG		/* IPv4 fragmentation */
+};
+
+/**
+ *  @ingroup pasaho_if_structures
+ *  @brief  pasahoCmdInfo_t defines the general short command information
+ *
+ */
+struct pasaho_cmd_info {
+	u32	word0;		/* Control block word 0 */
+};
+
+/**
+ *  @ingroup pasaho_if_structures
+ *  @brief  pasahoLongInfo_t defines the packet parsing information in the long format.
+ *          The information is structured as an array of 32 bit values. These values
+ *          are broken down through macros. This allows the representation to be
+ *          endian independent to the hardware which operates only on 32 bit values.
+ *
+ *  @details
+ */
+struct pasaho_long_info {
+	u32   word0;	/* Control block word 0 */
+	u32   word1;	/* Control block word 1 */
+	u32   word2;	/* Control block word 2 */
+	u32   word3;	/* Control block word 3 */
+	u32   word4;	/* Control block word 4 */
+};
+
+/**
+ *  @defgroup PASAHO_long_info_command_macros  PASAHO Long Info Command Macros
+ *  @ingroup pasaho_if_macros
+ *  @{
+ *  @name PASAHO Long Info Command Macros
+ *  Macros used by the PASAHO Long Info Command
+ */
+
+/* Extract the command ID defined at */
+#define PASAHO_LINFO_READ_CMDID(x)		PASAHO_READ_BITFIELD((x)->word0,29,3)
+
+/* Extract the block length */
+#define PASAHO_LINFO_READ_RECLEN(x)		PASAHO_READ_BITFIELD((x)->word0,24,5)
+
+/* Extract the next parse start offset */
+#define PASAHO_LINFO_READ_START_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word0,0,16)
+
+/* Extract the end of packet parse offset */
+#define PASAHO_LINFO_READ_END_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word1,16,16)
+
+/* Extract the error index */
+#define PASAHO_LINFO_READ_EIDX(x)		PASAHO_READ_BITFIELD((x)->word1,11,5)
+
+/* Extract the previous match flag */
+#define PASAHO_LINFO_READ_PMATCH(x)		PASAHO_READ_BITFIELD((x)->word1,10,1)
+
+/* Extract the custom classify flag */
+#define PASAHO_LINFO_READ_C2C(x)		PASAHO_READ_BITFIELD((x)->word1,9,1)
+
+/* Extract the first parse module ID */
+#define PASAHO_LINFO_READ_L1_PDSP_ID(x)		PASAHO_READ_BITFIELD((x)->word1,6,3)
+
+/* Extract the first parse module match index */
+#define PASAHO_LINFO_READ_L1_IDX(x)		PASAHO_READ_BITFIELD((x)->word1,0,6)
+
+/* Extract the offset to the level 3 header */
+#define PASAHO_LINFO_READ_L3_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,24,8)
+
+/* Extract the offset to the level 4 header */
+#define PASAHO_LINFO_READ_L4_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,16,8)
+
+/* Extract the offset to the level 5 header */
+#define PASAHO_LINFO_READ_L5_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,8,8)
+
+/* Extract the offset to the security header */
+#define PASAHO_LINFO_READ_ESP_AH_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word2,0,8)
+
+/* Extract the bitmask of parsed header types */
+#define PASAHO_LINFO_READ_HDR_BITMASK(x)	PASAHO_READ_BITFIELD((x)->word3,21,11)
+
+/* Extract the next header to parse type */
+#define PASAHO_LINFO_READ_NXT_HDR_TYPE(x)	PASAHO_READ_BITFIELD((x)->word3,16,5)
+
+/* Extract the number of VLAN tags found */
+#define PASAHO_LINFO_READ_VLAN_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,12,4)
+
+/* Extract the number of IP headers found */
+#define PASAHO_LINFO_READ_IP_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,8,4)
+
+/* Extract the number of GRE headers found */
+#define PASAHO_LINFO_READ_GRE_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,4,4)
+
+/* Extract the fragmentation found flag */
+#define PASAHO_LINFO_READ_FLAG_FRAG(x)		PASAHO_READ_BITFIELD((x)->word3,3,1)
+
+/* Extract the incomplete IP route flag */
+#define PASAHO_LINFO_READ_FLAG_ROUTE(x)		PASAHO_READ_BITFIELD((x)->word3,2,1)
+
+/* Extract the (1-based) input EMAC port number */
+/*  0: Indicates that the packet does not enter PASS through CPSW */
+#define PASAHO_LINFO_READ_INPORT(x)		PASAHO_READ_BITFIELD((x)->word3,0,3)
+
+/* Extract the last pseudo-header checksum computed */
+#define PASAHO_LINFO_READ_PSEUDO_CHKSM(x)	PASAHO_READ_BITFIELD((x)->word4,16,16)
+
+#define PASAHO_LINFO_READ_TSTAMP_MSB(x)		PASAHO_READ_BITFIELD((x)->word4,0,16)
+
+/* Extract the IP Reassembly Traffic Flow Index */
+#define PASAHO_LINFO_READ_TFINDEX(x)		PASAHO_READ_BITFIELD((x)->word4,24,8)
+
+/* Extract the IP Reassembly Fragment count */
+#define PASAHO_LINFO_READ_FRANCNT(x)		PASAHO_READ_BITFIELD((x)->word4,16,8)
+
+/* Set the IP Reassembly Traffic Flow Index */
+#define PASAHO_LINFO_SET_TFINDEX(x, v)		PASAHO_SET_BITFIELD((x)->word4,(v),24,8)
+
+/* Set the IP Reassembly Fragment count */
+#define PASAHO_LINFO_SET_FRANCNT(x, v)		PASAHO_SET_BITFIELD((x)->word4,(v),16,8)
+
+/* Indicate whether it is an IPSEC packet */
+#define PASAHO_LINFO_IS_IPSEC(x)		PASAHO_READ_BITFIELD((x)->word3,25,2)
+
+/* Indicate whether it is an IPSEC ESP packet */
+#define PASAHO_LINFO_IS_IPSEC_ESP(x)		PASAHO_READ_BITFIELD((x)->word3,26,1)
+
+/* Indicate whether it is an IPSEC AH packet */
+#define PASAHO_LINFO_IS_IPSEC_AH(x)		PASAHO_READ_BITFIELD((x)->word3,25,1)
+
+/* Clear IPSEC indication bits */
+#define PASAHO_LINFO_CLR_IPSEC(x)		PASAHO_SET_BITFIELD((x)->word3,0,25,2)
+
+/* Clear IPSEC ESP indication bit */
+#define PASAHO_LINFO_CLR_IPSEC_ESP(x)		PASAHO_SET_BITFIELD((x)->word3,0,26,1)
+
+/* Clear IPSEC AH indication bit */
+#define PASAHO_LINFO_CLR_IPSEC_AH(x)		PASAHO_SET_BITFIELD((x)->word3,0,25,1)
+
+/* Clear the fragmentation found flag */
+#define PASAHO_LINFO_CLR_FLAG_FRAG(x)		PASAHO_SET_BITFIELD((x)->word3,0,3,1)
+
+/* Update the next parse start offset */
+#define PASAHO_LINFO_SET_START_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word0,(v),0,16)
+
+/* Update the end of packet parse offset */
+#define PASAHO_LINFO_SET_END_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word1,(v),16,16)
+
+
+/*
+ * Set the null packet flag which indicates that the packet should be dropped.
+ * This flag should be set for the null packet to be delivered to PASS when
+ * the reassembly timeout occurs
+ */
+#define PASAHO_LINFO_SET_NULL_PKT_IND(x, v)	PASAHO_SET_BITFIELD((x)->word0,(v),21,1)
+
+/*
+ * PA_INV_TF_INDEX
+ * PASS-asssited IP reassembly traffic flow index to indicate
+ * that no traffic flow is available
+ */
+#define PA_INV_TF_INDEX		0xFF
+
+struct pasaho_short_info {
+	u32	word0;
+	u32	word1;
+};
+
+/* Extract the command ID defined at */
+#define PASAHO_SINFO_READ_CMDID(x)		PASAHO_READ_BITFIELD((x)->word0,29,3)
+
+/* Extract the offset to the packet payload */
+#define PASAHO_SINFO_RESD_PAYLOAD_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word0,16,8)
+
+/* Extract the byte length of the payload */
+#define PASAHO_SINFO_READ_PAYLOAD_LENGTH(x)	PASAHO_READ_BITFIELD((x)->word0,0,16)
+
+/* Set the offset to the payload */
+#define PASAHO_SINFO_SET_PAYLOAD_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Set the payload length */
+#define PASAHO_SINFO_SET_PAYLOAD_LENGTH(x, v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+#endif
+/* Format the entire short info command */
+#define PASAHO_SINFO_FORMAT_CMD(offset, len)	(((offset) << 16) | (len) | (PASAHO_SA_SHORT_INFO << 29))
+#if 0
+#define PASAHO_HDR_BITMASK_MAC		(1 << 0)	/* MAC present */
+#define PASAHO_HDR_BITMASK_VLAN		(1 << 1)	/* VLAN present */
+#define PASAHO_HDR_BITMASK_MPLS		(1 << 2)	/* MPLS present */
+#define PASAHO_HDR_BITMASK_IP		(1 << 3)	/* IP present */
+#define PASAHO_HDR_BITMASK_ESP		(1 << 4)	/* IPSEC/ESP present */
+#define PASAHO_HDR_BITMASK_AH		(1 << 5)	/* IPSEC/AH present */
+#define PASAHO_HDR_BITMASK_UDP		(1 << 6)	/* UDP present */
+#define PASAHO_HDR_BITMASK_UDPLITE	(1 << 7)	/* UDPLITE present */
+#define PASAHO_HDR_BITMASK_TCP		(1 << 8)	/* TCP present */
+#define PASAHO_HDR_BITMASK_GRE		(1 << 9)	/* GRE present */
+#define PASAHO_HDR_BITMASK_CUSTOM	(1 << 10)	/* Custom header */
+
+struct pasaho_next_route {
+	u32  word0;
+	u32  sw_info0;
+	u32  sw_info1;
+	u32  word1;
+};
+
+/*
+ * Sets the N bit which indicates the next command
+ * should be executed prior to the route command
+ */
+#define PASAHO_SET_N(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 28, 1)
+
+/*
+ * Sets the E bit which indicates the extened
+ * parameters (packet type) are present for SRIO
+ */
+#define PASAHO_SET_E(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 27, 1)
+
+/*
+ * Sets the destination of the route defined */
+#define PASAHO_SET_DEST(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 24, 3)
+
+/* Specifies the flow to use for packets sent to the host */
+#define PASAHO_SET_FLOW(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for packets send to the host */
+#define PASAHO_SET_QUEUE(x,v)   PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Specifies the packet type to use for packets send to the SRIO */
+#define PASAHO_SET_PKTTYPE(x,v) PASAHO_SET_BITFIELD((x)->word1, (v), 24, 8)
+
+struct pasaho_com_chk_crc {
+	u32	word0;		/* PASAHO_chksum_command_macros */
+	u32	word1;		/* PASAHO_chksum_command_macros */
+	u32	word2;		/* PASAHO_chksum_command_macros */
+};
+
+/*
+ * Sets the negative 0 flag - if set a
+ * checksum computed as 0 will be sent as 0xffff
+ */
+#define PASAHO_CHKCRC_SET_NEG0(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 23, 1)
+
+/* Sets the optional flags of the CRC/Checksum command */
+#define PASAHO_CHKCRC_SET_CTRL(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Sets the start offset of the checksum/crc */
+#define PASAHO_CHKCRC_SET_START(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Sets the length of the checksum/crc */
+#define PASAHO_CHKCRC_SET_LEN(x,v)	PASAHO_SET_BITFIELD((x)->word1, (v), 16, 16)
+
+/* Sets the offset to where to paste the checksum/crc into the packet */
+#define PASAHO_CHKCRC_SET_RESULT_OFF(x,v)	PASAHO_SET_BITFIELD((x)->word1, (v), 0,  16)
+
+/* Sets the initial value of the checksum/crc */
+#define PASAHO_CHKCRC_SET_INITVAL(x,v)	PASAHO_SET_BITFIELD((x)->word2, (v), 16, 16)
+
+#define PASAHO_BPATCH_MAX_PATCH_WORDS	4
+
+struct pasaho_com_blind_patch {
+	u32	word0;
+	u32	patch[PASAHO_BPATCH_MAX_PATCH_WORDS];
+};
+
+
+#define PASAHO_BPATCH_SET_PATCH_NBYTES(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 24,  5)
+
+/* Sets the number of bytes to patch */
+#define PASAHO_BPATCH_SET_PATCH_CMDSIZE(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 20, 4)
+
+/* Sets the size of the command in 32 bit word units */
+#define PASAHO_BPATCH_SET_OVERWRITE(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 19, 1)
+
+/*
+ * Sets the overwrite flag. If set the patch will
+ * overwrite existing packet data, otherwise data is inserted
+ */
+#define PASAHO_BPATCH_SET_OFFSET(x,v)		PASAHO_SET_BITFIELD((x)->word0, v, 0,  16)
+
+/* Sets the offset to the start of the patch */
+#define PASAHO_BPATCH_SET_PATCH_BYTE(x, byteNum, byte)  (x)->patch[(byteNum) >> 2] = \
+		PASAHO_SET_BITFIELD((x)->patch[(byteNum) >> 2], byte, ((3 - (byteNum & 0x3)) << 3), 8)
+
+
+struct pasaho_report_timestamp {
+	u32	word0;
+	u32	sw_info0;
+};
+
+/* Specifies the flow to use for report packets sent to the host */
+
+#define PASAHO_SET_REPORT_FLOW(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for report packets send to the host */
+#define PASAHO_SET_REPORT_QUEUE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+struct pasaho_ip_frag {
+	u32	word0;
+};
+
+/* Set sub-command code to indicate IP Fragmentation command */
+#define PASAHO_SET_SUB_CODE_IP_FRAG(x) PASAHO_SET_BITFIELD((x)->word0, PASAHO_SUB_CMD_IP_FRAG, 24, 5)
+
+/* Specifies the sub-command code */
+#define PASAHO_SET_SUB_CODE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 24, 5)
+
+/* Specifies the offset to the IP header to be fragmented */
+#define PASAHO_SET_IP_OFFSET(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the MTU size */
+#define PASAHO_SET_MTU_SIZE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* KEYSTONE_PASAHOST_H */
diff --git a/drivers/net/ethernet/ti/keystone_pasahost2.h b/drivers/net/ethernet/ti/keystone_pasahost2.h
new file mode 100644
index 0000000..f5e7e8b
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_pasahost2.h
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2013 Texas Instruments Incorporated
+ * Author: Hao Zhang <hzhang@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef KEYSTONE_PASAHOST2_H
+#define KEYSTONE_PASAHOST2_H
+
+#ifdef __KERNEL__
+
+#define	PASAHO2_CONFIGURE		4
+#define PASAHO2_PARX_PARSECMD		0
+#define PASAHO2_PARX_MULTI_ROUTE		5
+#define PASAHO2_PAMOD_CMPT_CHKSUM	0
+#define PASAHO2_PAMOD_CMPT_CRC		1
+#define PASAHO2_PAMOD_PATCH		2
+#define PASAHO2_PAMOD_NROUTE		3
+#define PASAHO2_PAMOD_EF_OP		5
+#define PASAHO2_PAMOD_REPORT_TIMESTAMP	6
+#define PASAHO2_PAMOD_GROUP_7		7
+#define PASAHO2_PAMOD_DUMMY		PASAHO2_PAMOD_GROUP_7
+#define PASAHO2_PAMOD_IP_FRAGMENT	PASAHO2_PAMOD_GROUP_7
+#define PASAHO2_SA_LONG_INFO		0
+#define PASAHO2_SA_SHORT_INFO		1
+#define PASAHO2_SA_AIR_INFO		2
+
+#define PASAHO2_READ_BITFIELD(a, b, c)	(((a) >> (b)) & ((1 << (c)) - 1))
+
+#define PASAHO2_SET_BITFIELD(a, x, b, c) (a) &= ~(((1 << (c)) - 1) << (b)), \
+					(a) |= (((x) & ((1 << (c)) - 1)) << (b))
+
+#define PASAHO2_SET_CMDID(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 29, 3)
+
+#define PASAHO2_PACFG_CMD	(((u32)PASAHO2_CONFIGURE << 5) << 24)
+
+enum pasaho2_header_type {
+	PASAHO2_HDR_MAC	= 0,		/* MAC */
+	PASAHO2_HDR_VLAN,		/* VLAN */
+	PASAHO2_HDR_MPLS,		/* MPLS */
+	PASAHO2_HDR_IPv4,		/* IPv4 */
+	PASAHO2_HDR_IPv6,		/* IPv6 */
+	PASAHO2_HDR_IPv6_EXT_HOP,	/* IPv6 hop by hop extenstion header */
+	PASAHO2_HDR_IPv6_EXT_ROUTE,	/* IPv6 routing extenstion header */
+	PASAHO2_HDR_IPv6_EXT_FRAG,	/* IPv6 fragmentation extention hdr */
+	PASAHO2_HDR_IPv6_EXT_DEST,	/* IPv6 destination options header */
+	PASAHO2_HDR_GRE,		/* Generic Routing Encapsulation
+					   header */
+	PASAHO2_HDR_ESP,		/* Encapsulating Security Payload
+					   header */
+	PASAHO2_HDR_ESP_DECODED,	/* Decoded Encapsulating Security
+					   Payload header */
+	PASAHO2_HDR_AUTH,		/* Authentication header */
+	PASAHO2_HDR_CUSTOM_C1,		/* Custom classify 1 header */
+	PASAHO2_HDR_PPPoE,		/* PPPoE Header */
+	PASAHO2_HDR_SCTP,		/* SCTP Header */
+	PASAHO2_HDR_UNKNOWN,		/* Next header type is unknown */
+	PASAHO2_HDR_UDP,		/* User Datagram Protocol header */
+	PASAHO2_HDR_UDP_LITE,		/* Lightweight User Datagram Protocol
+					   header */
+	PASAHO2_HDR_TCP,		/* Transmission Control Protocol
+					   header */
+	PASAHO2_HDR_GTPU,		/* GTPU header */
+	PASAHO2_HDR_ESP_DECODED_C2,	/* Decoded Encapsulating Security
+					   Payload header at Classifyer2 */
+	PASAHO2_HDR_CUSTOM_C2		/* Custom classify 2 header */
+};
+
+/* Definition of the 5-bit sub-command codes which is used to specify the group
+   7 commands. */
+enum pasaho2_sub_cmd_code {
+	PASAHO2_SUB_CMD_DUMMY	= 0,	/* Dummy */
+	PASAHO2_SUB_CMD_IP_FRAG,		/* IPv4 fragmentation */
+	PASAHO2_SUB_CMD_PATCH_MSG_LEN	/* Message length Patching */
+};
+
+/* pasaho2_cmd_info defines the general short command information */
+struct pasaho2_cmd_info {
+	u32	word0;		/* Control block word 0 */
+};
+
+/* pasaho2_long_info defines the packet parsing information in the long format.
+ * The information is structured as an array of 32 bit values. These values
+ * are broken down through macros. This allows the representation to be
+ * endian independent to the hardware which operates only on 32 bit values. */
+struct pasaho2_long_info {
+	u32   word0;	/* Control block word 0 */
+	u32   word1;	/* Control block word 1 */
+	u32   word2;	/* Control block word 2 */
+	u32   word3;	/* Control block word 3 */
+	u32   word4;	/* Control block word 4 */
+};
+
+/* Macros used by the PASAHO Long Info Command */
+
+/* Extract the command ID defined at */
+#define PASAHO2_LINFO_READ_CMDID(x)	PASAHO2_READ_BITFIELD((x)->word0, 29, 3)
+
+/* Extract the block length */
+#define PASAHO2_LINFO_READ_RECLEN(x)	PASAHO2_READ_BITFIELD((x)->word0, 24, 5)
+
+/* Extract the next parse start offset */
+#define PASAHO2_LINFO_READ_START_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 0, 8)
+
+/* Indicate whether it is a broadcast MAC packet */
+#define PASAHO2_LINFO_IS_MAC_BROADCAST(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 1)
+
+/* Indicate whether it is a multicast MAC packet */
+#define PASAHO2_LINFO_IS_MAC_MULTICAST(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 17, 1)
+
+/* Extract the MAC packet type */
+#define PASAHO2_LINFO_READ_MAC_PKTTYPE(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 2)
+
+/* Indicate whether it is a broadcast IP packet */
+#define PASAHO2_LINFO_IS_IP_BROADCAST(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 1)
+
+/* Indicate whether it is a multicast IP packet */
+#define PASAHO2_LINFO_IS_IP_MULTICAST(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 17, 1)
+
+/* Extract the IP packet type */
+#define PASAHO2_LINFO_READ_IP_PKTTYPE(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 2)
+
+/* Extract the previous match flag */
+#define PASAHO2_LINFO_READ_PMATCH(x)	PASAHO2_READ_BITFIELD((x)->word0, 23, 1)
+
+/* Extract the fragmentation found flag */
+#define PASAHO2_LINFO_READ_FLAG_FRAG(x)	PASAHO2_READ_BITFIELD((x)->word0, 19, 1)
+
+/* Extract the end of packet parse offset */
+#define PASAHO2_LINFO_READ_END_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word1, 16, 16)
+
+/* Extract the error index */
+#define PASAHO2_LINFO_READ_EIDX(x)	PASAHO2_READ_BITFIELD((x)->word1, 10, 6)
+
+/* Extract the next header to parse type */
+#define PASAHO2_LINFO_READ_NXT_HDR_TYPE(x) \
+	PASAHO2_READ_BITFIELD((x)->word1, 0, 6)
+
+/* Extract the (1-based) input EMAC port number through CPSW */
+#define PASAHO2_LINFO_READ_INPORT(x)	PASAHO2_READ_BITFIELD((x)->word1, 6, 4)
+
+/* Extract the offset to the level 3 header */
+#define PASAHO2_LINFO_READ_L3_OFFSET(x)	PASAHO2_READ_BITFIELD((x)->word2, 24, 8)
+
+/* Extract the offset to the level 4 header */
+#define PASAHO2_LINFO_READ_L4_OFFSET(x)	PASAHO2_READ_BITFIELD((x)->word2, 16, 8)
+
+/* Extract the offset to the level 5 header */
+#define PASAHO2_LINFO_READ_L5_OFFSET(x)	PASAHO2_READ_BITFIELD((x)->word2, 8, 8)
+
+/* Extract the offset to the security header */
+#define PASAHO2_LINFO_READ_ESP_AH_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word2, 0, 8)
+
+/* Extract the first parse module ID */
+#define PASAHO2_LINFO_READ_L1_PDSP_ID(x) \
+	PASAHO2_READ_BITFIELD((x)->word3, 26, 6)
+
+/* Extract the first parse module match index */
+#define PASAHO2_LINFO_READ_L1_IDX(x) \
+	PASAHO2_READ_BITFIELD((x)->word3, 16, 10)
+
+/* Extract the bitmask of parsed header types */
+#define PASAHO2_LINFO_READ_HDR_BITMASK(x) \
+	PASAHO2_READ_BITFIELD((x)->word3, 0, 16)
+
+/* Extract the number of VLAN tags found */
+#define PASAHO2_LINFO_READ_VLAN_COUNT(x) PASAHO2_READ_BITFIELD((x)->word4, 6, 2)
+
+/* Extract the number of IP headers found */
+#define PASAHO2_LINFO_READ_IP_COUNT(x)	PASAHO2_READ_BITFIELD((x)->word4, 0, 3)
+
+/* Extract the number of GRE headers found */
+#define PASAHO2_LINFO_READ_GRE_COUNT(x)	PASAHO2_READ_BITFIELD((x)->word4, 3, 3)
+
+/*  Extract the last pseudo-header checksum computed (depreciated) */
+#define PASAHO2_LINFO_READ_PSEUDO_CHKSM(x) \
+	PASAHO2_READ_BITFIELD((x)->word5, 16, 16)
+
+/**< Extract the offset to the inner IP header */
+#define PASAHO2_LINFO_READ_INNER_IP_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word5, 24, 8)
+
+/* Extract the most significant 16-bit of the 48-bit timestamp */
+#define PASAHO2_LINFO_READ_TSTAMP_MSB(x) \
+	PASAHO2_READ_BITFIELD((x)->word5, 0, 16)
+
+
+/* Indicate whether it is a MAC packet */
+#define PASAHO2_LINFO_IS_MAC(x)		PASAHO2_READ_BITFIELD((x)->word3, 0, 1)
+
+/* Indicate whether it is a MAC packet with VLAN */
+#define PASAHO2_LINFO_IS_WITH_VLAN(x)	PASAHO2_LINFO_READ_VLAN_COUNT(x)
+
+/* Indicate whether it is a MAC packet with MPLS */
+#define PASAHO2_LINFO_IS_WITH_MPLS(x)	PASAHO2_READ_BITFIELD((x)->word3, 2, 1)
+
+/* Indicate whether it is a 802.3 packet */
+#define PASAHO2_LINFO_IS_802_3(x)	PASAHO2_READ_BITFIELD((x)->word3, 3, 1)
+
+/* Indicate whether it is a PPPoE packet */
+#define PASAHO2_LINFO_IS_PPPoE(x)	PASAHO2_READ_BITFIELD((x)->word3, 4, 1)
+
+/* Indicate whether it is an IP packet */
+#define PASAHO2_LINFO_IS_IP(x)		PASAHO2_LINFO_READ_IP_COUNT(x)
+
+/* Indicate whether it is an IPv4 packet */
+#define PASAHO2_LINFO_IS_IPv4(x)	PASAHO2_READ_BITFIELD((x)->word3, 5, 1)
+
+/* Indicate whether it is an IPv4 packet */
+#define PASAHO2_LINFO_IS_IPv6(x)	PASAHO2_READ_BITFIELD((x)->word3, 6, 1)
+
+/* Indicate whether there are IPV4 options or IPv6 extention headers */
+#define PASAHO2_LINFO_IS_IP_OPTIONS(x)	PASAHO2_READ_BITFIELD((x)->word3, 7, 1)
+
+/* Indicate whether it is an IPSEC packet */
+#define PASAHO2_LINFO_IS_IPSEC(x)	PASAHO2_READ_BITFIELD((x)->word3, 8, 2)
+
+/* Indicate whether it is an IPSEC ESP packet */
+#define PASAHO2_LINFO_IS_IPSEC_ESP(x)	PASAHO2_READ_BITFIELD((x)->word3, 8, 1)
+
+/* Indicate whether it is an IPSEC AH packet */
+#define PASAHO2_LINFO_IS_IPSEC_AH(x)	PASAHO2_READ_BITFIELD((x)->word3, 9, 1)
+
+/* Indicate whether it is a SCTP packet */
+#define PASAHO2_LINFO_IS_SCTP(x)	PASAHO2_READ_BITFIELD((x)->word3, 10, 1)
+
+/* Indicate whether it is an UDP packet */
+#define PASAHO2_LINFO_IS_UDP(x)		PASAHO2_READ_BITFIELD((x)->word3, 11, 1)
+
+/* Indicate whether it is an UDP Lite packet */
+#define PASAHO2_LINFO_IS_UDP_LITE(x)	PASAHO2_READ_BITFIELD((x)->word3, 11, 1)
+
+/* Indicate whether it is a TCP packet */
+#define PASAHO2_LINFO_IS_TCP(x)		PASAHO2_READ_BITFIELD((x)->word3, 12, 1)
+
+/* Indicate whether it is a GRE packet */
+#define PASAHO2_LINFO_IS_GRE(x)		PASAHO2_LINFO_READ_GRE_COUNT(x)
+
+/* Indicate whether it is a GTPU packet */
+#define PASAHO2_LINFO_IS_GTPU(x)	PASAHO2_READ_BITFIELD((x)->word3, 13, 1)
+
+/* Indicate whether it is a Custom packet */
+#define PASAHO2_LINFO_IS_CUSTOM(x)	PASAHO2_READ_BITFIELD((x)->word3, 14, 1)
+
+/* Indicate whether it is an IPSEC NAT-T packet */
+#define PASAHO2_LINFO_IS_IPSEC_NAT_T(x)	PASAHO2_READ_BITFIELD((x)->word3, 15, 1)
+
+
+/* Extract the IP Reassembly Traffic Flow Index */
+#define PASAHO2_LINFO_READ_TFINDEX(x)	PASAHO2_READ_BITFIELD((x)->word5, 24, 8)
+
+/* Extract the IP Reassembly Fragment count */
+#define PASAHO2_LINFO_READ_FRANCNT(x)	PASAHO2_READ_BITFIELD((x)->word5, 16, 8)
+
+/* Set the IP Reassembly Traffic Flow Index */
+#define PASAHO2_LINFO_SET_TFINDEX(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word5, (v), 24, 8)
+
+/* Set the IP Reassembly Fragment count */
+#define PASAHO2_LINFO_SET_FRANCNT(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word5, (v), 16, 8)
+
+
+/* Clear IPSEC indication bits */
+#define PASAHO2_LINFO_CLR_IPSEC(x) \
+	PASAHO2_SET_BITFIELD((x)->word3, 0, 8, 2)
+
+/* Clear IPSEC ESP indication bit */
+#define PASAHO2_LINFO_CLR_IPSEC_ESP(x) \
+	PASAHO2_SET_BITFIELD((x)->word3, 0, 8, 1)
+
+/* Claer IPSEC AH indication bit */
+#define PASAHO2_LINFO_CLR_IPSEC_AH(x) \
+	PASAHO2_SET_BITFIELD((x)->word3, 0, 9, 1)
+
+/* Clear the fragmentation found flag */
+#define PASAHO2_LINFO_CLR_FLAG_FRAG(x) \
+	PASAHO2_SET_BITFIELD((x)->word1, 0, 19, 1)
+
+/* Update the next parse start offset */
+#define PASAHO2_LINFO_SET_START_OFFSET(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 0, 8)
+
+/* Update the end of packet parse offset */
+#define PASAHO2_LINFO_SET_END_OFFSET(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word1, (v), 16, 16)
+
+/* Update the next header to parse type */
+#define PASAHO2_LINFO_SET_NXT_HDR_TYPE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word1, (v), 0, 6)
+
+/* Set the null packet flag which indicates that the packet should be dropped.
+ * This flag should be set for the null packet to be delivered to PASS when the
+ * reassembly timeout occurs */
+#define PASAHO2_LINFO_SET_NULL_PKT_IND(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 21, 1)
+
+/*
+ * PA_INV_TF_INDEX
+ * PASS-asssited IP reassembly traffic flow index to indicate
+ * that no traffic flow is available
+ */
+#define PA_INV_TF_INDEX		0xFF
+
+struct pasaho2_short_info {
+	u32	word0;
+	u32	word1;
+};
+
+/* Extract the command ID defined at */
+#define PASAHO2_SINFO_READ_CMDID(x)	PASAHO2_READ_BITFIELD((x)->word0, 29, 3)
+
+/* Extract the offset to the packet payload */
+#define PASAHO2_SINFO_RESD_PAYLOAD_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 8)
+
+/* Extract the byte length of the payload */
+#define PASAHO2_SINFO_READ_PAYLOAD_LENGTH(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 0, 16)
+
+/* Set the offset to the payload */
+#define PASAHO2_SINFO_SET_PAYLOAD_OFFSET(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Set the payload length */
+#define PASAHO2_SINFO_SET_PAYLOAD_LENGTH(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Format the entire short info command */
+#define PASAHO2_SINFO_FORMAT_CMD(offset, len) \
+	(((offset) << 16) | (len) | (PASAHO2_SA_SHORT_INFO << 29))
+
+#define PASAHO2_HDR_BITMASK_MAC		(1 << 0)  /* MAC present */
+#define PASAHO2_HDR_BITMASK_VLAN		(1 << 1)  /* VLAN present */
+#define PASAHO2_HDR_BITMASK_MPLS		(1 << 2)  /* MPLS present */
+#define PASAHO2_HDR_BITMASK_802_3	(1 << 3)  /* 802.3 present */
+#define PASAHO2_HDR_BITMASK_PPPoE	(1 << 4)  /* PPPoE present */
+#define PASAHO2_HDR_BITMASK_IPv4		(1 << 5)  /* IPv4 present */
+#define PASAHO2_HDR_BITMASK_IPv6		(1 << 6)  /* IPv6 present */
+#define PASAHO2_HDR_BITMASK_IP_OPTS	(1 << 7)  /* IPv4 options or IPv6
+						     extension headers esent */
+#define PASAHO2_HDR_BITMASK_ESP		(1 << 8)  /* IPSEC/ESP present */
+#define PASAHO2_HDR_BITMASK_AH		(1 << 9)  /* IPSEC/AH present */
+#define PASAHO2_HDR_BITMASK_SCTP		(1 << 10) /* SCTP present */
+#define PASAHO2_HDR_BITMASK_UDP		(1 << 11) /* UDP present */
+#define PASAHO2_HDR_BITMASK_UDPLITE	(1 << 11) /* UDPLITE present */
+#define PASAHO2_HDR_BITMASK_TCP		(1 << 12) /* TCP present */
+#define PASAHO2_HDR_BITMASK_GTPU		(1 << 13) /* GTPU present */
+#define PASAHO2_HDR_BITMASK_CUSTOM	(1 << 14) /* Custom header present */
+#define PASAHO2_HDR_BITMASK_IPSEC_NAT_T	(1 << 15) /* IPSEC NAT-T present */
+
+struct pasaho2_next_route {
+	u32  word0;
+	u32  sw_info0;
+	u32  sw_info1;
+	u32  word1;
+};
+
+/*
+ * Sets the N bit which indicates the next command
+ * should be executed prior to the route command
+ */
+#define PASAHO2_SET_N(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 28, 1)
+
+/*
+ * Sets the E bit which indicates the extened
+ * parameters (packet type) are present for SRIO
+ */
+#define PASAHO2_SET_E(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 27, 1)
+
+/*
+ * Sets the destination of the route defined */
+#define PASAHO2_SET_DEST(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 24, 3)
+
+/* Specifies the flow to use for packets sent to the host */
+#define PASAHO2_SET_FLOW(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for packets send to the host */
+#define PASAHO2_SET_QUEUE(x, v)   PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Specifies the packet type to use for packets send to the SRIO */
+#define PASAHO2_SET_PKTTYPE(x, v) PASAHO2_SET_BITFIELD((x)->word1, (v), 24, 8)
+
+struct pasaho2_com_chk_crc {
+	u32	word0;		/* PASAHO2_chksum_command_macros */
+	u32	word1;		/* PASAHO2_chksum_command_macros */
+	u32	word2;		/* PASAHO2_chksum_command_macros */
+};
+
+/*
+ * Sets the negative 0 flag - if set a
+ * checksum computed as 0 will be sent as 0xffff
+ */
+#define PASAHO2_CHKCRC_SET_NEG0(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 23, 1)
+
+/* Sets the optional flags of the CRC/Checksum command */
+#define PASAHO2_CHKCRC_SET_CTRL(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 4)
+
+/* Sets the size of the crc in bytes */
+#define PASAHO2_CHKCRC_SET_CRCSIZE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 8,  8)
+
+/* Sets the start offset of the checksum/crc */
+#define PASAHO2_CHKCRC_SET_START(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  8)
+
+/* Sets the length of the checksum/crc */
+#define PASAHO2_CHKCRC_SET_LEN(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word1, (v), 16, 16)
+
+/* Sets the offset to where to paste the checksum/crc into the packet */
+#define PASAHO2_CHKCRC_SET_RESULT_OFF(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word1, (v), 0,  16)
+
+/* Sets the initial value of the checksum/crc */
+#define PASAHO2_CHKCRC_SET_INITVAL(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word2, (v), 16, 16)
+
+/* Sets the initial value of the 32-bit crc */
+#define PASAHO2_CHKCRC_SET_INITVAL32(x, v)	((x)->word2) = (v)
+
+
+#define PASAHO2_BPATCH_MAX_PATCH_WORDS	4
+
+struct pasaho2_com_blind_patch {
+	u32	word0;
+	u32	patch[PASAHO2_BPATCH_MAX_PATCH_WORDS];
+};
+
+
+#define PASAHO2_BPATCH_SET_PATCH_NBYTES(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, v, 24,  5)
+
+/* Sets the number of bytes to patch */
+#define PASAHO2_BPATCH_SET_PATCH_CMDSIZE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, v, 20, 4)
+
+/* Sets the size of the command in 32 bit word units */
+#define PASAHO2_BPATCH_SET_OVERWRITE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, v, 19, 1)
+
+/*
+ * Sets the overwrite flag. If set the patch will
+ * overwrite existing packet data, otherwise data is inserted
+ */
+#define PASAHO2_BPATCH_SET_OFFSET(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, v, 0,  16)
+
+/* Sets the offset to the start of the patch */
+#define PASAHO2_BPATCH_SET_PATCH_BYTE(x, byteNum, byte) \
+	((x)->patch[(byteNum) >> 2]) = \
+	PASAHO2_SET_BITFIELD((x)->patch[(byteNum) >> 2], \
+	byte, ((3 - (byteNum & 0x3)) << 3), 8)
+
+
+struct pasaho2_report_timestamp {
+	u32	word0;
+	u32	sw_info0;
+};
+
+/* Specifies the flow to use for report packets sent to the host */
+
+#define PASAHO2_SET_REPORT_FLOW(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for report packets send to the host */
+#define PASAHO2_SET_REPORT_QUEUE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+struct pasaho2_ip_frag {
+	u32	word0;
+};
+
+/* Set sub-command code to indicate IP Fragmentation command */
+#define PASAHO2_SET_SUB_CODE_IP_FRAG(x) \
+	PASAHO2_SET_BITFIELD((x)->word0, PASAHO2_SUB_CMD_IP_FRAG, 24, 5)
+
+/* Specifies the sub-command code */
+#define PASAHO2_SET_SUB_CODE(x, v) PASAHO2_SET_BITFIELD((x)->word0, (v), 24, 5)
+
+/* Specifies the offset to the IP header to be fragmented */
+#define PASAHO2_SET_IP_OFFSET(x, v) PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the MTU size */
+#define PASAHO2_SET_MTU_SIZE(x, v) PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+#endif /* __KERNEL__ */
+#endif /* KEYSTONE_PASAHOST2_H */
diff --git a/drivers/net/ethernet/ti/netcp_pasa2_host.h b/drivers/net/ethernet/ti/netcp_pasa2_host.h
new file mode 100644
index 0000000..81550b0
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_pasa2_host.h
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2013 Texas Instruments Incorporated
+ * Author: Hao Zhang <hzhang@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef NETCP_PASA2_HOST_H
+#define NETCP_PASA2_HOST_H
+
+#ifdef __KERNEL__
+
+#define	PASAHO2_CONFIGURE		4
+#define PASAHO2_PARX_PARSECMD		0
+#define PASAHO2_PARX_MULTI_ROUTE		5
+#define PASAHO2_PAMOD_CMPT_CHKSUM	0
+#define PASAHO2_PAMOD_CMPT_CRC		1
+#define PASAHO2_PAMOD_PATCH		2
+#define PASAHO2_PAMOD_NROUTE		3
+#define PASAHO2_PAMOD_EF_OP		5
+#define PASAHO2_PAMOD_REPORT_TIMESTAMP	6
+#define PASAHO2_PAMOD_GROUP_7		7
+#define PASAHO2_PAMOD_DUMMY		PASAHO2_PAMOD_GROUP_7
+#define PASAHO2_PAMOD_IP_FRAGMENT	PASAHO2_PAMOD_GROUP_7
+#define PASAHO2_SA_LONG_INFO		0
+#define PASAHO2_SA_SHORT_INFO		1
+#define PASAHO2_SA_AIR_INFO		2
+
+#define PASAHO2_READ_BITFIELD(a, b, c)	(((a) >> (b)) & ((1 << (c)) - 1))
+
+#define PASAHO2_SET_BITFIELD(a, x, b, c) (a) &= ~(((1 << (c)) - 1) << (b)), \
+					(a) |= (((x) & ((1 << (c)) - 1)) << (b))
+
+#define PASAHO2_SET_CMDID(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 29, 3)
+
+#define PASAHO2_PACFG_CMD	(((u32)PASAHO2_CONFIGURE << 5) << 24)
+
+enum pasaho2_header_type {
+	PASAHO2_HDR_MAC	= 0,		/* MAC */
+	PASAHO2_HDR_VLAN,		/* VLAN */
+	PASAHO2_HDR_MPLS,		/* MPLS */
+	PASAHO2_HDR_IPv4,		/* IPv4 */
+	PASAHO2_HDR_IPv6,		/* IPv6 */
+	PASAHO2_HDR_IPv6_EXT_HOP,	/* IPv6 hop by hop extenstion header */
+	PASAHO2_HDR_IPv6_EXT_ROUTE,	/* IPv6 routing extenstion header */
+	PASAHO2_HDR_IPv6_EXT_FRAG,	/* IPv6 fragmentation extention hdr */
+	PASAHO2_HDR_IPv6_EXT_DEST,	/* IPv6 destination options header */
+	PASAHO2_HDR_GRE,		/* Generic Routing Encapsulation
+					   header */
+	PASAHO2_HDR_ESP,		/* Encapsulating Security Payload
+					   header */
+	PASAHO2_HDR_ESP_DECODED,	/* Decoded Encapsulating Security
+					   Payload header */
+	PASAHO2_HDR_AUTH,		/* Authentication header */
+	PASAHO2_HDR_CUSTOM_C1,		/* Custom classify 1 header */
+	PASAHO2_HDR_PPPoE,		/* PPPoE Header */
+	PASAHO2_HDR_SCTP,		/* SCTP Header */
+	PASAHO2_HDR_UNKNOWN,		/* Next header type is unknown */
+	PASAHO2_HDR_UDP,		/* User Datagram Protocol header */
+	PASAHO2_HDR_UDP_LITE,		/* Lightweight User Datagram Protocol
+					   header */
+	PASAHO2_HDR_TCP,		/* Transmission Control Protocol
+					   header */
+	PASAHO2_HDR_GTPU,		/* GTPU header */
+	PASAHO2_HDR_ESP_DECODED_C2,	/* Decoded Encapsulating Security
+					   Payload header at Classifyer2 */
+	PASAHO2_HDR_CUSTOM_C2		/* Custom classify 2 header */
+};
+
+/* Definition of the 5-bit sub-command codes which is used to specify the group
+   7 commands. */
+enum pasaho2_sub_cmd_code {
+	PASAHO2_SUB_CMD_DUMMY	= 0,	/* Dummy */
+	PASAHO2_SUB_CMD_IP_FRAG,		/* IPv4 fragmentation */
+	PASAHO2_SUB_CMD_PATCH_MSG_LEN	/* Message length Patching */
+};
+
+/* pasaho2_cmd_info defines the general short command information */
+struct pasaho2_cmd_info {
+	u32	word0;		/* Control block word 0 */
+};
+
+/* pasaho2_long_info defines the packet parsing information in the long format.
+ * The information is structured as an array of 32 bit values. These values
+ * are broken down through macros. This allows the representation to be
+ * endian independent to the hardware which operates only on 32 bit values. */
+struct pasaho2_long_info {
+	u32   word0;	/* Control block word 0 */
+	u32   word1;	/* Control block word 1 */
+	u32   word2;	/* Control block word 2 */
+	u32   word3;	/* Control block word 3 */
+	u32   word4;	/* Control block word 4 */
+};
+
+/* Macros used by the PASAHO Long Info Command */
+
+/* Extract the command ID defined at */
+#define PASAHO2_LINFO_READ_CMDID(x)	PASAHO2_READ_BITFIELD((x)->word0, 29, 3)
+
+/* Extract the block length */
+#define PASAHO2_LINFO_READ_RECLEN(x)	PASAHO2_READ_BITFIELD((x)->word0, 24, 5)
+
+/* Extract the next parse start offset */
+#define PASAHO2_LINFO_READ_START_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 0, 8)
+
+/* Indicate whether it is a broadcast MAC packet */
+#define PASAHO2_LINFO_IS_MAC_BROADCAST(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 1)
+
+/* Indicate whether it is a multicast MAC packet */
+#define PASAHO2_LINFO_IS_MAC_MULTICAST(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 17, 1)
+
+/* Extract the MAC packet type */
+#define PASAHO2_LINFO_READ_MAC_PKTTYPE(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 2)
+
+/* Indicate whether it is a broadcast IP packet */
+#define PASAHO2_LINFO_IS_IP_BROADCAST(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 1)
+
+/* Indicate whether it is a multicast IP packet */
+#define PASAHO2_LINFO_IS_IP_MULTICAST(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 17, 1)
+
+/* Extract the IP packet type */
+#define PASAHO2_LINFO_READ_IP_PKTTYPE(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 2)
+
+/* Extract the previous match flag */
+#define PASAHO2_LINFO_READ_PMATCH(x)	PASAHO2_READ_BITFIELD((x)->word0, 23, 1)
+
+/* Extract the fragmentation found flag */
+#define PASAHO2_LINFO_READ_FLAG_FRAG(x)	PASAHO2_READ_BITFIELD((x)->word0, 19, 1)
+
+/* Extract the end of packet parse offset */
+#define PASAHO2_LINFO_READ_END_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word1, 16, 16)
+
+/* Extract the error index */
+#define PASAHO2_LINFO_READ_EIDX(x)	PASAHO2_READ_BITFIELD((x)->word1, 10, 6)
+
+/* Extract the next header to parse type */
+#define PASAHO2_LINFO_READ_NXT_HDR_TYPE(x) \
+	PASAHO2_READ_BITFIELD((x)->word1, 0, 6)
+
+/* Extract the (1-based) input EMAC port number through CPSW */
+#define PASAHO2_LINFO_READ_INPORT(x)	PASAHO2_READ_BITFIELD((x)->word1, 6, 4)
+
+/* Extract the offset to the level 3 header */
+#define PASAHO2_LINFO_READ_L3_OFFSET(x)	PASAHO2_READ_BITFIELD((x)->word2, 24, 8)
+
+/* Extract the offset to the level 4 header */
+#define PASAHO2_LINFO_READ_L4_OFFSET(x)	PASAHO2_READ_BITFIELD((x)->word2, 16, 8)
+
+/* Extract the offset to the level 5 header */
+#define PASAHO2_LINFO_READ_L5_OFFSET(x)	PASAHO2_READ_BITFIELD((x)->word2, 8, 8)
+
+/* Extract the offset to the security header */
+#define PASAHO2_LINFO_READ_ESP_AH_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word2, 0, 8)
+
+/* Extract the first parse module ID */
+#define PASAHO2_LINFO_READ_L1_PDSP_ID(x) \
+	PASAHO2_READ_BITFIELD((x)->word3, 26, 6)
+
+/* Extract the first parse module match index */
+#define PASAHO2_LINFO_READ_L1_IDX(x) \
+	PASAHO2_READ_BITFIELD((x)->word3, 16, 10)
+
+/* Extract the bitmask of parsed header types */
+#define PASAHO2_LINFO_READ_HDR_BITMASK(x) \
+	PASAHO2_READ_BITFIELD((x)->word3, 0, 16)
+
+/* Extract the number of VLAN tags found */
+#define PASAHO2_LINFO_READ_VLAN_COUNT(x) PASAHO2_READ_BITFIELD((x)->word4, 6, 2)
+
+/* Extract the number of IP headers found */
+#define PASAHO2_LINFO_READ_IP_COUNT(x)	PASAHO2_READ_BITFIELD((x)->word4, 0, 3)
+
+/* Extract the number of GRE headers found */
+#define PASAHO2_LINFO_READ_GRE_COUNT(x)	PASAHO2_READ_BITFIELD((x)->word4, 3, 3)
+
+/*  Extract the last pseudo-header checksum computed (depreciated) */
+#define PASAHO2_LINFO_READ_PSEUDO_CHKSM(x) \
+	PASAHO2_READ_BITFIELD((x)->word5, 16, 16)
+
+/**< Extract the offset to the inner IP header */
+#define PASAHO2_LINFO_READ_INNER_IP_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word5, 24, 8)
+
+/* Extract the most significant 16-bit of the 48-bit timestamp */
+#define PASAHO2_LINFO_READ_TSTAMP_MSB(x) \
+	PASAHO2_READ_BITFIELD((x)->word5, 0, 16)
+
+
+/* Indicate whether it is a MAC packet */
+#define PASAHO2_LINFO_IS_MAC(x)		PASAHO2_READ_BITFIELD((x)->word3, 0, 1)
+
+/* Indicate whether it is a MAC packet with VLAN */
+#define PASAHO2_LINFO_IS_WITH_VLAN(x)	PASAHO2_LINFO_READ_VLAN_COUNT(x)
+
+/* Indicate whether it is a MAC packet with MPLS */
+#define PASAHO2_LINFO_IS_WITH_MPLS(x)	PASAHO2_READ_BITFIELD((x)->word3, 2, 1)
+
+/* Indicate whether it is a 802.3 packet */
+#define PASAHO2_LINFO_IS_802_3(x)	PASAHO2_READ_BITFIELD((x)->word3, 3, 1)
+
+/* Indicate whether it is a PPPoE packet */
+#define PASAHO2_LINFO_IS_PPPoE(x)	PASAHO2_READ_BITFIELD((x)->word3, 4, 1)
+
+/* Indicate whether it is an IP packet */
+#define PASAHO2_LINFO_IS_IP(x)		PASAHO2_LINFO_READ_IP_COUNT(x)
+
+/* Indicate whether it is an IPv4 packet */
+#define PASAHO2_LINFO_IS_IPv4(x)	PASAHO2_READ_BITFIELD((x)->word3, 5, 1)
+
+/* Indicate whether it is an IPv4 packet */
+#define PASAHO2_LINFO_IS_IPv6(x)	PASAHO2_READ_BITFIELD((x)->word3, 6, 1)
+
+/* Indicate whether there are IPV4 options or IPv6 extention headers */
+#define PASAHO2_LINFO_IS_IP_OPTIONS(x)	PASAHO2_READ_BITFIELD((x)->word3, 7, 1)
+
+/* Indicate whether it is an IPSEC packet */
+#define PASAHO2_LINFO_IS_IPSEC(x)	PASAHO2_READ_BITFIELD((x)->word3, 8, 2)
+
+/* Indicate whether it is an IPSEC ESP packet */
+#define PASAHO2_LINFO_IS_IPSEC_ESP(x)	PASAHO2_READ_BITFIELD((x)->word3, 8, 1)
+
+/* Indicate whether it is an IPSEC AH packet */
+#define PASAHO2_LINFO_IS_IPSEC_AH(x)	PASAHO2_READ_BITFIELD((x)->word3, 9, 1)
+
+/* Indicate whether it is a SCTP packet */
+#define PASAHO2_LINFO_IS_SCTP(x)	PASAHO2_READ_BITFIELD((x)->word3, 10, 1)
+
+/* Indicate whether it is an UDP packet */
+#define PASAHO2_LINFO_IS_UDP(x)		PASAHO2_READ_BITFIELD((x)->word3, 11, 1)
+
+/* Indicate whether it is an UDP Lite packet */
+#define PASAHO2_LINFO_IS_UDP_LITE(x)	PASAHO2_READ_BITFIELD((x)->word3, 11, 1)
+
+/* Indicate whether it is a TCP packet */
+#define PASAHO2_LINFO_IS_TCP(x)		PASAHO2_READ_BITFIELD((x)->word3, 12, 1)
+
+/* Indicate whether it is a GRE packet */
+#define PASAHO2_LINFO_IS_GRE(x)		PASAHO2_LINFO_READ_GRE_COUNT(x)
+
+/* Indicate whether it is a GTPU packet */
+#define PASAHO2_LINFO_IS_GTPU(x)	PASAHO2_READ_BITFIELD((x)->word3, 13, 1)
+
+/* Indicate whether it is a Custom packet */
+#define PASAHO2_LINFO_IS_CUSTOM(x)	PASAHO2_READ_BITFIELD((x)->word3, 14, 1)
+
+/* Indicate whether it is an IPSEC NAT-T packet */
+#define PASAHO2_LINFO_IS_IPSEC_NAT_T(x)	PASAHO2_READ_BITFIELD((x)->word3, 15, 1)
+
+
+/* Extract the IP Reassembly Traffic Flow Index */
+#define PASAHO2_LINFO_READ_TFINDEX(x)	PASAHO2_READ_BITFIELD((x)->word5, 24, 8)
+
+/* Extract the IP Reassembly Fragment count */
+#define PASAHO2_LINFO_READ_FRANCNT(x)	PASAHO2_READ_BITFIELD((x)->word5, 16, 8)
+
+/* Set the IP Reassembly Traffic Flow Index */
+#define PASAHO2_LINFO_SET_TFINDEX(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word5, (v), 24, 8)
+
+/* Set the IP Reassembly Fragment count */
+#define PASAHO2_LINFO_SET_FRANCNT(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word5, (v), 16, 8)
+
+
+/* Clear IPSEC indication bits */
+#define PASAHO2_LINFO_CLR_IPSEC(x) \
+	PASAHO2_SET_BITFIELD((x)->word3, 0, 8, 2)
+
+/* Clear IPSEC ESP indication bit */
+#define PASAHO2_LINFO_CLR_IPSEC_ESP(x) \
+	PASAHO2_SET_BITFIELD((x)->word3, 0, 8, 1)
+
+/* Claer IPSEC AH indication bit */
+#define PASAHO2_LINFO_CLR_IPSEC_AH(x) \
+	PASAHO2_SET_BITFIELD((x)->word3, 0, 9, 1)
+
+/* Clear the fragmentation found flag */
+#define PASAHO2_LINFO_CLR_FLAG_FRAG(x) \
+	PASAHO2_SET_BITFIELD((x)->word1, 0, 19, 1)
+
+/* Update the next parse start offset */
+#define PASAHO2_LINFO_SET_START_OFFSET(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 0, 8)
+
+/* Update the end of packet parse offset */
+#define PASAHO2_LINFO_SET_END_OFFSET(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word1, (v), 16, 16)
+
+/* Update the next header to parse type */
+#define PASAHO2_LINFO_SET_NXT_HDR_TYPE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word1, (v), 0, 6)
+
+/* Set the null packet flag which indicates that the packet should be dropped.
+ * This flag should be set for the null packet to be delivered to PASS when the
+ * reassembly timeout occurs */
+#define PASAHO2_LINFO_SET_NULL_PKT_IND(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 21, 1)
+
+/*
+ * PA_INV_TF_INDEX
+ * PASS-asssited IP reassembly traffic flow index to indicate
+ * that no traffic flow is available
+ */
+#define PA_INV_TF_INDEX		0xFF
+
+struct pasaho2_short_info {
+	u32	word0;
+	u32	word1;
+};
+
+/* Extract the command ID defined at */
+#define PASAHO2_SINFO_READ_CMDID(x)	PASAHO2_READ_BITFIELD((x)->word0, 29, 3)
+
+/* Extract the offset to the packet payload */
+#define PASAHO2_SINFO_RESD_PAYLOAD_OFFSET(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 16, 8)
+
+/* Extract the byte length of the payload */
+#define PASAHO2_SINFO_READ_PAYLOAD_LENGTH(x) \
+	PASAHO2_READ_BITFIELD((x)->word0, 0, 16)
+
+/* Set the offset to the payload */
+#define PASAHO2_SINFO_SET_PAYLOAD_OFFSET(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Set the payload length */
+#define PASAHO2_SINFO_SET_PAYLOAD_LENGTH(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Format the entire short info command */
+#define PASAHO2_SINFO_FORMAT_CMD(offset, len) \
+	(((offset) << 16) | (len) | (PASAHO2_SA_SHORT_INFO << 29))
+
+#define PASAHO2_HDR_BITMASK_MAC		(1 << 0)  /* MAC present */
+#define PASAHO2_HDR_BITMASK_VLAN		(1 << 1)  /* VLAN present */
+#define PASAHO2_HDR_BITMASK_MPLS		(1 << 2)  /* MPLS present */
+#define PASAHO2_HDR_BITMASK_802_3	(1 << 3)  /* 802.3 present */
+#define PASAHO2_HDR_BITMASK_PPPoE	(1 << 4)  /* PPPoE present */
+#define PASAHO2_HDR_BITMASK_IPv4		(1 << 5)  /* IPv4 present */
+#define PASAHO2_HDR_BITMASK_IPv6		(1 << 6)  /* IPv6 present */
+#define PASAHO2_HDR_BITMASK_IP_OPTS	(1 << 7)  /* IPv4 options or IPv6
+						     extension headers esent */
+#define PASAHO2_HDR_BITMASK_ESP		(1 << 8)  /* IPSEC/ESP present */
+#define PASAHO2_HDR_BITMASK_AH		(1 << 9)  /* IPSEC/AH present */
+#define PASAHO2_HDR_BITMASK_SCTP		(1 << 10) /* SCTP present */
+#define PASAHO2_HDR_BITMASK_UDP		(1 << 11) /* UDP present */
+#define PASAHO2_HDR_BITMASK_UDPLITE	(1 << 11) /* UDPLITE present */
+#define PASAHO2_HDR_BITMASK_TCP		(1 << 12) /* TCP present */
+#define PASAHO2_HDR_BITMASK_GTPU		(1 << 13) /* GTPU present */
+#define PASAHO2_HDR_BITMASK_CUSTOM	(1 << 14) /* Custom header present */
+#define PASAHO2_HDR_BITMASK_IPSEC_NAT_T	(1 << 15) /* IPSEC NAT-T present */
+
+struct pasaho2_next_route {
+	u32  word0;
+	u32  sw_info0;
+	u32  sw_info1;
+	u32  word1;
+};
+
+/*
+ * Sets the N bit which indicates the next command
+ * should be executed prior to the route command
+ */
+#define PASAHO2_SET_N(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 28, 1)
+
+/*
+ * Sets the E bit which indicates the extened
+ * parameters (packet type) are present for SRIO
+ */
+#define PASAHO2_SET_E(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 27, 1)
+
+/*
+ * Sets the destination of the route defined */
+#define PASAHO2_SET_DEST(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 24, 3)
+
+/* Specifies the flow to use for packets sent to the host */
+#define PASAHO2_SET_FLOW(x, v)	PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for packets send to the host */
+#define PASAHO2_SET_QUEUE(x, v)   PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Specifies the packet type to use for packets send to the SRIO */
+#define PASAHO2_SET_PKTTYPE(x, v) PASAHO2_SET_BITFIELD((x)->word1, (v), 24, 8)
+
+struct pasaho2_com_chk_crc {
+	u32	word0;		/* PASAHO2_chksum_command_macros */
+	u32	word1;		/* PASAHO2_chksum_command_macros */
+	u32	word2;		/* PASAHO2_chksum_command_macros */
+};
+
+/*
+ * Sets the negative 0 flag - if set a
+ * checksum computed as 0 will be sent as 0xffff
+ */
+#define PASAHO2_CHKCRC_SET_NEG0(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 23, 1)
+
+/* Sets the optional flags of the CRC/Checksum command */
+#define PASAHO2_CHKCRC_SET_CTRL(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 4)
+
+/* Sets the size of the crc in bytes */
+#define PASAHO2_CHKCRC_SET_CRCSIZE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 8,  8)
+
+/* Sets the start offset of the checksum/crc */
+#define PASAHO2_CHKCRC_SET_START(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  8)
+
+/* Sets the length of the checksum/crc */
+#define PASAHO2_CHKCRC_SET_LEN(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word1, (v), 16, 16)
+
+/* Sets the offset to where to paste the checksum/crc into the packet */
+#define PASAHO2_CHKCRC_SET_RESULT_OFF(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word1, (v), 0,  16)
+
+/* Sets the initial value of the checksum/crc */
+#define PASAHO2_CHKCRC_SET_INITVAL(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word2, (v), 16, 16)
+
+/* Sets the initial value of the 32-bit crc */
+#define PASAHO2_CHKCRC_SET_INITVAL32(x, v)	((x)->word2) = (v)
+
+
+#define PASAHO2_BPATCH_MAX_PATCH_WORDS	4
+
+struct pasaho2_com_blind_patch {
+	u32	word0;
+	u32	patch[PASAHO2_BPATCH_MAX_PATCH_WORDS];
+};
+
+
+#define PASAHO2_BPATCH_SET_PATCH_NBYTES(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, v, 24,  5)
+
+/* Sets the number of bytes to patch */
+#define PASAHO2_BPATCH_SET_PATCH_CMDSIZE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, v, 20, 4)
+
+/* Sets the size of the command in 32 bit word units */
+#define PASAHO2_BPATCH_SET_OVERWRITE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, v, 19, 1)
+
+/*
+ * Sets the overwrite flag. If set the patch will
+ * overwrite existing packet data, otherwise data is inserted
+ */
+#define PASAHO2_BPATCH_SET_OFFSET(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, v, 0,  16)
+
+/* Sets the offset to the start of the patch */
+#define PASAHO2_BPATCH_SET_PATCH_BYTE(x, byteNum, byte) \
+	((x)->patch[(byteNum) >> 2]) = \
+	PASAHO2_SET_BITFIELD((x)->patch[(byteNum) >> 2], \
+	byte, ((3 - (byteNum & 0x3)) << 3), 8)
+
+
+struct pasaho2_report_timestamp {
+	u32	word0;
+	u32	sw_info0;
+};
+
+/* Specifies the flow to use for report packets sent to the host */
+
+#define PASAHO2_SET_REPORT_FLOW(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for report packets send to the host */
+#define PASAHO2_SET_REPORT_QUEUE(x, v) \
+	PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+struct pasaho2_ip_frag {
+	u32	word0;
+};
+
+/* Set sub-command code to indicate IP Fragmentation command */
+#define PASAHO2_SET_SUB_CODE_IP_FRAG(x) \
+	PASAHO2_SET_BITFIELD((x)->word0, PASAHO2_SUB_CMD_IP_FRAG, 24, 5)
+
+/* Specifies the sub-command code */
+#define PASAHO2_SET_SUB_CODE(x, v) PASAHO2_SET_BITFIELD((x)->word0, (v), 24, 5)
+
+/* Specifies the offset to the IP header to be fragmented */
+#define PASAHO2_SET_IP_OFFSET(x, v) PASAHO2_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the MTU size */
+#define PASAHO2_SET_MTU_SIZE(x, v) PASAHO2_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+#endif /* __KERNEL__ */
+#endif /* NETCP_PASA2_HOST_H */
diff --git a/drivers/net/ethernet/ti/netcp_pasa_host.h b/drivers/net/ethernet/ti/netcp_pasa_host.h
new file mode 100644
index 0000000..bfc2899
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_pasa_host.h
@@ -0,0 +1,395 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Author: Sandeep Paulraj <s-paulraj@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef KEYSTONE_PASAHOST_H
+#define KEYSTONE_PASAHOST_H
+
+#ifdef __KERNEL__
+
+#define PASAHO_SA_SHORT_INFO		1
+
+#if 0
+#define	PASAHO_CONFIGURE		4
+#define PASAHO_PARX_PARSECMD		0
+#define PASAHO_PARX_MULTI_ROUTE		5
+#define PASAHO_PAMOD_CMPT_CHKSUM	0
+#define PASAHO_PAMOD_CMPT_CRC		1
+#define PASAHO_PAMOD_PATCH		2
+#define PASAHO_PAMOD_NROUTE		3
+#define PASAHO_PAMOD_MULTI_ROUTE	5
+#define PASAHO_PAMOD_REPORT_TIMESTAMP	6
+#define PASAHO_PAMOD_GROUP_7		7
+#define PASAHO_PAMOD_DUMMY		PASAHO_PAMOD_GROUP_7
+#define PASAHO_PAMOD_IP_FRAGMENT	PASAHO_PAMOD_GROUP_7
+#define PASAHO_SA_LONG_INFO		0
+#define PASAHO_SA_AIR_INFO		2
+
+#define PASAHO_READ_BITFIELD(a,b,c)	(((a)>>(b)) & ((1UL<<(c))-1))
+
+#define PASAHO_SET_BITFIELD(a,x,b,c)	(a) &= ~(((1UL<<(c))-1)<<(b)), \
+					(a) |= (((x) & ((1UL<<(c))-1))<<(b))
+
+#define PASAHO_SET_CMDID(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 29,3)
+
+#define PASAHO_PACFG_CMD	(((u32)PASAHO_CONFIGURE << 5) << 24)
+
+enum pasaho_header_type {
+	PASAHO_HDR_MAC        = 0,        /* MAC */
+	PASAHO_HDR_VLAN,                  /* VLAN */
+	PASAHO_HDR_MPLS,                  /* MPLS */
+	PASAHO_HDR_IPv4,                  /* IPv4 */
+	PASAHO_HDR_IPv6,                  /* IPv6 */
+	PASAHO_HDR_IPv6_EXT_HOP,          /* IPv6 hop by hop extenstion header */
+	PASAHO_HDR_IPv6_EXT_ROUTE,        /* IPv6 routing extenstion header */
+	PASAHO_HDR_IPv6_EXT_FRAG,         /* IPv6 fragmentation extention header */
+	PASAHO_HDR_IPv6_EXT_DEST,         /* IPv6 destination options header */
+	PASAHO_HDR_GRE,                   /* Generic Routing Encapsulation header */
+	PASAHO_HDR_ESP,                   /* Encapsulating Security Payload header */
+	PASAHO_HDR_ESP_DECODED,           /* Decoded Encapsulating Security Payload header */
+	PASAHO_HDR_AUTH,                  /* Authentication header */
+	PASAHO_HDR_CUSTOM_C1,             /* Custom classify 1 header */
+	PASAHO_HDR_FORCE_LOOKUP,          /* A contrived header type used with custom SRIO to force
+                                        a parse after looking at only the SRIO L0-L2 */
+	PASAHO_HDR_UNKNOWN,               /* Next header type is unknown */
+	PASAHO_HDR_UDP,                   /* User Datagram Protocol header */
+	PASAHO_HDR_UDP_LITE,              /* Lightweight User Datagram Protocol header */
+	PASAHO_HDR_TCP,                   /* Transmission Control Protocol header */
+	PASAHO_HDR_CUSTOM_C2              /* Custom classify 2 header */
+};
+
+/**
+ *  @defgroup pasahoSubCmdCode PASS Sub-Command Code
+ *  @ingroup pasaho_if_constants
+ *  @{
+ *
+ *  @name PASS Sub-Command Code
+ *  Definition of the 5-bit sub-command codes which is used to specify the group 7 commands.
+ */
+
+enum pasaho_sub_cmd_code {
+	PASAHO_SUB_CMD_DUMMY	= 0,	/* Dummy */
+	PASAHO_SUB_CMD_IP_FRAG		/* IPv4 fragmentation */
+};
+
+/**
+ *  @ingroup pasaho_if_structures
+ *  @brief  pasahoCmdInfo_t defines the general short command information
+ *
+ */
+struct pasaho_cmd_info {
+	u32	word0;		/* Control block word 0 */
+};
+
+/**
+ *  @ingroup pasaho_if_structures
+ *  @brief  pasahoLongInfo_t defines the packet parsing information in the long format.
+ *          The information is structured as an array of 32 bit values. These values
+ *          are broken down through macros. This allows the representation to be
+ *          endian independent to the hardware which operates only on 32 bit values.
+ *
+ *  @details
+ */
+struct pasaho_long_info {
+	u32   word0;	/* Control block word 0 */
+	u32   word1;	/* Control block word 1 */
+	u32   word2;	/* Control block word 2 */
+	u32   word3;	/* Control block word 3 */
+	u32   word4;	/* Control block word 4 */
+};
+
+/**
+ *  @defgroup PASAHO_long_info_command_macros  PASAHO Long Info Command Macros
+ *  @ingroup pasaho_if_macros
+ *  @{
+ *  @name PASAHO Long Info Command Macros
+ *  Macros used by the PASAHO Long Info Command
+ */
+
+/* Extract the command ID defined at */
+#define PASAHO_LINFO_READ_CMDID(x)		PASAHO_READ_BITFIELD((x)->word0,29,3)
+
+/* Extract the block length */
+#define PASAHO_LINFO_READ_RECLEN(x)		PASAHO_READ_BITFIELD((x)->word0,24,5)
+
+/* Extract the next parse start offset */
+#define PASAHO_LINFO_READ_START_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word0,0,16)
+
+/* Extract the end of packet parse offset */
+#define PASAHO_LINFO_READ_END_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word1,16,16)
+
+/* Extract the error index */
+#define PASAHO_LINFO_READ_EIDX(x)		PASAHO_READ_BITFIELD((x)->word1,11,5)
+
+/* Extract the previous match flag */
+#define PASAHO_LINFO_READ_PMATCH(x)		PASAHO_READ_BITFIELD((x)->word1,10,1)
+
+/* Extract the custom classify flag */
+#define PASAHO_LINFO_READ_C2C(x)		PASAHO_READ_BITFIELD((x)->word1,9,1)
+
+/* Extract the first parse module ID */
+#define PASAHO_LINFO_READ_L1_PDSP_ID(x)		PASAHO_READ_BITFIELD((x)->word1,6,3)
+
+/* Extract the first parse module match index */
+#define PASAHO_LINFO_READ_L1_IDX(x)		PASAHO_READ_BITFIELD((x)->word1,0,6)
+
+/* Extract the offset to the level 3 header */
+#define PASAHO_LINFO_READ_L3_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,24,8)
+
+/* Extract the offset to the level 4 header */
+#define PASAHO_LINFO_READ_L4_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,16,8)
+
+/* Extract the offset to the level 5 header */
+#define PASAHO_LINFO_READ_L5_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,8,8)
+
+/* Extract the offset to the security header */
+#define PASAHO_LINFO_READ_ESP_AH_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word2,0,8)
+
+/* Extract the bitmask of parsed header types */
+#define PASAHO_LINFO_READ_HDR_BITMASK(x)	PASAHO_READ_BITFIELD((x)->word3,21,11)
+
+/* Extract the next header to parse type */
+#define PASAHO_LINFO_READ_NXT_HDR_TYPE(x)	PASAHO_READ_BITFIELD((x)->word3,16,5)
+
+/* Extract the number of VLAN tags found */
+#define PASAHO_LINFO_READ_VLAN_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,12,4)
+
+/* Extract the number of IP headers found */
+#define PASAHO_LINFO_READ_IP_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,8,4)
+
+/* Extract the number of GRE headers found */
+#define PASAHO_LINFO_READ_GRE_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,4,4)
+
+/* Extract the fragmentation found flag */
+#define PASAHO_LINFO_READ_FLAG_FRAG(x)		PASAHO_READ_BITFIELD((x)->word3,3,1)
+
+/* Extract the incomplete IP route flag */
+#define PASAHO_LINFO_READ_FLAG_ROUTE(x)		PASAHO_READ_BITFIELD((x)->word3,2,1)
+
+/* Extract the (1-based) input EMAC port number */
+/*  0: Indicates that the packet does not enter PASS through CPSW */
+#define PASAHO_LINFO_READ_INPORT(x)		PASAHO_READ_BITFIELD((x)->word3,0,3)
+
+/* Extract the last pseudo-header checksum computed */
+#define PASAHO_LINFO_READ_PSEUDO_CHKSM(x)	PASAHO_READ_BITFIELD((x)->word4,16,16)
+
+#define PASAHO_LINFO_READ_TSTAMP_MSB(x)		PASAHO_READ_BITFIELD((x)->word4,0,16)
+
+/* Extract the IP Reassembly Traffic Flow Index */
+#define PASAHO_LINFO_READ_TFINDEX(x)		PASAHO_READ_BITFIELD((x)->word4,24,8)
+
+/* Extract the IP Reassembly Fragment count */
+#define PASAHO_LINFO_READ_FRANCNT(x)		PASAHO_READ_BITFIELD((x)->word4,16,8)
+
+/* Set the IP Reassembly Traffic Flow Index */
+#define PASAHO_LINFO_SET_TFINDEX(x, v)		PASAHO_SET_BITFIELD((x)->word4,(v),24,8)
+
+/* Set the IP Reassembly Fragment count */
+#define PASAHO_LINFO_SET_FRANCNT(x, v)		PASAHO_SET_BITFIELD((x)->word4,(v),16,8)
+
+/* Indicate whether it is an IPSEC packet */
+#define PASAHO_LINFO_IS_IPSEC(x)		PASAHO_READ_BITFIELD((x)->word3,25,2)
+
+/* Indicate whether it is an IPSEC ESP packet */
+#define PASAHO_LINFO_IS_IPSEC_ESP(x)		PASAHO_READ_BITFIELD((x)->word3,26,1)
+
+/* Indicate whether it is an IPSEC AH packet */
+#define PASAHO_LINFO_IS_IPSEC_AH(x)		PASAHO_READ_BITFIELD((x)->word3,25,1)
+
+/* Clear IPSEC indication bits */
+#define PASAHO_LINFO_CLR_IPSEC(x)		PASAHO_SET_BITFIELD((x)->word3,0,25,2)
+
+/* Clear IPSEC ESP indication bit */
+#define PASAHO_LINFO_CLR_IPSEC_ESP(x)		PASAHO_SET_BITFIELD((x)->word3,0,26,1)
+
+/* Clear IPSEC AH indication bit */
+#define PASAHO_LINFO_CLR_IPSEC_AH(x)		PASAHO_SET_BITFIELD((x)->word3,0,25,1)
+
+/* Clear the fragmentation found flag */
+#define PASAHO_LINFO_CLR_FLAG_FRAG(x)		PASAHO_SET_BITFIELD((x)->word3,0,3,1)
+
+/* Update the next parse start offset */
+#define PASAHO_LINFO_SET_START_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word0,(v),0,16)
+
+/* Update the end of packet parse offset */
+#define PASAHO_LINFO_SET_END_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word1,(v),16,16)
+
+
+/*
+ * Set the null packet flag which indicates that the packet should be dropped.
+ * This flag should be set for the null packet to be delivered to PASS when
+ * the reassembly timeout occurs
+ */
+#define PASAHO_LINFO_SET_NULL_PKT_IND(x, v)	PASAHO_SET_BITFIELD((x)->word0,(v),21,1)
+
+/*
+ * PA_INV_TF_INDEX
+ * PASS-asssited IP reassembly traffic flow index to indicate
+ * that no traffic flow is available
+ */
+#define PA_INV_TF_INDEX		0xFF
+
+struct pasaho_short_info {
+	u32	word0;
+	u32	word1;
+};
+
+/* Extract the command ID defined at */
+#define PASAHO_SINFO_READ_CMDID(x)		PASAHO_READ_BITFIELD((x)->word0,29,3)
+
+/* Extract the offset to the packet payload */
+#define PASAHO_SINFO_RESD_PAYLOAD_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word0,16,8)
+
+/* Extract the byte length of the payload */
+#define PASAHO_SINFO_READ_PAYLOAD_LENGTH(x)	PASAHO_READ_BITFIELD((x)->word0,0,16)
+
+/* Set the offset to the payload */
+#define PASAHO_SINFO_SET_PAYLOAD_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Set the payload length */
+#define PASAHO_SINFO_SET_PAYLOAD_LENGTH(x, v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+#endif
+/* Format the entire short info command */
+#define PASAHO_SINFO_FORMAT_CMD(offset, len)	(((offset) << 16) | (len) | (PASAHO_SA_SHORT_INFO << 29))
+#if 0
+#define PASAHO_HDR_BITMASK_MAC		(1 << 0)	/* MAC present */
+#define PASAHO_HDR_BITMASK_VLAN		(1 << 1)	/* VLAN present */
+#define PASAHO_HDR_BITMASK_MPLS		(1 << 2)	/* MPLS present */
+#define PASAHO_HDR_BITMASK_IP		(1 << 3)	/* IP present */
+#define PASAHO_HDR_BITMASK_ESP		(1 << 4)	/* IPSEC/ESP present */
+#define PASAHO_HDR_BITMASK_AH		(1 << 5)	/* IPSEC/AH present */
+#define PASAHO_HDR_BITMASK_UDP		(1 << 6)	/* UDP present */
+#define PASAHO_HDR_BITMASK_UDPLITE	(1 << 7)	/* UDPLITE present */
+#define PASAHO_HDR_BITMASK_TCP		(1 << 8)	/* TCP present */
+#define PASAHO_HDR_BITMASK_GRE		(1 << 9)	/* GRE present */
+#define PASAHO_HDR_BITMASK_CUSTOM	(1 << 10)	/* Custom header */
+
+struct pasaho_next_route {
+	u32  word0;
+	u32  sw_info0;
+	u32  sw_info1;
+	u32  word1;
+};
+
+/*
+ * Sets the N bit which indicates the next command
+ * should be executed prior to the route command
+ */
+#define PASAHO_SET_N(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 28, 1)
+
+/*
+ * Sets the E bit which indicates the extened
+ * parameters (packet type) are present for SRIO
+ */
+#define PASAHO_SET_E(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 27, 1)
+
+/*
+ * Sets the destination of the route defined */
+#define PASAHO_SET_DEST(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 24, 3)
+
+/* Specifies the flow to use for packets sent to the host */
+#define PASAHO_SET_FLOW(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for packets send to the host */
+#define PASAHO_SET_QUEUE(x,v)   PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Specifies the packet type to use for packets send to the SRIO */
+#define PASAHO_SET_PKTTYPE(x,v) PASAHO_SET_BITFIELD((x)->word1, (v), 24, 8)
+
+struct pasaho_com_chk_crc {
+	u32	word0;		/* PASAHO_chksum_command_macros */
+	u32	word1;		/* PASAHO_chksum_command_macros */
+	u32	word2;		/* PASAHO_chksum_command_macros */
+};
+
+/*
+ * Sets the negative 0 flag - if set a
+ * checksum computed as 0 will be sent as 0xffff
+ */
+#define PASAHO_CHKCRC_SET_NEG0(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 23, 1)
+
+/* Sets the optional flags of the CRC/Checksum command */
+#define PASAHO_CHKCRC_SET_CTRL(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Sets the start offset of the checksum/crc */
+#define PASAHO_CHKCRC_SET_START(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Sets the length of the checksum/crc */
+#define PASAHO_CHKCRC_SET_LEN(x,v)	PASAHO_SET_BITFIELD((x)->word1, (v), 16, 16)
+
+/* Sets the offset to where to paste the checksum/crc into the packet */
+#define PASAHO_CHKCRC_SET_RESULT_OFF(x,v)	PASAHO_SET_BITFIELD((x)->word1, (v), 0,  16)
+
+/* Sets the initial value of the checksum/crc */
+#define PASAHO_CHKCRC_SET_INITVAL(x,v)	PASAHO_SET_BITFIELD((x)->word2, (v), 16, 16)
+
+#define PASAHO_BPATCH_MAX_PATCH_WORDS	4
+
+struct pasaho_com_blind_patch {
+	u32	word0;
+	u32	patch[PASAHO_BPATCH_MAX_PATCH_WORDS];
+};
+
+
+#define PASAHO_BPATCH_SET_PATCH_NBYTES(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 24,  5)
+
+/* Sets the number of bytes to patch */
+#define PASAHO_BPATCH_SET_PATCH_CMDSIZE(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 20, 4)
+
+/* Sets the size of the command in 32 bit word units */
+#define PASAHO_BPATCH_SET_OVERWRITE(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 19, 1)
+
+/*
+ * Sets the overwrite flag. If set the patch will
+ * overwrite existing packet data, otherwise data is inserted
+ */
+#define PASAHO_BPATCH_SET_OFFSET(x,v)		PASAHO_SET_BITFIELD((x)->word0, v, 0,  16)
+
+/* Sets the offset to the start of the patch */
+#define PASAHO_BPATCH_SET_PATCH_BYTE(x, byteNum, byte)  (x)->patch[(byteNum) >> 2] = \
+		PASAHO_SET_BITFIELD((x)->patch[(byteNum) >> 2], byte, ((3 - (byteNum & 0x3)) << 3), 8)
+
+
+struct pasaho_report_timestamp {
+	u32	word0;
+	u32	sw_info0;
+};
+
+/* Specifies the flow to use for report packets sent to the host */
+
+#define PASAHO_SET_REPORT_FLOW(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for report packets send to the host */
+#define PASAHO_SET_REPORT_QUEUE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+struct pasaho_ip_frag {
+	u32	word0;
+};
+
+/* Set sub-command code to indicate IP Fragmentation command */
+#define PASAHO_SET_SUB_CODE_IP_FRAG(x) PASAHO_SET_BITFIELD((x)->word0, PASAHO_SUB_CMD_IP_FRAG, 24, 5)
+
+/* Specifies the sub-command code */
+#define PASAHO_SET_SUB_CODE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 24, 5)
+
+/* Specifies the offset to the IP header to be fragmented */
+#define PASAHO_SET_IP_OFFSET(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the MTU size */
+#define PASAHO_SET_MTU_SIZE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* KEYSTONE_PASAHOST_H */
diff --git a/drivers/net/ethernet/ti/netcp_sa.c b/drivers/net/ethernet/ti/netcp_sa.c
new file mode 100644
index 0000000..0d5cd9a
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_sa.c
@@ -0,0 +1,471 @@
+/*
+ * Copyright (C) 2012-2016 Texas Instruments Incorporated
+ * Authors: Sandeep Nair <sandeep_n@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/interrupt.h>
+#include <linux/byteorder/generic.h>
+#include <linux/platform_device.h>
+#include <linux/errqueue.h>
+
+#include <net/ipv6.h>
+#include <net/xfrm.h>
+
+#include "netcp.h"
+#include "netcp_pasa_host.h"
+
+#define NET_SA_CHAN_PRFX "satx"
+
+struct sa_device {
+	struct device		*dev;
+	struct netcp_device	*netcp_device;
+	struct device_node	*node;
+	u32			tx_queue_id;
+	u32			multi_if;
+};
+
+struct sa_intf {
+	struct net_device	*net_device;
+	const char		*tx_chan_name;
+	struct netcp_tx_pipe	tx_pipe;
+	u32			natt_port;
+	u32			netcp_ver; /* 0: NETCP 1.0, 1: NSS 1.0 */
+};
+
+struct ipsecmgr_mod_sa_ctx_info {
+	atomic_t	refcnt;
+	int		len;
+	int		majic;
+	u32		word0;
+	u32		word1;
+	u16		flow_id;
+};
+
+static inline void calc_ipv6_esp_info(const struct sk_buff *skb,
+					u16 *p_offset, u16 *p_len)
+{
+	const struct ipv6hdr *ipv6h = ipv6_hdr(skb);
+
+	/* type of the 1st exthdr */
+	WARN_ON(ipv6_hdr(skb)->nexthdr != NEXTHDR_ESP);
+
+	*p_offset = (u16)(skb_network_header(skb) -
+			skb->data) + skb_network_header_len(skb);
+
+	/* payload length */
+	*p_len = ntohs(ipv6h->payload_len);
+}
+
+#define	SA_TXHOOK_ORDER	30
+#define SA_IPSECMAN_MAJIC 0xdeadfeed
+static int sa_tx_hook(int order, void *data, struct netcp_packet *p_info)
+{
+	struct sa_intf *sa_intf = data;
+	u16 offset, len, ihl;
+	u32 *psdata, *swinfo;
+	const struct iphdr *iph;
+	struct ipsecmgr_mod_sa_ctx_info *ctx_info =
+			(struct ipsecmgr_mod_sa_ctx_info *)p_info->skb->sp;
+
+	if ((!ctx_info) || (ctx_info->majic != SA_IPSECMAN_MAJIC))
+		return 0;
+
+	iph = ip_hdr(p_info->skb);
+
+	if (iph->version == IPVERSION) {
+		ihl = iph->ihl * 4;
+		if (iph->protocol == IPPROTO_UDP) {
+			/* UDP encapsulation for IPSec NAT-T */
+			offset = (ulong)(skb_network_header(p_info->skb) -
+					p_info->skb->data) + ihl +
+					sizeof(struct udphdr);
+			len = ntohs(iph->tot_len) - ihl - sizeof(struct udphdr);
+		} else if (iph->protocol == IPPROTO_ESP) {
+			offset = (ulong)(skb_network_header(p_info->skb) -
+			p_info->skb->data) + ihl;
+			len = ntohs(iph->tot_len) - ihl;
+		} else
+			return 0;
+	} else if (iph->version == 6) {
+		if ((ipv6_hdr(p_info->skb)->nexthdr) == IPPROTO_ESP)
+			/* need to calculate offset to where ESP header
+			 * starts and total length of the payload
+			 */
+			calc_ipv6_esp_info(p_info->skb, &offset, &len);
+		else
+			return 0;
+	} else
+		return 0;
+
+	psdata = netcp_push_psdata(p_info, (2 * sizeof(u32)));
+	if (!psdata)
+		return -ENOMEM;
+
+	psdata[0] = PASAHO_SINFO_FORMAT_CMD(offset, len);
+	psdata[1] = 0;
+	swinfo = &p_info->epib[1];
+	swinfo[0] = ctx_info->word0 | 0x40000000L;
+	swinfo[1] = ctx_info->word1;
+	swinfo[2] &= 0xff000000;
+	swinfo[2] |= ((ctx_info->flow_id) & 0xFF) << 16 |
+		p_info->tx_pipe->dma_queue_id;
+
+	p_info->tx_pipe = &sa_intf->tx_pipe;
+	ctx_info->len = 0;
+	secpath_reset(p_info->skb);
+	return 0;
+}
+
+#define SA_RXHOOK_ORDER	30
+
+#define ETH_TYPE_OFFSET	12
+#define ETH_HDR_LEN	14
+
+/* Version 0 of sa_rx_hook definitions (for NETCP 1.0 on K2HK) */
+#define BITS(x) (BIT(x) - 1)
+#define BITMASK(n, s)          (BITS(n) << (s))
+#define SA_IS_IPSEC_ESP_MASK	BIT(25)
+#define SA_IS_FLAG_FRAG_MASK	BIT(3)
+#define SA_NUM_IP_HEADERS_SHIFT	8
+#define SA_NUM_IP_HEADERS_MASK BITMASK(3, SA_NUM_IP_HEADERS_SHIFT)
+#define SA_NUM_VLAN_HEADERS_SHIFT	14
+#define SA_NUM_VLAN_HEADERS_MASK BITMASK(2, SA_NUM_VLAN_HEADERS_SHIFT)
+
+static int sa_rx_hook(int order, void *data, struct netcp_packet *p_info)
+{
+	struct sk_buff *skb = p_info->skb;
+	struct sa_intf *sa = data;
+
+	/* See if packet is a fragment, if it is not then return out.
+	 * This is word 3, bit 3 of metadata psdata
+	 */
+	if (!(p_info->psdata[3] & SA_IS_FLAG_FRAG_MASK))
+		return 0;
+
+	/* Make sure there is just one IP header. If 2 ipheaders then
+	 * we passed IPSEC; so return out.
+	 */
+	if (((p_info->psdata[3] & SA_NUM_IP_HEADERS_MASK) >>
+	      SA_NUM_IP_HEADERS_SHIFT) != 1)
+		return 0;
+
+	/* Check to see if this is an ESP packet.
+	 * ESP packet indication is in word 3, bit 25 of psdata
+	 */
+	if (p_info->psdata[3] & SA_IS_IPSEC_ESP_MASK) {
+
+		/* Packet is ESP, a fragment and does not have 2
+		 * ipheaders, so set ignore_df flag
+		 */
+		skb->ignore_df = 1;
+		return 0;
+	}
+
+	/* If we have a NAT-T port set, check for NAT-T packet */
+	if (sa->natt_port) {
+		struct iphdr *ip_hdr;
+		uint16_t e_type;
+		int vlan;
+
+		/* Count how many VLAN headers we have */
+		vlan = ((p_info->psdata[3] & SA_NUM_VLAN_HEADERS_MASK) >>
+			 SA_NUM_VLAN_HEADERS_SHIFT);
+
+		/* Return out for IPv6, nothing to be done.
+		 * Ethertype follows the MAC and optional VLAN tags.
+		 */
+		e_type = *((uint16_t *)skb->data +
+				     ((ETH_TYPE_OFFSET / 2) + (vlan << 1)));
+		if (ntohs(e_type) == ETH_P_IPV6)
+			return 0;
+
+		/* Skip over Eth header to IP header.
+		 * Eth header is 14 bytes + (4 bytes per VLAN header).
+		 */
+		ip_hdr = (struct iphdr *)(skb->data +
+					 (ETH_HDR_LEN + (vlan << 2)));
+
+		/* Check if the protocol is UDP */
+		if (ip_hdr->protocol == IPPROTO_UDP) {
+
+			/* Get the UDP header.
+			 * It follows the IP header + optional words;
+			 * calculate offset with IHL
+			 */
+			struct udphdr *udp_hdr;
+			udp_hdr = (struct udphdr *)
+				  ((u_char *)ip_hdr + (ip_hdr->ihl << 2));
+
+			/* Check if the source or destination ports ==
+			 * NAT-T port. If so, it is a NAT-T packet;
+			 * set ignore_df flag
+			 */
+			if (ntohs(udp_hdr->dest) == sa->natt_port  ||
+			    ntohs(udp_hdr->source) == sa->natt_port)
+				skb->ignore_df = 1;
+		}
+	}
+
+	return 0;
+}
+
+/* Version 1 of sa_rx_hook definitions (for NSS 1.0 on K2L and K2E) */
+#define SA_IS_IPSEC_ESP_MASK_VER1	BIT(8)
+#define SA_IS_FLAG_FRAG_MASK_VER1	BIT(19)
+#define SA_NUM_IP_HEADERS_SHIFT_VER1	0
+#define SA_NUM_IP_HEADERS_MASK_VER1	BITMASK(3, SA_NUM_IP_HEADERS_SHIFT_VER1)
+#define SA_NUM_VLAN_HEADERS_SHIFT_VER1	6
+#define SA_NUM_VLAN_HEADERS_MASK_VER1	\
+				BITMASK(2, SA_NUM_VLAN_HEADERS_SHIFT_VER1)
+
+static int sa_rx_hook_ver1(int order, void *data, struct netcp_packet *p_info)
+{
+	struct sk_buff *skb = p_info->skb;
+	struct sa_intf *sa = data;
+
+	/* See if packet is a fragment, if it is not then return out.
+	 * This is word 0, bit 19 of metadata psdata
+	 */
+	if (!(p_info->psdata[0] & SA_IS_FLAG_FRAG_MASK_VER1))
+		return 0;
+
+	/* Make sure there is just one IP header. If 2 ipheaders then
+	 * we passed IPSEC; so return out.
+	 */
+	if (((p_info->psdata[4] & SA_NUM_IP_HEADERS_MASK_VER1) >>
+	     SA_NUM_IP_HEADERS_SHIFT_VER1) != 1)
+		return 0;
+
+	/* Check to see if this is an ESP packet.
+	 * ESP packet indication is in word 3, bit 8 of psdata
+	 */
+	if (p_info->psdata[3] & SA_IS_IPSEC_ESP_MASK_VER1) {
+
+		/* Packet is ESP, a fragment and does not have 2
+		 * ipheaders, so set ignore_df flag
+		 */
+		skb->ignore_df = 1;
+		return 0;
+	}
+
+	/* If we have a NAT-T port set, check for NAT-T packet */
+	if (sa->natt_port) {
+		struct iphdr *ip_hdr;
+		uint16_t e_type;
+		int vlan;
+
+		/* Count how many VLAN headers we have */
+		vlan = ((p_info->psdata[4] & SA_NUM_VLAN_HEADERS_MASK_VER1) >>
+			 SA_NUM_VLAN_HEADERS_SHIFT_VER1);
+
+		/* Return out for IPv6, nothing to be done.
+		 * Ethertype follows the MAC and optional VLAN tags.
+		 */
+		e_type = *((uint16_t *)skb->data +
+				     ((ETH_TYPE_OFFSET / 2) + (vlan << 1)));
+		if (ntohs(e_type) == ETH_P_IPV6)
+			return 0;
+
+		/* Skip over Eth header to IP header.
+		 * Eth header is 14 bytes + (4 bytes per VLAN header).
+		 */
+		ip_hdr = (struct iphdr *)(skb->data +
+					 (ETH_HDR_LEN + (vlan << 2)));
+
+		/* Check if the protocol is UDP */
+		if (ip_hdr->protocol == IPPROTO_UDP) {
+
+			/* Get the UDP header.
+			 * It follows the IP header; calculate with IHL
+			 */
+			struct udphdr *udp_hdr;
+			udp_hdr = (struct udphdr *)
+				  ((u_char *)ip_hdr + (ip_hdr->ihl << 2));
+
+			/* check if the source or destination ports ==
+			 * NAT-T port. If so, it is a NAT-T packet;
+			 * set ignore_df flag
+			 */
+			if (ntohs(udp_hdr->dest) == sa->natt_port  ||
+			    ntohs(udp_hdr->source) == sa->natt_port)
+				skb->ignore_df = 1;
+		}
+	}
+
+	return 0;
+}
+
+static int sa_close(void *intf_priv, struct net_device *ndev)
+{
+	struct sa_intf *sa_intf = (struct sa_intf *)intf_priv;
+	struct netcp_intf *netcp_intf = netdev_priv(ndev);
+
+	netcp_unregister_txhook(netcp_intf, SA_TXHOOK_ORDER, sa_tx_hook, sa_intf);
+	if (sa_intf->netcp_ver == 1)
+		netcp_unregister_rxhook(netcp_intf, SA_RXHOOK_ORDER,
+					sa_rx_hook_ver1, sa_intf);
+	else
+		netcp_unregister_rxhook(netcp_intf, SA_RXHOOK_ORDER,
+					sa_rx_hook, sa_intf);
+	netcp_txpipe_close(&sa_intf->tx_pipe);
+
+	return 0;
+}
+
+static int sa_open(void *intf_priv, struct net_device *ndev)
+{
+	struct sa_intf *sa_intf = (struct sa_intf *)intf_priv;
+	struct netcp_intf *netcp_intf = netdev_priv(ndev);
+	int ret;
+
+	/* Open the SA IPSec data transmit channel */
+	ret = netcp_txpipe_open(&sa_intf->tx_pipe);
+	if (ret)
+		return ret;
+
+	netcp_register_txhook(netcp_intf, SA_TXHOOK_ORDER, sa_tx_hook, sa_intf);
+	if (sa_intf->netcp_ver == 1)
+		netcp_register_rxhook(netcp_intf, SA_RXHOOK_ORDER,
+					sa_rx_hook_ver1, sa_intf);
+	else
+		netcp_register_rxhook(netcp_intf, SA_RXHOOK_ORDER,
+					sa_rx_hook, sa_intf);
+	return 0;
+}
+
+static int sa_attach(void *inst_priv, struct net_device *ndev,
+		     struct device_node *node, void **intf_priv)
+{
+	struct sa_device *sa_dev = inst_priv;
+	struct sa_intf *sa_intf;
+	int ret = 0;
+
+	sa_intf = devm_kzalloc(sa_dev->dev, sizeof(struct sa_intf), GFP_KERNEL);
+	if (!sa_intf) {
+		dev_err(sa_dev->dev, "memory allocation failed\n");
+		return -ENOMEM;
+	}
+
+	ret = of_property_read_string(node, "ti,tx-channel",
+				      &sa_intf->tx_chan_name);
+	if (ret < 0) {
+		dev_err(sa_dev->dev, "missing \"ti,tx-channel\" parameter\n");
+		return -EINVAL;
+	}
+
+	sa_intf->net_device = ndev;
+	*intf_priv = sa_intf;
+	netcp_txpipe_init(&sa_intf->tx_pipe, sa_dev->netcp_device,
+			  sa_intf->tx_chan_name, sa_dev->tx_queue_id);
+	dev_dbg(sa_dev->dev, "keystone-sa attached for %s\n", node->name);
+
+	ret = of_property_read_u32(sa_dev->node, "natt-port",
+				   &sa_intf->natt_port);
+	if (ret < 0)
+		sa_intf->natt_port = 0;
+
+	ret = of_property_read_u32(sa_dev->node, "netcp_ver",
+				   &sa_intf->netcp_ver);
+	if (ret < 0)
+		sa_intf->netcp_ver = 0;
+
+	return 0;
+}
+
+static int sa_release(void *intf_priv)
+{
+	struct sa_intf *sa_intf = intf_priv;
+	kfree(sa_intf);
+
+	return 0;
+}
+
+static int sa_remove(struct netcp_device *netcp_device, void *inst_priv)
+{
+
+	struct sa_device *sa_dev = inst_priv;
+	kfree(sa_dev);
+
+	return 0;
+}
+
+static int sa_probe(struct netcp_device *netcp_device,
+		    struct device *dev,
+		    struct device_node *node,
+		    void **inst_priv)
+{
+	struct sa_device *sa_dev;
+	int ret = 0;
+
+	if (!node) {
+		dev_err(dev, "device tree info unavailable\n");
+		return -ENODEV;
+	}
+
+	sa_dev = devm_kzalloc(dev, sizeof(struct sa_device), GFP_KERNEL);
+	if (!sa_dev) {
+		dev_err(dev, "memory allocation failed\n");
+		return -ENOMEM;
+	}
+	*inst_priv = sa_dev;
+	sa_dev->dev = dev;
+	sa_dev->netcp_device = netcp_device;
+	sa_dev->node = node;
+
+	if (of_find_property(node, "multi-interface", NULL))
+		sa_dev->multi_if = 1;
+
+	ret = of_property_read_u32(node, "tx-submit-queue",
+				   &sa_dev->tx_queue_id);
+	if (ret < 0) {
+		dev_err(dev, "missing tx-submit-queue parameter, err %d\n", ret);
+		sa_dev->tx_queue_id = 646;
+	}
+	dev_dbg(dev, "tx-submit-queue %u\n", sa_dev->tx_queue_id);
+
+	return 0;
+}
+
+static struct netcp_module sa_module = {
+	.name		= "netcp-sa",
+	.owner		= THIS_MODULE,
+	.probe		= sa_probe,
+	.open		= sa_open,
+	.close		= sa_close,
+	.remove		= sa_remove,
+	.attach		= sa_attach,
+	.release	= sa_release,
+};
+
+static int __init keystone_sa_init(void)
+{
+	return netcp_register_module(&sa_module);
+}
+module_init(keystone_sa_init);
+
+static void __exit keystone_sa_exit(void)
+{
+	netcp_unregister_module(&sa_module);
+}
+module_exit(keystone_sa_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("IPSec driver for Keystone devices");
-- 
1.9.1

