From 59e3f80e593d8f6e2450195814c89b7155f7fcf4 Mon Sep 17 00:00:00 2001
From: WingMan Kwok <w-kwok2@ti.com>
Date: Mon, 20 Jun 2016 07:14:02 -0400
Subject: [PATCH 39/43] phy: core: add API to support phy reset

In certain situations, such as after a remote device
is restarted, a PHY needs to be reset in order to
regain synchronization with the remote device.

The reset does not necessarily mean a complete restart
and/or reconfigurration of the PHY.  It may just be the
toggling of one bit in one register or the reconfiguration
of a small subset of the registers of the PHY.

This patch adds a new API to support the reset of a
PHY in these situations.

Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
---
 Documentation/phy.txt   |  8 ++++++++
 drivers/phy/phy-core.c  | 32 ++++++++++++++++++++++++++++++++
 include/linux/phy/phy.h |  9 +++++++++
 3 files changed, 49 insertions(+)

diff --git a/Documentation/phy.txt b/Documentation/phy.txt
index b388c5a..be26add 100644
--- a/Documentation/phy.txt
+++ b/Documentation/phy.txt
@@ -155,3 +155,11 @@ void phy_remove_lookup(struct phy *phy, const char *con_id, const char *dev_id);
 
 The documentation for PHY dt binding can be found @
 Documentation/devicetree/bindings/phy/phy-bindings.txt
+
+10. Resetting a PHY
+
+At runtime, it may happen that a PHY needs to be reset without being shutdown
+completely and then restart in order to get in sync again with remote
+partner. The framework provides the following reset API for this purpose.
+
+int phy_reset(struct phy *phy);
diff --git a/drivers/phy/phy-core.c b/drivers/phy/phy-core.c
index e7e574d..d65b2ce 100644
--- a/drivers/phy/phy-core.c
+++ b/drivers/phy/phy-core.c
@@ -244,6 +244,38 @@ out:
 }
 EXPORT_SYMBOL_GPL(phy_init);
 
+/**
+ * phy_reset() - resets a PHY device without shutting down
+ * @phy - the phy to be reset
+ *
+ * During runtime, the PHY may need to be reset in order to
+ * re-establish connection etc without being shut down or exit.
+ */
+int phy_reset(struct phy *phy)
+{
+	int ret;
+
+	if (!phy)
+		return 0;
+
+	ret = phy_pm_runtime_get_sync(phy);
+	if (ret < 0 && ret != -ENOTSUPP)
+		return ret;
+	ret = 0; /* Override possible ret == -ENOTSUPP */
+
+	mutex_lock(&phy->mutex);
+	if (phy->ops->reset) {
+		ret = phy->ops->reset(phy);
+		if (ret < 0)
+			dev_dbg(&phy->dev, "phy reset failed --> %d\n", ret);
+	}
+
+	mutex_unlock(&phy->mutex);
+	phy_pm_runtime_put(phy);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(phy_reset);
+
 int phy_exit(struct phy *phy)
 {
 	int ret;
diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 8cf05e3..81177bf 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -33,6 +33,7 @@ struct phy;
 struct phy_ops {
 	int	(*init)(struct phy *phy);
 	int	(*exit)(struct phy *phy);
+	int	(*reset)(struct phy *phy);
 	int	(*power_on)(struct phy *phy);
 	int	(*power_off)(struct phy *phy);
 	struct module *owner;
@@ -116,6 +117,7 @@ int phy_pm_runtime_put_sync(struct phy *phy);
 void phy_pm_runtime_allow(struct phy *phy);
 void phy_pm_runtime_forbid(struct phy *phy);
 int phy_init(struct phy *phy);
+int phy_reset(struct phy *phy);
 int phy_exit(struct phy *phy);
 int phy_power_on(struct phy *phy);
 int phy_power_off(struct phy *phy);
@@ -203,6 +205,13 @@ static inline int phy_init(struct phy *phy)
 	return -ENOSYS;
 }
 
+static int phy_reset(struct phy *phy)
+{
+	if (!phy)
+		return 0;
+	return -ENOSYS;
+}
+
 static inline int phy_exit(struct phy *phy)
 {
 	if (!phy)
-- 
1.9.1

